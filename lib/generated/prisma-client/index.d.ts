
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Client
 * 
 */
export type Client = $Result.DefaultSelection<Prisma.$ClientPayload>
/**
 * Model Agrotest
 * 
 */
export type Agrotest = $Result.DefaultSelection<Prisma.$AgrotestPayload>
/**
 * Model TestParameter
 * 
 */
export type TestParameter = $Result.DefaultSelection<Prisma.$TestParameterPayload>
/**
 * Model Sample
 * 
 */
export type Sample = $Result.DefaultSelection<Prisma.$SamplePayload>
/**
 * Model TestResult
 * 
 */
export type TestResult = $Result.DefaultSelection<Prisma.$TestResultPayload>
/**
 * Model ComparisonRule
 * 
 */
export type ComparisonRule = $Result.DefaultSelection<Prisma.$ComparisonRulePayload>
/**
 * Model Pricing
 * 
 */
export type Pricing = $Result.DefaultSelection<Prisma.$PricingPayload>
/**
 * Model Institute
 * 
 */
export type Institute = $Result.DefaultSelection<Prisma.$InstitutePayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model OrderTestParameter
 * 
 */
export type OrderTestParameter = $Result.DefaultSelection<Prisma.$OrderTestParameterPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ClientType: {
  FARMER: 'FARMER',
  GOVT_ORG: 'GOVT_ORG',
  PRIVATE: 'PRIVATE'
};

export type ClientType = (typeof ClientType)[keyof typeof ClientType]


export const SampleType: {
  SOIL: 'SOIL',
  WATER: 'WATER',
  FERTILIZER: 'FERTILIZER'
};

export type SampleType = (typeof SampleType)[keyof typeof SampleType]


export const AnalysisType: {
  ROUTINE: 'ROUTINE',
  SPECIAL: 'SPECIAL',
  RESEARCH: 'RESEARCH',
  Atomic_Absorption: 'Atomic_Absorption',
  Spectrophotmetric: 'Spectrophotmetric',
  Vacuum_Desiccator: 'Vacuum_Desiccator',
  OLSEN: 'OLSEN',
  BRAY: 'BRAY'
};

export type AnalysisType = (typeof AnalysisType)[keyof typeof AnalysisType]


export const SoilCategory: {
  BOTH: 'BOTH',
  UPLAND: 'UPLAND',
  WETLAND: 'WETLAND'
};

export type SoilCategory = (typeof SoilCategory)[keyof typeof SoilCategory]


export const ComparisonType: {
  GREATER_THAN: 'GREATER_THAN',
  LESS_THAN: 'LESS_THAN',
  BETWEEN: 'BETWEEN'
};

export type ComparisonType = (typeof ComparisonType)[keyof typeof ComparisonType]


export const InvoiceStatus: {
  PAID: 'PAID',
  DUE: 'DUE',
  CANCELLED: 'CANCELLED'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const ReportStatus: {
  DRAFT: 'DRAFT',
  PENDING_REVIEW: 'PENDING_REVIEW',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ISSUED: 'ISSUED'
};

export type ReportStatus = (typeof ReportStatus)[keyof typeof ReportStatus]


export const OrderStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  TESTING_COMPLETED: 'TESTING_COMPLETED',
  REPORT_GENERATED: 'REPORT_GENERATED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type OrderStatus = (typeof OrderStatus)[keyof typeof OrderStatus]


export const SampleStatus: {
  PENDING: 'PENDING',
  IN_LAB: 'IN_LAB',
  TESTING: 'TESTING',
  TEST_COMPLETED: 'TEST_COMPLETED',
  REPORT_READY: 'REPORT_READY',
  ISSUED: 'ISSUED',
  CANCELLED: 'CANCELLED'
};

export type SampleStatus = (typeof SampleStatus)[keyof typeof SampleStatus]

}

export type ClientType = $Enums.ClientType

export const ClientType: typeof $Enums.ClientType

export type SampleType = $Enums.SampleType

export const SampleType: typeof $Enums.SampleType

export type AnalysisType = $Enums.AnalysisType

export const AnalysisType: typeof $Enums.AnalysisType

export type SoilCategory = $Enums.SoilCategory

export const SoilCategory: typeof $Enums.SoilCategory

export type ComparisonType = $Enums.ComparisonType

export const ComparisonType: typeof $Enums.ComparisonType

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type ReportStatus = $Enums.ReportStatus

export const ReportStatus: typeof $Enums.ReportStatus

export type OrderStatus = $Enums.OrderStatus

export const OrderStatus: typeof $Enums.OrderStatus

export type SampleStatus = $Enums.SampleStatus

export const SampleStatus: typeof $Enums.SampleStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.client`: Exposes CRUD operations for the **Client** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.client.findMany()
    * ```
    */
  get client(): Prisma.ClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agrotest`: Exposes CRUD operations for the **Agrotest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agrotests
    * const agrotests = await prisma.agrotest.findMany()
    * ```
    */
  get agrotest(): Prisma.AgrotestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testParameter`: Exposes CRUD operations for the **TestParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestParameters
    * const testParameters = await prisma.testParameter.findMany()
    * ```
    */
  get testParameter(): Prisma.TestParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sample`: Exposes CRUD operations for the **Sample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Samples
    * const samples = await prisma.sample.findMany()
    * ```
    */
  get sample(): Prisma.SampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testResult`: Exposes CRUD operations for the **TestResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TestResults
    * const testResults = await prisma.testResult.findMany()
    * ```
    */
  get testResult(): Prisma.TestResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comparisonRule`: Exposes CRUD operations for the **ComparisonRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComparisonRules
    * const comparisonRules = await prisma.comparisonRule.findMany()
    * ```
    */
  get comparisonRule(): Prisma.ComparisonRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricing`: Exposes CRUD operations for the **Pricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pricings
    * const pricings = await prisma.pricing.findMany()
    * ```
    */
  get pricing(): Prisma.PricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.institute`: Exposes CRUD operations for the **Institute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Institutes
    * const institutes = await prisma.institute.findMany()
    * ```
    */
  get institute(): Prisma.InstituteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderTestParameter`: Exposes CRUD operations for the **OrderTestParameter** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderTestParameters
    * const orderTestParameters = await prisma.orderTestParameter.findMany()
    * ```
    */
  get orderTestParameter(): Prisma.OrderTestParameterDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Client: 'Client',
    Agrotest: 'Agrotest',
    TestParameter: 'TestParameter',
    Sample: 'Sample',
    TestResult: 'TestResult',
    ComparisonRule: 'ComparisonRule',
    Pricing: 'Pricing',
    Institute: 'Institute',
    Order: 'Order',
    OrderItem: 'OrderItem',
    OrderTestParameter: 'OrderTestParameter',
    Invoice: 'Invoice',
    Report: 'Report'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "client" | "agrotest" | "testParameter" | "sample" | "testResult" | "comparisonRule" | "pricing" | "institute" | "order" | "orderItem" | "orderTestParameter" | "invoice" | "report"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Client: {
        payload: Prisma.$ClientPayload<ExtArgs>
        fields: Prisma.ClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findFirst: {
            args: Prisma.ClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          findMany: {
            args: Prisma.ClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          create: {
            args: Prisma.ClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          createMany: {
            args: Prisma.ClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          delete: {
            args: Prisma.ClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          update: {
            args: Prisma.ClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          deleteMany: {
            args: Prisma.ClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>[]
          }
          upsert: {
            args: Prisma.ClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientPayload>
          }
          aggregate: {
            args: Prisma.ClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClient>
          }
          groupBy: {
            args: Prisma.ClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientCountArgs<ExtArgs>
            result: $Utils.Optional<ClientCountAggregateOutputType> | number
          }
        }
      }
      Agrotest: {
        payload: Prisma.$AgrotestPayload<ExtArgs>
        fields: Prisma.AgrotestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgrotestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgrotestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>
          }
          findFirst: {
            args: Prisma.AgrotestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgrotestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>
          }
          findMany: {
            args: Prisma.AgrotestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>[]
          }
          create: {
            args: Prisma.AgrotestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>
          }
          createMany: {
            args: Prisma.AgrotestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgrotestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>[]
          }
          delete: {
            args: Prisma.AgrotestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>
          }
          update: {
            args: Prisma.AgrotestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>
          }
          deleteMany: {
            args: Prisma.AgrotestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgrotestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgrotestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>[]
          }
          upsert: {
            args: Prisma.AgrotestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgrotestPayload>
          }
          aggregate: {
            args: Prisma.AgrotestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgrotest>
          }
          groupBy: {
            args: Prisma.AgrotestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgrotestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgrotestCountArgs<ExtArgs>
            result: $Utils.Optional<AgrotestCountAggregateOutputType> | number
          }
        }
      }
      TestParameter: {
        payload: Prisma.$TestParameterPayload<ExtArgs>
        fields: Prisma.TestParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>
          }
          findFirst: {
            args: Prisma.TestParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>
          }
          findMany: {
            args: Prisma.TestParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>[]
          }
          create: {
            args: Prisma.TestParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>
          }
          createMany: {
            args: Prisma.TestParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>[]
          }
          delete: {
            args: Prisma.TestParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>
          }
          update: {
            args: Prisma.TestParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>
          }
          deleteMany: {
            args: Prisma.TestParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>[]
          }
          upsert: {
            args: Prisma.TestParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestParameterPayload>
          }
          aggregate: {
            args: Prisma.TestParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestParameter>
          }
          groupBy: {
            args: Prisma.TestParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestParameterCountArgs<ExtArgs>
            result: $Utils.Optional<TestParameterCountAggregateOutputType> | number
          }
        }
      }
      Sample: {
        payload: Prisma.$SamplePayload<ExtArgs>
        fields: Prisma.SampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          findFirst: {
            args: Prisma.SampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          findMany: {
            args: Prisma.SampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>[]
          }
          create: {
            args: Prisma.SampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          createMany: {
            args: Prisma.SampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>[]
          }
          delete: {
            args: Prisma.SampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          update: {
            args: Prisma.SampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          deleteMany: {
            args: Prisma.SampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SampleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>[]
          }
          upsert: {
            args: Prisma.SampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SamplePayload>
          }
          aggregate: {
            args: Prisma.SampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSample>
          }
          groupBy: {
            args: Prisma.SampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SampleCountArgs<ExtArgs>
            result: $Utils.Optional<SampleCountAggregateOutputType> | number
          }
        }
      }
      TestResult: {
        payload: Prisma.$TestResultPayload<ExtArgs>
        fields: Prisma.TestResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TestResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TestResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          findFirst: {
            args: Prisma.TestResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TestResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          findMany: {
            args: Prisma.TestResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          create: {
            args: Prisma.TestResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          createMany: {
            args: Prisma.TestResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TestResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          delete: {
            args: Prisma.TestResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          update: {
            args: Prisma.TestResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          deleteMany: {
            args: Prisma.TestResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TestResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TestResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>[]
          }
          upsert: {
            args: Prisma.TestResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TestResultPayload>
          }
          aggregate: {
            args: Prisma.TestResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTestResult>
          }
          groupBy: {
            args: Prisma.TestResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<TestResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.TestResultCountArgs<ExtArgs>
            result: $Utils.Optional<TestResultCountAggregateOutputType> | number
          }
        }
      }
      ComparisonRule: {
        payload: Prisma.$ComparisonRulePayload<ExtArgs>
        fields: Prisma.ComparisonRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComparisonRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComparisonRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>
          }
          findFirst: {
            args: Prisma.ComparisonRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComparisonRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>
          }
          findMany: {
            args: Prisma.ComparisonRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>[]
          }
          create: {
            args: Prisma.ComparisonRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>
          }
          createMany: {
            args: Prisma.ComparisonRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComparisonRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>[]
          }
          delete: {
            args: Prisma.ComparisonRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>
          }
          update: {
            args: Prisma.ComparisonRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>
          }
          deleteMany: {
            args: Prisma.ComparisonRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComparisonRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComparisonRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>[]
          }
          upsert: {
            args: Prisma.ComparisonRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComparisonRulePayload>
          }
          aggregate: {
            args: Prisma.ComparisonRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComparisonRule>
          }
          groupBy: {
            args: Prisma.ComparisonRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComparisonRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComparisonRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ComparisonRuleCountAggregateOutputType> | number
          }
        }
      }
      Pricing: {
        payload: Prisma.$PricingPayload<ExtArgs>
        fields: Prisma.PricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>
          }
          findFirst: {
            args: Prisma.PricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>
          }
          findMany: {
            args: Prisma.PricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>[]
          }
          create: {
            args: Prisma.PricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>
          }
          createMany: {
            args: Prisma.PricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>[]
          }
          delete: {
            args: Prisma.PricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>
          }
          update: {
            args: Prisma.PricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>
          }
          deleteMany: {
            args: Prisma.PricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PricingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>[]
          }
          upsert: {
            args: Prisma.PricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingPayload>
          }
          aggregate: {
            args: Prisma.PricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricing>
          }
          groupBy: {
            args: Prisma.PricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingCountArgs<ExtArgs>
            result: $Utils.Optional<PricingCountAggregateOutputType> | number
          }
        }
      }
      Institute: {
        payload: Prisma.$InstitutePayload<ExtArgs>
        fields: Prisma.InstituteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstituteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstituteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          findFirst: {
            args: Prisma.InstituteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstituteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          findMany: {
            args: Prisma.InstituteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>[]
          }
          create: {
            args: Prisma.InstituteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          createMany: {
            args: Prisma.InstituteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstituteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>[]
          }
          delete: {
            args: Prisma.InstituteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          update: {
            args: Prisma.InstituteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          deleteMany: {
            args: Prisma.InstituteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstituteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstituteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>[]
          }
          upsert: {
            args: Prisma.InstituteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstitutePayload>
          }
          aggregate: {
            args: Prisma.InstituteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstitute>
          }
          groupBy: {
            args: Prisma.InstituteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstituteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstituteCountArgs<ExtArgs>
            result: $Utils.Optional<InstituteCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      OrderTestParameter: {
        payload: Prisma.$OrderTestParameterPayload<ExtArgs>
        fields: Prisma.OrderTestParameterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderTestParameterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderTestParameterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>
          }
          findFirst: {
            args: Prisma.OrderTestParameterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderTestParameterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>
          }
          findMany: {
            args: Prisma.OrderTestParameterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>[]
          }
          create: {
            args: Prisma.OrderTestParameterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>
          }
          createMany: {
            args: Prisma.OrderTestParameterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderTestParameterCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>[]
          }
          delete: {
            args: Prisma.OrderTestParameterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>
          }
          update: {
            args: Prisma.OrderTestParameterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>
          }
          deleteMany: {
            args: Prisma.OrderTestParameterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderTestParameterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderTestParameterUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>[]
          }
          upsert: {
            args: Prisma.OrderTestParameterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderTestParameterPayload>
          }
          aggregate: {
            args: Prisma.OrderTestParameterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderTestParameter>
          }
          groupBy: {
            args: Prisma.OrderTestParameterGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderTestParameterGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderTestParameterCountArgs<ExtArgs>
            result: $Utils.Optional<OrderTestParameterCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    client?: ClientOmit
    agrotest?: AgrotestOmit
    testParameter?: TestParameterOmit
    sample?: SampleOmit
    testResult?: TestResultOmit
    comparisonRule?: ComparisonRuleOmit
    pricing?: PricingOmit
    institute?: InstituteOmit
    order?: OrderOmit
    orderItem?: OrderItemOmit
    orderTestParameter?: OrderTestParameterOmit
    invoice?: InvoiceOmit
    report?: ReportOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    orders: number
    reports: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | UserCountOutputTypeCountOrdersArgs
    reports?: boolean | UserCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type ClientCountOutputType
   */

  export type ClientCountOutputType = {
    orders: number
    invoices: number
    reports: number
  }

  export type ClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | ClientCountOutputTypeCountOrdersArgs
    invoices?: boolean | ClientCountOutputTypeCountInvoicesArgs
    reports?: boolean | ClientCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientCountOutputType
     */
    select?: ClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ClientCountOutputType without action
   */
  export type ClientCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type AgrotestCountOutputType
   */

  export type AgrotestCountOutputType = {
    testParameter: number
    orderItems: number
  }

  export type AgrotestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParameter?: boolean | AgrotestCountOutputTypeCountTestParameterArgs
    orderItems?: boolean | AgrotestCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * AgrotestCountOutputType without action
   */
  export type AgrotestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgrotestCountOutputType
     */
    select?: AgrotestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgrotestCountOutputType without action
   */
  export type AgrotestCountOutputTypeCountTestParameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParameterWhereInput
  }

  /**
   * AgrotestCountOutputType without action
   */
  export type AgrotestCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type TestParameterCountOutputType
   */

  export type TestParameterCountOutputType = {
    pricing: number
    comparisonRules: number
    testResults: number
    orderTestParameters: number
  }

  export type TestParameterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricing?: boolean | TestParameterCountOutputTypeCountPricingArgs
    comparisonRules?: boolean | TestParameterCountOutputTypeCountComparisonRulesArgs
    testResults?: boolean | TestParameterCountOutputTypeCountTestResultsArgs
    orderTestParameters?: boolean | TestParameterCountOutputTypeCountOrderTestParametersArgs
  }

  // Custom InputTypes
  /**
   * TestParameterCountOutputType without action
   */
  export type TestParameterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameterCountOutputType
     */
    select?: TestParameterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TestParameterCountOutputType without action
   */
  export type TestParameterCountOutputTypeCountPricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingWhereInput
  }

  /**
   * TestParameterCountOutputType without action
   */
  export type TestParameterCountOutputTypeCountComparisonRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComparisonRuleWhereInput
  }

  /**
   * TestParameterCountOutputType without action
   */
  export type TestParameterCountOutputTypeCountTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResultWhereInput
  }

  /**
   * TestParameterCountOutputType without action
   */
  export type TestParameterCountOutputTypeCountOrderTestParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTestParameterWhereInput
  }


  /**
   * Count Type SampleCountOutputType
   */

  export type SampleCountOutputType = {
    testResults: number
  }

  export type SampleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testResults?: boolean | SampleCountOutputTypeCountTestResultsArgs
  }

  // Custom InputTypes
  /**
   * SampleCountOutputType without action
   */
  export type SampleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SampleCountOutputType
     */
    select?: SampleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SampleCountOutputType without action
   */
  export type SampleCountOutputTypeCountTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResultWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    samples: number
    orderItems: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    samples?: boolean | OrderCountOutputTypeCountSamplesArgs
    orderItems?: boolean | OrderCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type OrderItemCountOutputType
   */

  export type OrderItemCountOutputType = {
    orderTestParameters: number
    sample: number
  }

  export type OrderItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderTestParameters?: boolean | OrderItemCountOutputTypeCountOrderTestParametersArgs
    sample?: boolean | OrderItemCountOutputTypeCountSampleArgs
  }

  // Custom InputTypes
  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItemCountOutputType
     */
    select?: OrderItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountOrderTestParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTestParameterWhereInput
  }

  /**
   * OrderItemCountOutputType without action
   */
  export type OrderItemCountOutputTypeCountSampleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    samples: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    samples?: boolean | ReportCountOutputTypeCountSamplesArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountSamplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    imageUrl?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    imageUrl?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    imageUrl: string | null
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    orders?: boolean | User$ordersArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "imageUrl" | "createdAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | User$ordersArgs<ExtArgs>
    reports?: boolean | User$reportsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends User$ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends User$reportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly imageUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.orders
   */
  export type User$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.reports
   */
  export type User$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Client
   */

  export type AggregateClient = {
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  export type ClientMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    clientType: $Enums.ClientType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    clientType: $Enums.ClientType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    clientType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    clientType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    clientType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    clientType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Client to aggregate.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientMaxAggregateInputType
  }

  export type GetClientAggregateType<T extends ClientAggregateArgs> = {
        [P in keyof T & keyof AggregateClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClient[P]>
      : GetScalarType<T[P], AggregateClient[P]>
  }




  export type ClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientWhereInput
    orderBy?: ClientOrderByWithAggregationInput | ClientOrderByWithAggregationInput[]
    by: ClientScalarFieldEnum[] | ClientScalarFieldEnum
    having?: ClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientCountAggregateInputType | true
    _min?: ClientMinAggregateInputType
    _max?: ClientMaxAggregateInputType
  }

  export type ClientGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    clientType: $Enums.ClientType
    createdAt: Date
    updatedAt: Date
    _count: ClientCountAggregateOutputType | null
    _min: ClientMinAggregateOutputType | null
    _max: ClientMaxAggregateOutputType | null
  }

  type GetClientGroupByPayload<T extends ClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientGroupByOutputType[P]>
            : GetScalarType<T[P], ClientGroupByOutputType[P]>
        }
      >
    >


  export type ClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    clientType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | Client$ordersArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    reports?: boolean | Client$reportsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["client"]>

  export type ClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    clientType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    clientType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["client"]>

  export type ClientSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    clientType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "clientType" | "createdAt" | "updatedAt", ExtArgs["result"]["client"]>
  export type ClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | Client$ordersArgs<ExtArgs>
    invoices?: boolean | Client$invoicesArgs<ExtArgs>
    reports?: boolean | Client$reportsArgs<ExtArgs>
    _count?: boolean | ClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Client"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      clientType: $Enums.ClientType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["client"]>
    composites: {}
  }

  type ClientGetPayload<S extends boolean | null | undefined | ClientDefaultArgs> = $Result.GetResult<Prisma.$ClientPayload, S>

  type ClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientCountAggregateInputType | true
    }

  export interface ClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Client'], meta: { name: 'Client' } }
    /**
     * Find zero or one Client that matches the filter.
     * @param {ClientFindUniqueArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientFindUniqueArgs>(args: SelectSubset<T, ClientFindUniqueArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Client that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientFindUniqueOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientFindFirstArgs>(args?: SelectSubset<T, ClientFindFirstArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Client that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindFirstOrThrowArgs} args - Arguments to find a Client
     * @example
     * // Get one Client
     * const client = await prisma.client.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.client.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.client.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientWithIdOnly = await prisma.client.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientFindManyArgs>(args?: SelectSubset<T, ClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Client.
     * @param {ClientCreateArgs} args - Arguments to create a Client.
     * @example
     * // Create one Client
     * const Client = await prisma.client.create({
     *   data: {
     *     // ... data to create a Client
     *   }
     * })
     * 
     */
    create<T extends ClientCreateArgs>(args: SelectSubset<T, ClientCreateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clients.
     * @param {ClientCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientCreateManyArgs>(args?: SelectSubset<T, ClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clients and returns the data saved in the database.
     * @param {ClientCreateManyAndReturnArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const client = await prisma.client.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Client.
     * @param {ClientDeleteArgs} args - Arguments to delete one Client.
     * @example
     * // Delete one Client
     * const Client = await prisma.client.delete({
     *   where: {
     *     // ... filter to delete one Client
     *   }
     * })
     * 
     */
    delete<T extends ClientDeleteArgs>(args: SelectSubset<T, ClientDeleteArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Client.
     * @param {ClientUpdateArgs} args - Arguments to update one Client.
     * @example
     * // Update one Client
     * const client = await prisma.client.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientUpdateArgs>(args: SelectSubset<T, ClientUpdateArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clients.
     * @param {ClientDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.client.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientDeleteManyArgs>(args?: SelectSubset<T, ClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientUpdateManyArgs>(args: SelectSubset<T, ClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients and returns the data updated in the database.
     * @param {ClientUpdateManyAndReturnArgs} args - Arguments to update many Clients.
     * @example
     * // Update many Clients
     * const client = await prisma.client.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clients and only return the `id`
     * const clientWithIdOnly = await prisma.client.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Client.
     * @param {ClientUpsertArgs} args - Arguments to update or create a Client.
     * @example
     * // Update or create a Client
     * const client = await prisma.client.upsert({
     *   create: {
     *     // ... data to create a Client
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Client we want to update
     *   }
     * })
     */
    upsert<T extends ClientUpsertArgs>(args: SelectSubset<T, ClientUpsertArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.client.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientCountArgs>(
      args?: Subset<T, ClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAggregateArgs>(args: Subset<T, ClientAggregateArgs>): Prisma.PrismaPromise<GetClientAggregateType<T>>

    /**
     * Group by Client.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientGroupByArgs['orderBy'] }
        : { orderBy?: ClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Client model
   */
  readonly fields: ClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Client.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends Client$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Client$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Client$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Client$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Client$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Client$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Client model
   */
  interface ClientFieldRefs {
    readonly id: FieldRef<"Client", 'String'>
    readonly name: FieldRef<"Client", 'String'>
    readonly address: FieldRef<"Client", 'String'>
    readonly phone: FieldRef<"Client", 'String'>
    readonly clientType: FieldRef<"Client", 'ClientType'>
    readonly createdAt: FieldRef<"Client", 'DateTime'>
    readonly updatedAt: FieldRef<"Client", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Client findUnique
   */
  export type ClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findUniqueOrThrow
   */
  export type ClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client findFirst
   */
  export type ClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findFirstOrThrow
   */
  export type ClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Client to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client findMany
   */
  export type ClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientOrderByWithRelationInput | ClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientScalarFieldEnum | ClientScalarFieldEnum[]
  }

  /**
   * Client create
   */
  export type ClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to create a Client.
     */
    data: XOR<ClientCreateInput, ClientUncheckedCreateInput>
  }

  /**
   * Client createMany
   */
  export type ClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client createManyAndReturn
   */
  export type ClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to create many Clients.
     */
    data: ClientCreateManyInput | ClientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Client update
   */
  export type ClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The data needed to update a Client.
     */
    data: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
    /**
     * Choose, which Client to update.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client updateMany
   */
  export type ClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client updateManyAndReturn
   */
  export type ClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientUpdateManyMutationInput, ClientUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to update.
     */
    limit?: number
  }

  /**
   * Client upsert
   */
  export type ClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * The filter to search for the Client to update in case it exists.
     */
    where: ClientWhereUniqueInput
    /**
     * In case the Client found by the `where` argument doesn't exist, create a new Client with this data.
     */
    create: XOR<ClientCreateInput, ClientUncheckedCreateInput>
    /**
     * In case the Client was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientUpdateInput, ClientUncheckedUpdateInput>
  }

  /**
   * Client delete
   */
  export type ClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
    /**
     * Filter which Client to delete.
     */
    where: ClientWhereUniqueInput
  }

  /**
   * Client deleteMany
   */
  export type ClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientWhereInput
    /**
     * Limit how many Clients to delete.
     */
    limit?: number
  }

  /**
   * Client.orders
   */
  export type Client$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Client.invoices
   */
  export type Client$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Client.reports
   */
  export type Client$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Client without action
   */
  export type ClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Client
     */
    select?: ClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Client
     */
    omit?: ClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientInclude<ExtArgs> | null
  }


  /**
   * Model Agrotest
   */

  export type AggregateAgrotest = {
    _count: AgrotestCountAggregateOutputType | null
    _min: AgrotestMinAggregateOutputType | null
    _max: AgrotestMaxAggregateOutputType | null
  }

  export type AgrotestMinAggregateOutputType = {
    id: string | null
    name: string | null
    sampleType: $Enums.SampleType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgrotestMaxAggregateOutputType = {
    id: string | null
    name: string | null
    sampleType: $Enums.SampleType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgrotestCountAggregateOutputType = {
    id: number
    name: number
    sampleType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgrotestMinAggregateInputType = {
    id?: true
    name?: true
    sampleType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgrotestMaxAggregateInputType = {
    id?: true
    name?: true
    sampleType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgrotestCountAggregateInputType = {
    id?: true
    name?: true
    sampleType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgrotestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agrotest to aggregate.
     */
    where?: AgrotestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrotests to fetch.
     */
    orderBy?: AgrotestOrderByWithRelationInput | AgrotestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgrotestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrotests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrotests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agrotests
    **/
    _count?: true | AgrotestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgrotestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgrotestMaxAggregateInputType
  }

  export type GetAgrotestAggregateType<T extends AgrotestAggregateArgs> = {
        [P in keyof T & keyof AggregateAgrotest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgrotest[P]>
      : GetScalarType<T[P], AggregateAgrotest[P]>
  }




  export type AgrotestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgrotestWhereInput
    orderBy?: AgrotestOrderByWithAggregationInput | AgrotestOrderByWithAggregationInput[]
    by: AgrotestScalarFieldEnum[] | AgrotestScalarFieldEnum
    having?: AgrotestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgrotestCountAggregateInputType | true
    _min?: AgrotestMinAggregateInputType
    _max?: AgrotestMaxAggregateInputType
  }

  export type AgrotestGroupByOutputType = {
    id: string
    name: string
    sampleType: $Enums.SampleType
    createdAt: Date
    updatedAt: Date
    _count: AgrotestCountAggregateOutputType | null
    _min: AgrotestMinAggregateOutputType | null
    _max: AgrotestMaxAggregateOutputType | null
  }

  type GetAgrotestGroupByPayload<T extends AgrotestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgrotestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgrotestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgrotestGroupByOutputType[P]>
            : GetScalarType<T[P], AgrotestGroupByOutputType[P]>
        }
      >
    >


  export type AgrotestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sampleType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParameter?: boolean | Agrotest$testParameterArgs<ExtArgs>
    orderItems?: boolean | Agrotest$orderItemsArgs<ExtArgs>
    _count?: boolean | AgrotestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agrotest"]>

  export type AgrotestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sampleType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agrotest"]>

  export type AgrotestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    sampleType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agrotest"]>

  export type AgrotestSelectScalar = {
    id?: boolean
    name?: boolean
    sampleType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgrotestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "sampleType" | "createdAt" | "updatedAt", ExtArgs["result"]["agrotest"]>
  export type AgrotestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParameter?: boolean | Agrotest$testParameterArgs<ExtArgs>
    orderItems?: boolean | Agrotest$orderItemsArgs<ExtArgs>
    _count?: boolean | AgrotestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgrotestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AgrotestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgrotestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agrotest"
    objects: {
      testParameter: Prisma.$TestParameterPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      sampleType: $Enums.SampleType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agrotest"]>
    composites: {}
  }

  type AgrotestGetPayload<S extends boolean | null | undefined | AgrotestDefaultArgs> = $Result.GetResult<Prisma.$AgrotestPayload, S>

  type AgrotestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgrotestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgrotestCountAggregateInputType | true
    }

  export interface AgrotestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agrotest'], meta: { name: 'Agrotest' } }
    /**
     * Find zero or one Agrotest that matches the filter.
     * @param {AgrotestFindUniqueArgs} args - Arguments to find a Agrotest
     * @example
     * // Get one Agrotest
     * const agrotest = await prisma.agrotest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgrotestFindUniqueArgs>(args: SelectSubset<T, AgrotestFindUniqueArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agrotest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgrotestFindUniqueOrThrowArgs} args - Arguments to find a Agrotest
     * @example
     * // Get one Agrotest
     * const agrotest = await prisma.agrotest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgrotestFindUniqueOrThrowArgs>(args: SelectSubset<T, AgrotestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agrotest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestFindFirstArgs} args - Arguments to find a Agrotest
     * @example
     * // Get one Agrotest
     * const agrotest = await prisma.agrotest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgrotestFindFirstArgs>(args?: SelectSubset<T, AgrotestFindFirstArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agrotest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestFindFirstOrThrowArgs} args - Arguments to find a Agrotest
     * @example
     * // Get one Agrotest
     * const agrotest = await prisma.agrotest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgrotestFindFirstOrThrowArgs>(args?: SelectSubset<T, AgrotestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agrotests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agrotests
     * const agrotests = await prisma.agrotest.findMany()
     * 
     * // Get first 10 Agrotests
     * const agrotests = await prisma.agrotest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agrotestWithIdOnly = await prisma.agrotest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgrotestFindManyArgs>(args?: SelectSubset<T, AgrotestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agrotest.
     * @param {AgrotestCreateArgs} args - Arguments to create a Agrotest.
     * @example
     * // Create one Agrotest
     * const Agrotest = await prisma.agrotest.create({
     *   data: {
     *     // ... data to create a Agrotest
     *   }
     * })
     * 
     */
    create<T extends AgrotestCreateArgs>(args: SelectSubset<T, AgrotestCreateArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agrotests.
     * @param {AgrotestCreateManyArgs} args - Arguments to create many Agrotests.
     * @example
     * // Create many Agrotests
     * const agrotest = await prisma.agrotest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgrotestCreateManyArgs>(args?: SelectSubset<T, AgrotestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agrotests and returns the data saved in the database.
     * @param {AgrotestCreateManyAndReturnArgs} args - Arguments to create many Agrotests.
     * @example
     * // Create many Agrotests
     * const agrotest = await prisma.agrotest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agrotests and only return the `id`
     * const agrotestWithIdOnly = await prisma.agrotest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgrotestCreateManyAndReturnArgs>(args?: SelectSubset<T, AgrotestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agrotest.
     * @param {AgrotestDeleteArgs} args - Arguments to delete one Agrotest.
     * @example
     * // Delete one Agrotest
     * const Agrotest = await prisma.agrotest.delete({
     *   where: {
     *     // ... filter to delete one Agrotest
     *   }
     * })
     * 
     */
    delete<T extends AgrotestDeleteArgs>(args: SelectSubset<T, AgrotestDeleteArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agrotest.
     * @param {AgrotestUpdateArgs} args - Arguments to update one Agrotest.
     * @example
     * // Update one Agrotest
     * const agrotest = await prisma.agrotest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgrotestUpdateArgs>(args: SelectSubset<T, AgrotestUpdateArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agrotests.
     * @param {AgrotestDeleteManyArgs} args - Arguments to filter Agrotests to delete.
     * @example
     * // Delete a few Agrotests
     * const { count } = await prisma.agrotest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgrotestDeleteManyArgs>(args?: SelectSubset<T, AgrotestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agrotests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agrotests
     * const agrotest = await prisma.agrotest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgrotestUpdateManyArgs>(args: SelectSubset<T, AgrotestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agrotests and returns the data updated in the database.
     * @param {AgrotestUpdateManyAndReturnArgs} args - Arguments to update many Agrotests.
     * @example
     * // Update many Agrotests
     * const agrotest = await prisma.agrotest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agrotests and only return the `id`
     * const agrotestWithIdOnly = await prisma.agrotest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgrotestUpdateManyAndReturnArgs>(args: SelectSubset<T, AgrotestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agrotest.
     * @param {AgrotestUpsertArgs} args - Arguments to update or create a Agrotest.
     * @example
     * // Update or create a Agrotest
     * const agrotest = await prisma.agrotest.upsert({
     *   create: {
     *     // ... data to create a Agrotest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agrotest we want to update
     *   }
     * })
     */
    upsert<T extends AgrotestUpsertArgs>(args: SelectSubset<T, AgrotestUpsertArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agrotests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestCountArgs} args - Arguments to filter Agrotests to count.
     * @example
     * // Count the number of Agrotests
     * const count = await prisma.agrotest.count({
     *   where: {
     *     // ... the filter for the Agrotests we want to count
     *   }
     * })
    **/
    count<T extends AgrotestCountArgs>(
      args?: Subset<T, AgrotestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgrotestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agrotest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgrotestAggregateArgs>(args: Subset<T, AgrotestAggregateArgs>): Prisma.PrismaPromise<GetAgrotestAggregateType<T>>

    /**
     * Group by Agrotest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgrotestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgrotestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgrotestGroupByArgs['orderBy'] }
        : { orderBy?: AgrotestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgrotestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgrotestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agrotest model
   */
  readonly fields: AgrotestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agrotest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgrotestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testParameter<T extends Agrotest$testParameterArgs<ExtArgs> = {}>(args?: Subset<T, Agrotest$testParameterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Agrotest$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Agrotest$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agrotest model
   */
  interface AgrotestFieldRefs {
    readonly id: FieldRef<"Agrotest", 'String'>
    readonly name: FieldRef<"Agrotest", 'String'>
    readonly sampleType: FieldRef<"Agrotest", 'SampleType'>
    readonly createdAt: FieldRef<"Agrotest", 'DateTime'>
    readonly updatedAt: FieldRef<"Agrotest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agrotest findUnique
   */
  export type AgrotestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * Filter, which Agrotest to fetch.
     */
    where: AgrotestWhereUniqueInput
  }

  /**
   * Agrotest findUniqueOrThrow
   */
  export type AgrotestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * Filter, which Agrotest to fetch.
     */
    where: AgrotestWhereUniqueInput
  }

  /**
   * Agrotest findFirst
   */
  export type AgrotestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * Filter, which Agrotest to fetch.
     */
    where?: AgrotestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrotests to fetch.
     */
    orderBy?: AgrotestOrderByWithRelationInput | AgrotestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agrotests.
     */
    cursor?: AgrotestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrotests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrotests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agrotests.
     */
    distinct?: AgrotestScalarFieldEnum | AgrotestScalarFieldEnum[]
  }

  /**
   * Agrotest findFirstOrThrow
   */
  export type AgrotestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * Filter, which Agrotest to fetch.
     */
    where?: AgrotestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrotests to fetch.
     */
    orderBy?: AgrotestOrderByWithRelationInput | AgrotestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agrotests.
     */
    cursor?: AgrotestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrotests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrotests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agrotests.
     */
    distinct?: AgrotestScalarFieldEnum | AgrotestScalarFieldEnum[]
  }

  /**
   * Agrotest findMany
   */
  export type AgrotestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * Filter, which Agrotests to fetch.
     */
    where?: AgrotestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agrotests to fetch.
     */
    orderBy?: AgrotestOrderByWithRelationInput | AgrotestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agrotests.
     */
    cursor?: AgrotestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agrotests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agrotests.
     */
    skip?: number
    distinct?: AgrotestScalarFieldEnum | AgrotestScalarFieldEnum[]
  }

  /**
   * Agrotest create
   */
  export type AgrotestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * The data needed to create a Agrotest.
     */
    data: XOR<AgrotestCreateInput, AgrotestUncheckedCreateInput>
  }

  /**
   * Agrotest createMany
   */
  export type AgrotestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agrotests.
     */
    data: AgrotestCreateManyInput | AgrotestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agrotest createManyAndReturn
   */
  export type AgrotestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * The data used to create many Agrotests.
     */
    data: AgrotestCreateManyInput | AgrotestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agrotest update
   */
  export type AgrotestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * The data needed to update a Agrotest.
     */
    data: XOR<AgrotestUpdateInput, AgrotestUncheckedUpdateInput>
    /**
     * Choose, which Agrotest to update.
     */
    where: AgrotestWhereUniqueInput
  }

  /**
   * Agrotest updateMany
   */
  export type AgrotestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agrotests.
     */
    data: XOR<AgrotestUpdateManyMutationInput, AgrotestUncheckedUpdateManyInput>
    /**
     * Filter which Agrotests to update
     */
    where?: AgrotestWhereInput
    /**
     * Limit how many Agrotests to update.
     */
    limit?: number
  }

  /**
   * Agrotest updateManyAndReturn
   */
  export type AgrotestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * The data used to update Agrotests.
     */
    data: XOR<AgrotestUpdateManyMutationInput, AgrotestUncheckedUpdateManyInput>
    /**
     * Filter which Agrotests to update
     */
    where?: AgrotestWhereInput
    /**
     * Limit how many Agrotests to update.
     */
    limit?: number
  }

  /**
   * Agrotest upsert
   */
  export type AgrotestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * The filter to search for the Agrotest to update in case it exists.
     */
    where: AgrotestWhereUniqueInput
    /**
     * In case the Agrotest found by the `where` argument doesn't exist, create a new Agrotest with this data.
     */
    create: XOR<AgrotestCreateInput, AgrotestUncheckedCreateInput>
    /**
     * In case the Agrotest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgrotestUpdateInput, AgrotestUncheckedUpdateInput>
  }

  /**
   * Agrotest delete
   */
  export type AgrotestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
    /**
     * Filter which Agrotest to delete.
     */
    where: AgrotestWhereUniqueInput
  }

  /**
   * Agrotest deleteMany
   */
  export type AgrotestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agrotests to delete
     */
    where?: AgrotestWhereInput
    /**
     * Limit how many Agrotests to delete.
     */
    limit?: number
  }

  /**
   * Agrotest.testParameter
   */
  export type Agrotest$testParameterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    where?: TestParameterWhereInput
    orderBy?: TestParameterOrderByWithRelationInput | TestParameterOrderByWithRelationInput[]
    cursor?: TestParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestParameterScalarFieldEnum | TestParameterScalarFieldEnum[]
  }

  /**
   * Agrotest.orderItems
   */
  export type Agrotest$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Agrotest without action
   */
  export type AgrotestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agrotest
     */
    select?: AgrotestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agrotest
     */
    omit?: AgrotestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgrotestInclude<ExtArgs> | null
  }


  /**
   * Model TestParameter
   */

  export type AggregateTestParameter = {
    _count: TestParameterCountAggregateOutputType | null
    _min: TestParameterMinAggregateOutputType | null
    _max: TestParameterMaxAggregateOutputType | null
  }

  export type TestParameterMinAggregateOutputType = {
    id: string | null
    agroTestID: string | null
    name: string | null
    unit: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestParameterMaxAggregateOutputType = {
    id: string | null
    agroTestID: string | null
    name: string | null
    unit: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestParameterCountAggregateOutputType = {
    id: number
    agroTestID: number
    name: number
    unit: number
    analysisType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestParameterMinAggregateInputType = {
    id?: true
    agroTestID?: true
    name?: true
    unit?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestParameterMaxAggregateInputType = {
    id?: true
    agroTestID?: true
    name?: true
    unit?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestParameterCountAggregateInputType = {
    id?: true
    agroTestID?: true
    name?: true
    unit?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParameter to aggregate.
     */
    where?: TestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParameters to fetch.
     */
    orderBy?: TestParameterOrderByWithRelationInput | TestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestParameters
    **/
    _count?: true | TestParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestParameterMaxAggregateInputType
  }

  export type GetTestParameterAggregateType<T extends TestParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateTestParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestParameter[P]>
      : GetScalarType<T[P], AggregateTestParameter[P]>
  }




  export type TestParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestParameterWhereInput
    orderBy?: TestParameterOrderByWithAggregationInput | TestParameterOrderByWithAggregationInput[]
    by: TestParameterScalarFieldEnum[] | TestParameterScalarFieldEnum
    having?: TestParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestParameterCountAggregateInputType | true
    _min?: TestParameterMinAggregateInputType
    _max?: TestParameterMaxAggregateInputType
  }

  export type TestParameterGroupByOutputType = {
    id: string
    agroTestID: string
    name: string
    unit: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date
    updatedAt: Date
    _count: TestParameterCountAggregateOutputType | null
    _min: TestParameterMinAggregateOutputType | null
    _max: TestParameterMaxAggregateOutputType | null
  }

  type GetTestParameterGroupByPayload<T extends TestParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestParameterGroupByOutputType[P]>
            : GetScalarType<T[P], TestParameterGroupByOutputType[P]>
        }
      >
    >


  export type TestParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agroTestID?: boolean
    name?: boolean
    unit?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
    pricing?: boolean | TestParameter$pricingArgs<ExtArgs>
    comparisonRules?: boolean | TestParameter$comparisonRulesArgs<ExtArgs>
    testResults?: boolean | TestParameter$testResultsArgs<ExtArgs>
    orderTestParameters?: boolean | TestParameter$orderTestParametersArgs<ExtArgs>
    _count?: boolean | TestParameterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParameter"]>

  export type TestParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agroTestID?: boolean
    name?: boolean
    unit?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParameter"]>

  export type TestParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agroTestID?: boolean
    name?: boolean
    unit?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testParameter"]>

  export type TestParameterSelectScalar = {
    id?: boolean
    agroTestID?: boolean
    name?: boolean
    unit?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agroTestID" | "name" | "unit" | "analysisType" | "createdAt" | "updatedAt", ExtArgs["result"]["testParameter"]>
  export type TestParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
    pricing?: boolean | TestParameter$pricingArgs<ExtArgs>
    comparisonRules?: boolean | TestParameter$comparisonRulesArgs<ExtArgs>
    testResults?: boolean | TestParameter$testResultsArgs<ExtArgs>
    orderTestParameters?: boolean | TestParameter$orderTestParametersArgs<ExtArgs>
    _count?: boolean | TestParameterCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TestParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }
  export type TestParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }

  export type $TestParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestParameter"
    objects: {
      agroTest: Prisma.$AgrotestPayload<ExtArgs>
      pricing: Prisma.$PricingPayload<ExtArgs>[]
      comparisonRules: Prisma.$ComparisonRulePayload<ExtArgs>[]
      testResults: Prisma.$TestResultPayload<ExtArgs>[]
      orderTestParameters: Prisma.$OrderTestParameterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agroTestID: string
      name: string
      unit: string | null
      analysisType: $Enums.AnalysisType | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testParameter"]>
    composites: {}
  }

  type TestParameterGetPayload<S extends boolean | null | undefined | TestParameterDefaultArgs> = $Result.GetResult<Prisma.$TestParameterPayload, S>

  type TestParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestParameterCountAggregateInputType | true
    }

  export interface TestParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestParameter'], meta: { name: 'TestParameter' } }
    /**
     * Find zero or one TestParameter that matches the filter.
     * @param {TestParameterFindUniqueArgs} args - Arguments to find a TestParameter
     * @example
     * // Get one TestParameter
     * const testParameter = await prisma.testParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestParameterFindUniqueArgs>(args: SelectSubset<T, TestParameterFindUniqueArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestParameterFindUniqueOrThrowArgs} args - Arguments to find a TestParameter
     * @example
     * // Get one TestParameter
     * const testParameter = await prisma.testParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, TestParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterFindFirstArgs} args - Arguments to find a TestParameter
     * @example
     * // Get one TestParameter
     * const testParameter = await prisma.testParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestParameterFindFirstArgs>(args?: SelectSubset<T, TestParameterFindFirstArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterFindFirstOrThrowArgs} args - Arguments to find a TestParameter
     * @example
     * // Get one TestParameter
     * const testParameter = await prisma.testParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, TestParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestParameters
     * const testParameters = await prisma.testParameter.findMany()
     * 
     * // Get first 10 TestParameters
     * const testParameters = await prisma.testParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testParameterWithIdOnly = await prisma.testParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestParameterFindManyArgs>(args?: SelectSubset<T, TestParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestParameter.
     * @param {TestParameterCreateArgs} args - Arguments to create a TestParameter.
     * @example
     * // Create one TestParameter
     * const TestParameter = await prisma.testParameter.create({
     *   data: {
     *     // ... data to create a TestParameter
     *   }
     * })
     * 
     */
    create<T extends TestParameterCreateArgs>(args: SelectSubset<T, TestParameterCreateArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestParameters.
     * @param {TestParameterCreateManyArgs} args - Arguments to create many TestParameters.
     * @example
     * // Create many TestParameters
     * const testParameter = await prisma.testParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestParameterCreateManyArgs>(args?: SelectSubset<T, TestParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestParameters and returns the data saved in the database.
     * @param {TestParameterCreateManyAndReturnArgs} args - Arguments to create many TestParameters.
     * @example
     * // Create many TestParameters
     * const testParameter = await prisma.testParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestParameters and only return the `id`
     * const testParameterWithIdOnly = await prisma.testParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, TestParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestParameter.
     * @param {TestParameterDeleteArgs} args - Arguments to delete one TestParameter.
     * @example
     * // Delete one TestParameter
     * const TestParameter = await prisma.testParameter.delete({
     *   where: {
     *     // ... filter to delete one TestParameter
     *   }
     * })
     * 
     */
    delete<T extends TestParameterDeleteArgs>(args: SelectSubset<T, TestParameterDeleteArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestParameter.
     * @param {TestParameterUpdateArgs} args - Arguments to update one TestParameter.
     * @example
     * // Update one TestParameter
     * const testParameter = await prisma.testParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestParameterUpdateArgs>(args: SelectSubset<T, TestParameterUpdateArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestParameters.
     * @param {TestParameterDeleteManyArgs} args - Arguments to filter TestParameters to delete.
     * @example
     * // Delete a few TestParameters
     * const { count } = await prisma.testParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestParameterDeleteManyArgs>(args?: SelectSubset<T, TestParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestParameters
     * const testParameter = await prisma.testParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestParameterUpdateManyArgs>(args: SelectSubset<T, TestParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestParameters and returns the data updated in the database.
     * @param {TestParameterUpdateManyAndReturnArgs} args - Arguments to update many TestParameters.
     * @example
     * // Update many TestParameters
     * const testParameter = await prisma.testParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestParameters and only return the `id`
     * const testParameterWithIdOnly = await prisma.testParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, TestParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestParameter.
     * @param {TestParameterUpsertArgs} args - Arguments to update or create a TestParameter.
     * @example
     * // Update or create a TestParameter
     * const testParameter = await prisma.testParameter.upsert({
     *   create: {
     *     // ... data to create a TestParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestParameter we want to update
     *   }
     * })
     */
    upsert<T extends TestParameterUpsertArgs>(args: SelectSubset<T, TestParameterUpsertArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterCountArgs} args - Arguments to filter TestParameters to count.
     * @example
     * // Count the number of TestParameters
     * const count = await prisma.testParameter.count({
     *   where: {
     *     // ... the filter for the TestParameters we want to count
     *   }
     * })
    **/
    count<T extends TestParameterCountArgs>(
      args?: Subset<T, TestParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestParameterAggregateArgs>(args: Subset<T, TestParameterAggregateArgs>): Prisma.PrismaPromise<GetTestParameterAggregateType<T>>

    /**
     * Group by TestParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestParameterGroupByArgs['orderBy'] }
        : { orderBy?: TestParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestParameter model
   */
  readonly fields: TestParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agroTest<T extends AgrotestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgrotestDefaultArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    pricing<T extends TestParameter$pricingArgs<ExtArgs> = {}>(args?: Subset<T, TestParameter$pricingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comparisonRules<T extends TestParameter$comparisonRulesArgs<ExtArgs> = {}>(args?: Subset<T, TestParameter$comparisonRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    testResults<T extends TestParameter$testResultsArgs<ExtArgs> = {}>(args?: Subset<T, TestParameter$testResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderTestParameters<T extends TestParameter$orderTestParametersArgs<ExtArgs> = {}>(args?: Subset<T, TestParameter$orderTestParametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestParameter model
   */
  interface TestParameterFieldRefs {
    readonly id: FieldRef<"TestParameter", 'String'>
    readonly agroTestID: FieldRef<"TestParameter", 'String'>
    readonly name: FieldRef<"TestParameter", 'String'>
    readonly unit: FieldRef<"TestParameter", 'String'>
    readonly analysisType: FieldRef<"TestParameter", 'AnalysisType'>
    readonly createdAt: FieldRef<"TestParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"TestParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestParameter findUnique
   */
  export type TestParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * Filter, which TestParameter to fetch.
     */
    where: TestParameterWhereUniqueInput
  }

  /**
   * TestParameter findUniqueOrThrow
   */
  export type TestParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * Filter, which TestParameter to fetch.
     */
    where: TestParameterWhereUniqueInput
  }

  /**
   * TestParameter findFirst
   */
  export type TestParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * Filter, which TestParameter to fetch.
     */
    where?: TestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParameters to fetch.
     */
    orderBy?: TestParameterOrderByWithRelationInput | TestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParameters.
     */
    cursor?: TestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParameters.
     */
    distinct?: TestParameterScalarFieldEnum | TestParameterScalarFieldEnum[]
  }

  /**
   * TestParameter findFirstOrThrow
   */
  export type TestParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * Filter, which TestParameter to fetch.
     */
    where?: TestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParameters to fetch.
     */
    orderBy?: TestParameterOrderByWithRelationInput | TestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestParameters.
     */
    cursor?: TestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestParameters.
     */
    distinct?: TestParameterScalarFieldEnum | TestParameterScalarFieldEnum[]
  }

  /**
   * TestParameter findMany
   */
  export type TestParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * Filter, which TestParameters to fetch.
     */
    where?: TestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestParameters to fetch.
     */
    orderBy?: TestParameterOrderByWithRelationInput | TestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestParameters.
     */
    cursor?: TestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestParameters.
     */
    skip?: number
    distinct?: TestParameterScalarFieldEnum | TestParameterScalarFieldEnum[]
  }

  /**
   * TestParameter create
   */
  export type TestParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a TestParameter.
     */
    data: XOR<TestParameterCreateInput, TestParameterUncheckedCreateInput>
  }

  /**
   * TestParameter createMany
   */
  export type TestParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestParameters.
     */
    data: TestParameterCreateManyInput | TestParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestParameter createManyAndReturn
   */
  export type TestParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * The data used to create many TestParameters.
     */
    data: TestParameterCreateManyInput | TestParameterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParameter update
   */
  export type TestParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a TestParameter.
     */
    data: XOR<TestParameterUpdateInput, TestParameterUncheckedUpdateInput>
    /**
     * Choose, which TestParameter to update.
     */
    where: TestParameterWhereUniqueInput
  }

  /**
   * TestParameter updateMany
   */
  export type TestParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestParameters.
     */
    data: XOR<TestParameterUpdateManyMutationInput, TestParameterUncheckedUpdateManyInput>
    /**
     * Filter which TestParameters to update
     */
    where?: TestParameterWhereInput
    /**
     * Limit how many TestParameters to update.
     */
    limit?: number
  }

  /**
   * TestParameter updateManyAndReturn
   */
  export type TestParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * The data used to update TestParameters.
     */
    data: XOR<TestParameterUpdateManyMutationInput, TestParameterUncheckedUpdateManyInput>
    /**
     * Filter which TestParameters to update
     */
    where?: TestParameterWhereInput
    /**
     * Limit how many TestParameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestParameter upsert
   */
  export type TestParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the TestParameter to update in case it exists.
     */
    where: TestParameterWhereUniqueInput
    /**
     * In case the TestParameter found by the `where` argument doesn't exist, create a new TestParameter with this data.
     */
    create: XOR<TestParameterCreateInput, TestParameterUncheckedCreateInput>
    /**
     * In case the TestParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestParameterUpdateInput, TestParameterUncheckedUpdateInput>
  }

  /**
   * TestParameter delete
   */
  export type TestParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
    /**
     * Filter which TestParameter to delete.
     */
    where: TestParameterWhereUniqueInput
  }

  /**
   * TestParameter deleteMany
   */
  export type TestParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestParameters to delete
     */
    where?: TestParameterWhereInput
    /**
     * Limit how many TestParameters to delete.
     */
    limit?: number
  }

  /**
   * TestParameter.pricing
   */
  export type TestParameter$pricingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    where?: PricingWhereInput
    orderBy?: PricingOrderByWithRelationInput | PricingOrderByWithRelationInput[]
    cursor?: PricingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * TestParameter.comparisonRules
   */
  export type TestParameter$comparisonRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    where?: ComparisonRuleWhereInput
    orderBy?: ComparisonRuleOrderByWithRelationInput | ComparisonRuleOrderByWithRelationInput[]
    cursor?: ComparisonRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComparisonRuleScalarFieldEnum | ComparisonRuleScalarFieldEnum[]
  }

  /**
   * TestParameter.testResults
   */
  export type TestParameter$testResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    cursor?: TestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestParameter.orderTestParameters
   */
  export type TestParameter$orderTestParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    where?: OrderTestParameterWhereInput
    orderBy?: OrderTestParameterOrderByWithRelationInput | OrderTestParameterOrderByWithRelationInput[]
    cursor?: OrderTestParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTestParameterScalarFieldEnum | OrderTestParameterScalarFieldEnum[]
  }

  /**
   * TestParameter without action
   */
  export type TestParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestParameter
     */
    select?: TestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestParameter
     */
    omit?: TestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestParameterInclude<ExtArgs> | null
  }


  /**
   * Model Sample
   */

  export type AggregateSample = {
    _count: SampleCountAggregateOutputType | null
    _avg: SampleAvgAggregateOutputType | null
    _sum: SampleSumAggregateOutputType | null
    _min: SampleMinAggregateOutputType | null
    _max: SampleMaxAggregateOutputType | null
  }

  export type SampleAvgAggregateOutputType = {
    manchitroUnit: number | null
  }

  export type SampleSumAggregateOutputType = {
    manchitroUnit: number | null
  }

  export type SampleMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    orderItemId: string | null
    sampleIdNumber: string | null
    collectionDate: Date | null
    sampleType: $Enums.SampleType | null
    collectionLocation: string | null
    cropType: string | null
    bunot: string | null
    manchitroUnit: number | null
    vumiSrini: string | null
    status: $Enums.SampleStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reportId: string | null
  }

  export type SampleMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    orderItemId: string | null
    sampleIdNumber: string | null
    collectionDate: Date | null
    sampleType: $Enums.SampleType | null
    collectionLocation: string | null
    cropType: string | null
    bunot: string | null
    manchitroUnit: number | null
    vumiSrini: string | null
    status: $Enums.SampleStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reportId: string | null
  }

  export type SampleCountAggregateOutputType = {
    id: number
    orderId: number
    orderItemId: number
    sampleIdNumber: number
    collectionDate: number
    sampleType: number
    collectionLocation: number
    cropType: number
    bunot: number
    manchitroUnit: number
    vumiSrini: number
    status: number
    createdAt: number
    updatedAt: number
    reportId: number
    _all: number
  }


  export type SampleAvgAggregateInputType = {
    manchitroUnit?: true
  }

  export type SampleSumAggregateInputType = {
    manchitroUnit?: true
  }

  export type SampleMinAggregateInputType = {
    id?: true
    orderId?: true
    orderItemId?: true
    sampleIdNumber?: true
    collectionDate?: true
    sampleType?: true
    collectionLocation?: true
    cropType?: true
    bunot?: true
    manchitroUnit?: true
    vumiSrini?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reportId?: true
  }

  export type SampleMaxAggregateInputType = {
    id?: true
    orderId?: true
    orderItemId?: true
    sampleIdNumber?: true
    collectionDate?: true
    sampleType?: true
    collectionLocation?: true
    cropType?: true
    bunot?: true
    manchitroUnit?: true
    vumiSrini?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reportId?: true
  }

  export type SampleCountAggregateInputType = {
    id?: true
    orderId?: true
    orderItemId?: true
    sampleIdNumber?: true
    collectionDate?: true
    sampleType?: true
    collectionLocation?: true
    cropType?: true
    bunot?: true
    manchitroUnit?: true
    vumiSrini?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reportId?: true
    _all?: true
  }

  export type SampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sample to aggregate.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Samples
    **/
    _count?: true | SampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SampleMaxAggregateInputType
  }

  export type GetSampleAggregateType<T extends SampleAggregateArgs> = {
        [P in keyof T & keyof AggregateSample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSample[P]>
      : GetScalarType<T[P], AggregateSample[P]>
  }




  export type SampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithAggregationInput | SampleOrderByWithAggregationInput[]
    by: SampleScalarFieldEnum[] | SampleScalarFieldEnum
    having?: SampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SampleCountAggregateInputType | true
    _avg?: SampleAvgAggregateInputType
    _sum?: SampleSumAggregateInputType
    _min?: SampleMinAggregateInputType
    _max?: SampleMaxAggregateInputType
  }

  export type SampleGroupByOutputType = {
    id: string
    orderId: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date
    sampleType: $Enums.SampleType
    collectionLocation: string | null
    cropType: string | null
    bunot: string | null
    manchitroUnit: number | null
    vumiSrini: string | null
    status: $Enums.SampleStatus
    createdAt: Date
    updatedAt: Date
    reportId: string | null
    _count: SampleCountAggregateOutputType | null
    _avg: SampleAvgAggregateOutputType | null
    _sum: SampleSumAggregateOutputType | null
    _min: SampleMinAggregateOutputType | null
    _max: SampleMaxAggregateOutputType | null
  }

  type GetSampleGroupByPayload<T extends SampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SampleGroupByOutputType[P]>
            : GetScalarType<T[P], SampleGroupByOutputType[P]>
        }
      >
    >


  export type SampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderItemId?: boolean
    sampleIdNumber?: boolean
    collectionDate?: boolean
    sampleType?: boolean
    collectionLocation?: boolean
    cropType?: boolean
    bunot?: boolean
    manchitroUnit?: boolean
    vumiSrini?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testResults?: boolean | Sample$testResultsArgs<ExtArgs>
    report?: boolean | Sample$reportArgs<ExtArgs>
    _count?: boolean | SampleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sample"]>

  export type SampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderItemId?: boolean
    sampleIdNumber?: boolean
    collectionDate?: boolean
    sampleType?: boolean
    collectionLocation?: boolean
    cropType?: boolean
    bunot?: boolean
    manchitroUnit?: boolean
    vumiSrini?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    report?: boolean | Sample$reportArgs<ExtArgs>
  }, ExtArgs["result"]["sample"]>

  export type SampleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    orderItemId?: boolean
    sampleIdNumber?: boolean
    collectionDate?: boolean
    sampleType?: boolean
    collectionLocation?: boolean
    cropType?: boolean
    bunot?: boolean
    manchitroUnit?: boolean
    vumiSrini?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    report?: boolean | Sample$reportArgs<ExtArgs>
  }, ExtArgs["result"]["sample"]>

  export type SampleSelectScalar = {
    id?: boolean
    orderId?: boolean
    orderItemId?: boolean
    sampleIdNumber?: boolean
    collectionDate?: boolean
    sampleType?: boolean
    collectionLocation?: boolean
    cropType?: boolean
    bunot?: boolean
    manchitroUnit?: boolean
    vumiSrini?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
  }

  export type SampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "orderItemId" | "sampleIdNumber" | "collectionDate" | "sampleType" | "collectionLocation" | "cropType" | "bunot" | "manchitroUnit" | "vumiSrini" | "status" | "createdAt" | "updatedAt" | "reportId", ExtArgs["result"]["sample"]>
  export type SampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testResults?: boolean | Sample$testResultsArgs<ExtArgs>
    report?: boolean | Sample$reportArgs<ExtArgs>
    _count?: boolean | SampleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SampleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    report?: boolean | Sample$reportArgs<ExtArgs>
  }
  export type SampleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    report?: boolean | Sample$reportArgs<ExtArgs>
  }

  export type $SamplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sample"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      testResults: Prisma.$TestResultPayload<ExtArgs>[]
      report: Prisma.$ReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      orderItemId: string
      sampleIdNumber: string
      collectionDate: Date
      sampleType: $Enums.SampleType
      collectionLocation: string | null
      cropType: string | null
      bunot: string | null
      manchitroUnit: number | null
      vumiSrini: string | null
      status: $Enums.SampleStatus
      createdAt: Date
      updatedAt: Date
      reportId: string | null
    }, ExtArgs["result"]["sample"]>
    composites: {}
  }

  type SampleGetPayload<S extends boolean | null | undefined | SampleDefaultArgs> = $Result.GetResult<Prisma.$SamplePayload, S>

  type SampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SampleCountAggregateInputType | true
    }

  export interface SampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sample'], meta: { name: 'Sample' } }
    /**
     * Find zero or one Sample that matches the filter.
     * @param {SampleFindUniqueArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SampleFindUniqueArgs>(args: SelectSubset<T, SampleFindUniqueArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SampleFindUniqueOrThrowArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SampleFindUniqueOrThrowArgs>(args: SelectSubset<T, SampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleFindFirstArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SampleFindFirstArgs>(args?: SelectSubset<T, SampleFindFirstArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleFindFirstOrThrowArgs} args - Arguments to find a Sample
     * @example
     * // Get one Sample
     * const sample = await prisma.sample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SampleFindFirstOrThrowArgs>(args?: SelectSubset<T, SampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Samples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Samples
     * const samples = await prisma.sample.findMany()
     * 
     * // Get first 10 Samples
     * const samples = await prisma.sample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sampleWithIdOnly = await prisma.sample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SampleFindManyArgs>(args?: SelectSubset<T, SampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sample.
     * @param {SampleCreateArgs} args - Arguments to create a Sample.
     * @example
     * // Create one Sample
     * const Sample = await prisma.sample.create({
     *   data: {
     *     // ... data to create a Sample
     *   }
     * })
     * 
     */
    create<T extends SampleCreateArgs>(args: SelectSubset<T, SampleCreateArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Samples.
     * @param {SampleCreateManyArgs} args - Arguments to create many Samples.
     * @example
     * // Create many Samples
     * const sample = await prisma.sample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SampleCreateManyArgs>(args?: SelectSubset<T, SampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Samples and returns the data saved in the database.
     * @param {SampleCreateManyAndReturnArgs} args - Arguments to create many Samples.
     * @example
     * // Create many Samples
     * const sample = await prisma.sample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Samples and only return the `id`
     * const sampleWithIdOnly = await prisma.sample.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SampleCreateManyAndReturnArgs>(args?: SelectSubset<T, SampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sample.
     * @param {SampleDeleteArgs} args - Arguments to delete one Sample.
     * @example
     * // Delete one Sample
     * const Sample = await prisma.sample.delete({
     *   where: {
     *     // ... filter to delete one Sample
     *   }
     * })
     * 
     */
    delete<T extends SampleDeleteArgs>(args: SelectSubset<T, SampleDeleteArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sample.
     * @param {SampleUpdateArgs} args - Arguments to update one Sample.
     * @example
     * // Update one Sample
     * const sample = await prisma.sample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SampleUpdateArgs>(args: SelectSubset<T, SampleUpdateArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Samples.
     * @param {SampleDeleteManyArgs} args - Arguments to filter Samples to delete.
     * @example
     * // Delete a few Samples
     * const { count } = await prisma.sample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SampleDeleteManyArgs>(args?: SelectSubset<T, SampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Samples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Samples
     * const sample = await prisma.sample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SampleUpdateManyArgs>(args: SelectSubset<T, SampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Samples and returns the data updated in the database.
     * @param {SampleUpdateManyAndReturnArgs} args - Arguments to update many Samples.
     * @example
     * // Update many Samples
     * const sample = await prisma.sample.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Samples and only return the `id`
     * const sampleWithIdOnly = await prisma.sample.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SampleUpdateManyAndReturnArgs>(args: SelectSubset<T, SampleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sample.
     * @param {SampleUpsertArgs} args - Arguments to update or create a Sample.
     * @example
     * // Update or create a Sample
     * const sample = await prisma.sample.upsert({
     *   create: {
     *     // ... data to create a Sample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sample we want to update
     *   }
     * })
     */
    upsert<T extends SampleUpsertArgs>(args: SelectSubset<T, SampleUpsertArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Samples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleCountArgs} args - Arguments to filter Samples to count.
     * @example
     * // Count the number of Samples
     * const count = await prisma.sample.count({
     *   where: {
     *     // ... the filter for the Samples we want to count
     *   }
     * })
    **/
    count<T extends SampleCountArgs>(
      args?: Subset<T, SampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SampleAggregateArgs>(args: Subset<T, SampleAggregateArgs>): Prisma.PrismaPromise<GetSampleAggregateType<T>>

    /**
     * Group by Sample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SampleGroupByArgs['orderBy'] }
        : { orderBy?: SampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sample model
   */
  readonly fields: SampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testResults<T extends Sample$testResultsArgs<ExtArgs> = {}>(args?: Subset<T, Sample$testResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    report<T extends Sample$reportArgs<ExtArgs> = {}>(args?: Subset<T, Sample$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sample model
   */
  interface SampleFieldRefs {
    readonly id: FieldRef<"Sample", 'String'>
    readonly orderId: FieldRef<"Sample", 'String'>
    readonly orderItemId: FieldRef<"Sample", 'String'>
    readonly sampleIdNumber: FieldRef<"Sample", 'String'>
    readonly collectionDate: FieldRef<"Sample", 'DateTime'>
    readonly sampleType: FieldRef<"Sample", 'SampleType'>
    readonly collectionLocation: FieldRef<"Sample", 'String'>
    readonly cropType: FieldRef<"Sample", 'String'>
    readonly bunot: FieldRef<"Sample", 'String'>
    readonly manchitroUnit: FieldRef<"Sample", 'Int'>
    readonly vumiSrini: FieldRef<"Sample", 'String'>
    readonly status: FieldRef<"Sample", 'SampleStatus'>
    readonly createdAt: FieldRef<"Sample", 'DateTime'>
    readonly updatedAt: FieldRef<"Sample", 'DateTime'>
    readonly reportId: FieldRef<"Sample", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Sample findUnique
   */
  export type SampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample findUniqueOrThrow
   */
  export type SampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample findFirst
   */
  export type SampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Samples.
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Samples.
     */
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Sample findFirstOrThrow
   */
  export type SampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Sample to fetch.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Samples.
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Samples.
     */
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Sample findMany
   */
  export type SampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter, which Samples to fetch.
     */
    where?: SampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Samples to fetch.
     */
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Samples.
     */
    cursor?: SampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Samples.
     */
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Sample create
   */
  export type SampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sample.
     */
    data: XOR<SampleCreateInput, SampleUncheckedCreateInput>
  }

  /**
   * Sample createMany
   */
  export type SampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Samples.
     */
    data: SampleCreateManyInput | SampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sample createManyAndReturn
   */
  export type SampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * The data used to create many Samples.
     */
    data: SampleCreateManyInput | SampleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sample update
   */
  export type SampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sample.
     */
    data: XOR<SampleUpdateInput, SampleUncheckedUpdateInput>
    /**
     * Choose, which Sample to update.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample updateMany
   */
  export type SampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Samples.
     */
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyInput>
    /**
     * Filter which Samples to update
     */
    where?: SampleWhereInput
    /**
     * Limit how many Samples to update.
     */
    limit?: number
  }

  /**
   * Sample updateManyAndReturn
   */
  export type SampleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * The data used to update Samples.
     */
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyInput>
    /**
     * Filter which Samples to update
     */
    where?: SampleWhereInput
    /**
     * Limit how many Samples to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sample upsert
   */
  export type SampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sample to update in case it exists.
     */
    where: SampleWhereUniqueInput
    /**
     * In case the Sample found by the `where` argument doesn't exist, create a new Sample with this data.
     */
    create: XOR<SampleCreateInput, SampleUncheckedCreateInput>
    /**
     * In case the Sample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SampleUpdateInput, SampleUncheckedUpdateInput>
  }

  /**
   * Sample delete
   */
  export type SampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    /**
     * Filter which Sample to delete.
     */
    where: SampleWhereUniqueInput
  }

  /**
   * Sample deleteMany
   */
  export type SampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Samples to delete
     */
    where?: SampleWhereInput
    /**
     * Limit how many Samples to delete.
     */
    limit?: number
  }

  /**
   * Sample.testResults
   */
  export type Sample$testResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    cursor?: TestResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * Sample.report
   */
  export type Sample$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Sample without action
   */
  export type SampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
  }


  /**
   * Model TestResult
   */

  export type AggregateTestResult = {
    _count: TestResultCountAggregateOutputType | null
    _avg: TestResultAvgAggregateOutputType | null
    _sum: TestResultSumAggregateOutputType | null
    _min: TestResultMinAggregateOutputType | null
    _max: TestResultMaxAggregateOutputType | null
  }

  export type TestResultAvgAggregateOutputType = {
    value: number | null
  }

  export type TestResultSumAggregateOutputType = {
    value: number | null
  }

  export type TestResultMinAggregateOutputType = {
    id: string | null
    sampleId: string | null
    testParameterId: string | null
    value: number | null
    interpretation: string | null
    uplandInterpretation: string | null
    wetlandInterpretation: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestResultMaxAggregateOutputType = {
    id: string | null
    sampleId: string | null
    testParameterId: string | null
    value: number | null
    interpretation: string | null
    uplandInterpretation: string | null
    wetlandInterpretation: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TestResultCountAggregateOutputType = {
    id: number
    sampleId: number
    testParameterId: number
    value: number
    interpretation: number
    uplandInterpretation: number
    wetlandInterpretation: number
    analysisType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TestResultAvgAggregateInputType = {
    value?: true
  }

  export type TestResultSumAggregateInputType = {
    value?: true
  }

  export type TestResultMinAggregateInputType = {
    id?: true
    sampleId?: true
    testParameterId?: true
    value?: true
    interpretation?: true
    uplandInterpretation?: true
    wetlandInterpretation?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestResultMaxAggregateInputType = {
    id?: true
    sampleId?: true
    testParameterId?: true
    value?: true
    interpretation?: true
    uplandInterpretation?: true
    wetlandInterpretation?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TestResultCountAggregateInputType = {
    id?: true
    sampleId?: true
    testParameterId?: true
    value?: true
    interpretation?: true
    uplandInterpretation?: true
    wetlandInterpretation?: true
    analysisType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TestResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResult to aggregate.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TestResults
    **/
    _count?: true | TestResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TestResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TestResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TestResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TestResultMaxAggregateInputType
  }

  export type GetTestResultAggregateType<T extends TestResultAggregateArgs> = {
        [P in keyof T & keyof AggregateTestResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTestResult[P]>
      : GetScalarType<T[P], AggregateTestResult[P]>
  }




  export type TestResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TestResultWhereInput
    orderBy?: TestResultOrderByWithAggregationInput | TestResultOrderByWithAggregationInput[]
    by: TestResultScalarFieldEnum[] | TestResultScalarFieldEnum
    having?: TestResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TestResultCountAggregateInputType | true
    _avg?: TestResultAvgAggregateInputType
    _sum?: TestResultSumAggregateInputType
    _min?: TestResultMinAggregateInputType
    _max?: TestResultMaxAggregateInputType
  }

  export type TestResultGroupByOutputType = {
    id: string
    sampleId: string
    testParameterId: string
    value: number | null
    interpretation: string | null
    uplandInterpretation: string | null
    wetlandInterpretation: string | null
    analysisType: $Enums.AnalysisType | null
    createdAt: Date
    updatedAt: Date
    _count: TestResultCountAggregateOutputType | null
    _avg: TestResultAvgAggregateOutputType | null
    _sum: TestResultSumAggregateOutputType | null
    _min: TestResultMinAggregateOutputType | null
    _max: TestResultMaxAggregateOutputType | null
  }

  type GetTestResultGroupByPayload<T extends TestResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TestResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TestResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TestResultGroupByOutputType[P]>
            : GetScalarType<T[P], TestResultGroupByOutputType[P]>
        }
      >
    >


  export type TestResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sampleId?: boolean
    testParameterId?: boolean
    value?: boolean
    interpretation?: boolean
    uplandInterpretation?: boolean
    wetlandInterpretation?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sample?: boolean | SampleDefaultArgs<ExtArgs>
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testResult"]>

  export type TestResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sampleId?: boolean
    testParameterId?: boolean
    value?: boolean
    interpretation?: boolean
    uplandInterpretation?: boolean
    wetlandInterpretation?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sample?: boolean | SampleDefaultArgs<ExtArgs>
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testResult"]>

  export type TestResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sampleId?: boolean
    testParameterId?: boolean
    value?: boolean
    interpretation?: boolean
    uplandInterpretation?: boolean
    wetlandInterpretation?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sample?: boolean | SampleDefaultArgs<ExtArgs>
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["testResult"]>

  export type TestResultSelectScalar = {
    id?: boolean
    sampleId?: boolean
    testParameterId?: boolean
    value?: boolean
    interpretation?: boolean
    uplandInterpretation?: boolean
    wetlandInterpretation?: boolean
    analysisType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TestResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sampleId" | "testParameterId" | "value" | "interpretation" | "uplandInterpretation" | "wetlandInterpretation" | "analysisType" | "createdAt" | "updatedAt", ExtArgs["result"]["testResult"]>
  export type TestResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sample?: boolean | SampleDefaultArgs<ExtArgs>
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type TestResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sample?: boolean | SampleDefaultArgs<ExtArgs>
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type TestResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sample?: boolean | SampleDefaultArgs<ExtArgs>
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }

  export type $TestResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TestResult"
    objects: {
      sample: Prisma.$SamplePayload<ExtArgs>
      testParamater: Prisma.$TestParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sampleId: string
      testParameterId: string
      value: number | null
      interpretation: string | null
      uplandInterpretation: string | null
      wetlandInterpretation: string | null
      analysisType: $Enums.AnalysisType | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["testResult"]>
    composites: {}
  }

  type TestResultGetPayload<S extends boolean | null | undefined | TestResultDefaultArgs> = $Result.GetResult<Prisma.$TestResultPayload, S>

  type TestResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TestResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TestResultCountAggregateInputType | true
    }

  export interface TestResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TestResult'], meta: { name: 'TestResult' } }
    /**
     * Find zero or one TestResult that matches the filter.
     * @param {TestResultFindUniqueArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TestResultFindUniqueArgs>(args: SelectSubset<T, TestResultFindUniqueArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TestResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TestResultFindUniqueOrThrowArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TestResultFindUniqueOrThrowArgs>(args: SelectSubset<T, TestResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindFirstArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TestResultFindFirstArgs>(args?: SelectSubset<T, TestResultFindFirstArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TestResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindFirstOrThrowArgs} args - Arguments to find a TestResult
     * @example
     * // Get one TestResult
     * const testResult = await prisma.testResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TestResultFindFirstOrThrowArgs>(args?: SelectSubset<T, TestResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TestResults
     * const testResults = await prisma.testResult.findMany()
     * 
     * // Get first 10 TestResults
     * const testResults = await prisma.testResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const testResultWithIdOnly = await prisma.testResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TestResultFindManyArgs>(args?: SelectSubset<T, TestResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TestResult.
     * @param {TestResultCreateArgs} args - Arguments to create a TestResult.
     * @example
     * // Create one TestResult
     * const TestResult = await prisma.testResult.create({
     *   data: {
     *     // ... data to create a TestResult
     *   }
     * })
     * 
     */
    create<T extends TestResultCreateArgs>(args: SelectSubset<T, TestResultCreateArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TestResults.
     * @param {TestResultCreateManyArgs} args - Arguments to create many TestResults.
     * @example
     * // Create many TestResults
     * const testResult = await prisma.testResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TestResultCreateManyArgs>(args?: SelectSubset<T, TestResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TestResults and returns the data saved in the database.
     * @param {TestResultCreateManyAndReturnArgs} args - Arguments to create many TestResults.
     * @example
     * // Create many TestResults
     * const testResult = await prisma.testResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TestResults and only return the `id`
     * const testResultWithIdOnly = await prisma.testResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TestResultCreateManyAndReturnArgs>(args?: SelectSubset<T, TestResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TestResult.
     * @param {TestResultDeleteArgs} args - Arguments to delete one TestResult.
     * @example
     * // Delete one TestResult
     * const TestResult = await prisma.testResult.delete({
     *   where: {
     *     // ... filter to delete one TestResult
     *   }
     * })
     * 
     */
    delete<T extends TestResultDeleteArgs>(args: SelectSubset<T, TestResultDeleteArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TestResult.
     * @param {TestResultUpdateArgs} args - Arguments to update one TestResult.
     * @example
     * // Update one TestResult
     * const testResult = await prisma.testResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TestResultUpdateArgs>(args: SelectSubset<T, TestResultUpdateArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TestResults.
     * @param {TestResultDeleteManyArgs} args - Arguments to filter TestResults to delete.
     * @example
     * // Delete a few TestResults
     * const { count } = await prisma.testResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TestResultDeleteManyArgs>(args?: SelectSubset<T, TestResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TestResults
     * const testResult = await prisma.testResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TestResultUpdateManyArgs>(args: SelectSubset<T, TestResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TestResults and returns the data updated in the database.
     * @param {TestResultUpdateManyAndReturnArgs} args - Arguments to update many TestResults.
     * @example
     * // Update many TestResults
     * const testResult = await prisma.testResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TestResults and only return the `id`
     * const testResultWithIdOnly = await prisma.testResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TestResultUpdateManyAndReturnArgs>(args: SelectSubset<T, TestResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TestResult.
     * @param {TestResultUpsertArgs} args - Arguments to update or create a TestResult.
     * @example
     * // Update or create a TestResult
     * const testResult = await prisma.testResult.upsert({
     *   create: {
     *     // ... data to create a TestResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TestResult we want to update
     *   }
     * })
     */
    upsert<T extends TestResultUpsertArgs>(args: SelectSubset<T, TestResultUpsertArgs<ExtArgs>>): Prisma__TestResultClient<$Result.GetResult<Prisma.$TestResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultCountArgs} args - Arguments to filter TestResults to count.
     * @example
     * // Count the number of TestResults
     * const count = await prisma.testResult.count({
     *   where: {
     *     // ... the filter for the TestResults we want to count
     *   }
     * })
    **/
    count<T extends TestResultCountArgs>(
      args?: Subset<T, TestResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TestResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TestResultAggregateArgs>(args: Subset<T, TestResultAggregateArgs>): Prisma.PrismaPromise<GetTestResultAggregateType<T>>

    /**
     * Group by TestResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TestResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TestResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TestResultGroupByArgs['orderBy'] }
        : { orderBy?: TestResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TestResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTestResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TestResult model
   */
  readonly fields: TestResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TestResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TestResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sample<T extends SampleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SampleDefaultArgs<ExtArgs>>): Prisma__SampleClient<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testParamater<T extends TestParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParameterDefaultArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TestResult model
   */
  interface TestResultFieldRefs {
    readonly id: FieldRef<"TestResult", 'String'>
    readonly sampleId: FieldRef<"TestResult", 'String'>
    readonly testParameterId: FieldRef<"TestResult", 'String'>
    readonly value: FieldRef<"TestResult", 'Float'>
    readonly interpretation: FieldRef<"TestResult", 'String'>
    readonly uplandInterpretation: FieldRef<"TestResult", 'String'>
    readonly wetlandInterpretation: FieldRef<"TestResult", 'String'>
    readonly analysisType: FieldRef<"TestResult", 'AnalysisType'>
    readonly createdAt: FieldRef<"TestResult", 'DateTime'>
    readonly updatedAt: FieldRef<"TestResult", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TestResult findUnique
   */
  export type TestResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult findUniqueOrThrow
   */
  export type TestResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult findFirst
   */
  export type TestResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResults.
     */
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult findFirstOrThrow
   */
  export type TestResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResult to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TestResults.
     */
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult findMany
   */
  export type TestResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter, which TestResults to fetch.
     */
    where?: TestResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TestResults to fetch.
     */
    orderBy?: TestResultOrderByWithRelationInput | TestResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TestResults.
     */
    cursor?: TestResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TestResults.
     */
    skip?: number
    distinct?: TestResultScalarFieldEnum | TestResultScalarFieldEnum[]
  }

  /**
   * TestResult create
   */
  export type TestResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * The data needed to create a TestResult.
     */
    data: XOR<TestResultCreateInput, TestResultUncheckedCreateInput>
  }

  /**
   * TestResult createMany
   */
  export type TestResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TestResults.
     */
    data: TestResultCreateManyInput | TestResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TestResult createManyAndReturn
   */
  export type TestResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The data used to create many TestResults.
     */
    data: TestResultCreateManyInput | TestResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestResult update
   */
  export type TestResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * The data needed to update a TestResult.
     */
    data: XOR<TestResultUpdateInput, TestResultUncheckedUpdateInput>
    /**
     * Choose, which TestResult to update.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult updateMany
   */
  export type TestResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TestResults.
     */
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyInput>
    /**
     * Filter which TestResults to update
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to update.
     */
    limit?: number
  }

  /**
   * TestResult updateManyAndReturn
   */
  export type TestResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * The data used to update TestResults.
     */
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyInput>
    /**
     * Filter which TestResults to update
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TestResult upsert
   */
  export type TestResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * The filter to search for the TestResult to update in case it exists.
     */
    where: TestResultWhereUniqueInput
    /**
     * In case the TestResult found by the `where` argument doesn't exist, create a new TestResult with this data.
     */
    create: XOR<TestResultCreateInput, TestResultUncheckedCreateInput>
    /**
     * In case the TestResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TestResultUpdateInput, TestResultUncheckedUpdateInput>
  }

  /**
   * TestResult delete
   */
  export type TestResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
    /**
     * Filter which TestResult to delete.
     */
    where: TestResultWhereUniqueInput
  }

  /**
   * TestResult deleteMany
   */
  export type TestResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TestResults to delete
     */
    where?: TestResultWhereInput
    /**
     * Limit how many TestResults to delete.
     */
    limit?: number
  }

  /**
   * TestResult without action
   */
  export type TestResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TestResult
     */
    select?: TestResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TestResult
     */
    omit?: TestResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TestResultInclude<ExtArgs> | null
  }


  /**
   * Model ComparisonRule
   */

  export type AggregateComparisonRule = {
    _count: ComparisonRuleCountAggregateOutputType | null
    _avg: ComparisonRuleAvgAggregateOutputType | null
    _sum: ComparisonRuleSumAggregateOutputType | null
    _min: ComparisonRuleMinAggregateOutputType | null
    _max: ComparisonRuleMaxAggregateOutputType | null
  }

  export type ComparisonRuleAvgAggregateOutputType = {
    min: number | null
    max: number | null
  }

  export type ComparisonRuleSumAggregateOutputType = {
    min: number | null
    max: number | null
  }

  export type ComparisonRuleMinAggregateOutputType = {
    id: string | null
    testParameterId: string | null
    soilCategory: $Enums.SoilCategory | null
    min: number | null
    max: number | null
    interpretation: string | null
    type: $Enums.ComparisonType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComparisonRuleMaxAggregateOutputType = {
    id: string | null
    testParameterId: string | null
    soilCategory: $Enums.SoilCategory | null
    min: number | null
    max: number | null
    interpretation: string | null
    type: $Enums.ComparisonType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComparisonRuleCountAggregateOutputType = {
    id: number
    testParameterId: number
    soilCategory: number
    min: number
    max: number
    interpretation: number
    type: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComparisonRuleAvgAggregateInputType = {
    min?: true
    max?: true
  }

  export type ComparisonRuleSumAggregateInputType = {
    min?: true
    max?: true
  }

  export type ComparisonRuleMinAggregateInputType = {
    id?: true
    testParameterId?: true
    soilCategory?: true
    min?: true
    max?: true
    interpretation?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComparisonRuleMaxAggregateInputType = {
    id?: true
    testParameterId?: true
    soilCategory?: true
    min?: true
    max?: true
    interpretation?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComparisonRuleCountAggregateInputType = {
    id?: true
    testParameterId?: true
    soilCategory?: true
    min?: true
    max?: true
    interpretation?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComparisonRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComparisonRule to aggregate.
     */
    where?: ComparisonRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparisonRules to fetch.
     */
    orderBy?: ComparisonRuleOrderByWithRelationInput | ComparisonRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComparisonRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparisonRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparisonRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComparisonRules
    **/
    _count?: true | ComparisonRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComparisonRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComparisonRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComparisonRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComparisonRuleMaxAggregateInputType
  }

  export type GetComparisonRuleAggregateType<T extends ComparisonRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateComparisonRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComparisonRule[P]>
      : GetScalarType<T[P], AggregateComparisonRule[P]>
  }




  export type ComparisonRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComparisonRuleWhereInput
    orderBy?: ComparisonRuleOrderByWithAggregationInput | ComparisonRuleOrderByWithAggregationInput[]
    by: ComparisonRuleScalarFieldEnum[] | ComparisonRuleScalarFieldEnum
    having?: ComparisonRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComparisonRuleCountAggregateInputType | true
    _avg?: ComparisonRuleAvgAggregateInputType
    _sum?: ComparisonRuleSumAggregateInputType
    _min?: ComparisonRuleMinAggregateInputType
    _max?: ComparisonRuleMaxAggregateInputType
  }

  export type ComparisonRuleGroupByOutputType = {
    id: string
    testParameterId: string
    soilCategory: $Enums.SoilCategory | null
    min: number | null
    max: number | null
    interpretation: string | null
    type: $Enums.ComparisonType
    createdAt: Date
    updatedAt: Date
    _count: ComparisonRuleCountAggregateOutputType | null
    _avg: ComparisonRuleAvgAggregateOutputType | null
    _sum: ComparisonRuleSumAggregateOutputType | null
    _min: ComparisonRuleMinAggregateOutputType | null
    _max: ComparisonRuleMaxAggregateOutputType | null
  }

  type GetComparisonRuleGroupByPayload<T extends ComparisonRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComparisonRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComparisonRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComparisonRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ComparisonRuleGroupByOutputType[P]>
        }
      >
    >


  export type ComparisonRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testParameterId?: boolean
    soilCategory?: boolean
    min?: boolean
    max?: boolean
    interpretation?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comparisonRule"]>

  export type ComparisonRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testParameterId?: boolean
    soilCategory?: boolean
    min?: boolean
    max?: boolean
    interpretation?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comparisonRule"]>

  export type ComparisonRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    testParameterId?: boolean
    soilCategory?: boolean
    min?: boolean
    max?: boolean
    interpretation?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comparisonRule"]>

  export type ComparisonRuleSelectScalar = {
    id?: boolean
    testParameterId?: boolean
    soilCategory?: boolean
    min?: boolean
    max?: boolean
    interpretation?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComparisonRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "testParameterId" | "soilCategory" | "min" | "max" | "interpretation" | "type" | "createdAt" | "updatedAt", ExtArgs["result"]["comparisonRule"]>
  export type ComparisonRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type ComparisonRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type ComparisonRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }

  export type $ComparisonRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComparisonRule"
    objects: {
      testParameter: Prisma.$TestParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      testParameterId: string
      soilCategory: $Enums.SoilCategory | null
      min: number | null
      max: number | null
      interpretation: string | null
      type: $Enums.ComparisonType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comparisonRule"]>
    composites: {}
  }

  type ComparisonRuleGetPayload<S extends boolean | null | undefined | ComparisonRuleDefaultArgs> = $Result.GetResult<Prisma.$ComparisonRulePayload, S>

  type ComparisonRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComparisonRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComparisonRuleCountAggregateInputType | true
    }

  export interface ComparisonRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComparisonRule'], meta: { name: 'ComparisonRule' } }
    /**
     * Find zero or one ComparisonRule that matches the filter.
     * @param {ComparisonRuleFindUniqueArgs} args - Arguments to find a ComparisonRule
     * @example
     * // Get one ComparisonRule
     * const comparisonRule = await prisma.comparisonRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComparisonRuleFindUniqueArgs>(args: SelectSubset<T, ComparisonRuleFindUniqueArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComparisonRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComparisonRuleFindUniqueOrThrowArgs} args - Arguments to find a ComparisonRule
     * @example
     * // Get one ComparisonRule
     * const comparisonRule = await prisma.comparisonRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComparisonRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ComparisonRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComparisonRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleFindFirstArgs} args - Arguments to find a ComparisonRule
     * @example
     * // Get one ComparisonRule
     * const comparisonRule = await prisma.comparisonRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComparisonRuleFindFirstArgs>(args?: SelectSubset<T, ComparisonRuleFindFirstArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComparisonRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleFindFirstOrThrowArgs} args - Arguments to find a ComparisonRule
     * @example
     * // Get one ComparisonRule
     * const comparisonRule = await prisma.comparisonRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComparisonRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ComparisonRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComparisonRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComparisonRules
     * const comparisonRules = await prisma.comparisonRule.findMany()
     * 
     * // Get first 10 ComparisonRules
     * const comparisonRules = await prisma.comparisonRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comparisonRuleWithIdOnly = await prisma.comparisonRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComparisonRuleFindManyArgs>(args?: SelectSubset<T, ComparisonRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComparisonRule.
     * @param {ComparisonRuleCreateArgs} args - Arguments to create a ComparisonRule.
     * @example
     * // Create one ComparisonRule
     * const ComparisonRule = await prisma.comparisonRule.create({
     *   data: {
     *     // ... data to create a ComparisonRule
     *   }
     * })
     * 
     */
    create<T extends ComparisonRuleCreateArgs>(args: SelectSubset<T, ComparisonRuleCreateArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComparisonRules.
     * @param {ComparisonRuleCreateManyArgs} args - Arguments to create many ComparisonRules.
     * @example
     * // Create many ComparisonRules
     * const comparisonRule = await prisma.comparisonRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComparisonRuleCreateManyArgs>(args?: SelectSubset<T, ComparisonRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComparisonRules and returns the data saved in the database.
     * @param {ComparisonRuleCreateManyAndReturnArgs} args - Arguments to create many ComparisonRules.
     * @example
     * // Create many ComparisonRules
     * const comparisonRule = await prisma.comparisonRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComparisonRules and only return the `id`
     * const comparisonRuleWithIdOnly = await prisma.comparisonRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComparisonRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, ComparisonRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComparisonRule.
     * @param {ComparisonRuleDeleteArgs} args - Arguments to delete one ComparisonRule.
     * @example
     * // Delete one ComparisonRule
     * const ComparisonRule = await prisma.comparisonRule.delete({
     *   where: {
     *     // ... filter to delete one ComparisonRule
     *   }
     * })
     * 
     */
    delete<T extends ComparisonRuleDeleteArgs>(args: SelectSubset<T, ComparisonRuleDeleteArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComparisonRule.
     * @param {ComparisonRuleUpdateArgs} args - Arguments to update one ComparisonRule.
     * @example
     * // Update one ComparisonRule
     * const comparisonRule = await prisma.comparisonRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComparisonRuleUpdateArgs>(args: SelectSubset<T, ComparisonRuleUpdateArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComparisonRules.
     * @param {ComparisonRuleDeleteManyArgs} args - Arguments to filter ComparisonRules to delete.
     * @example
     * // Delete a few ComparisonRules
     * const { count } = await prisma.comparisonRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComparisonRuleDeleteManyArgs>(args?: SelectSubset<T, ComparisonRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComparisonRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComparisonRules
     * const comparisonRule = await prisma.comparisonRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComparisonRuleUpdateManyArgs>(args: SelectSubset<T, ComparisonRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComparisonRules and returns the data updated in the database.
     * @param {ComparisonRuleUpdateManyAndReturnArgs} args - Arguments to update many ComparisonRules.
     * @example
     * // Update many ComparisonRules
     * const comparisonRule = await prisma.comparisonRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComparisonRules and only return the `id`
     * const comparisonRuleWithIdOnly = await prisma.comparisonRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComparisonRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, ComparisonRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComparisonRule.
     * @param {ComparisonRuleUpsertArgs} args - Arguments to update or create a ComparisonRule.
     * @example
     * // Update or create a ComparisonRule
     * const comparisonRule = await prisma.comparisonRule.upsert({
     *   create: {
     *     // ... data to create a ComparisonRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComparisonRule we want to update
     *   }
     * })
     */
    upsert<T extends ComparisonRuleUpsertArgs>(args: SelectSubset<T, ComparisonRuleUpsertArgs<ExtArgs>>): Prisma__ComparisonRuleClient<$Result.GetResult<Prisma.$ComparisonRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComparisonRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleCountArgs} args - Arguments to filter ComparisonRules to count.
     * @example
     * // Count the number of ComparisonRules
     * const count = await prisma.comparisonRule.count({
     *   where: {
     *     // ... the filter for the ComparisonRules we want to count
     *   }
     * })
    **/
    count<T extends ComparisonRuleCountArgs>(
      args?: Subset<T, ComparisonRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComparisonRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComparisonRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComparisonRuleAggregateArgs>(args: Subset<T, ComparisonRuleAggregateArgs>): Prisma.PrismaPromise<GetComparisonRuleAggregateType<T>>

    /**
     * Group by ComparisonRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComparisonRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComparisonRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComparisonRuleGroupByArgs['orderBy'] }
        : { orderBy?: ComparisonRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComparisonRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComparisonRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComparisonRule model
   */
  readonly fields: ComparisonRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComparisonRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComparisonRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testParameter<T extends TestParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParameterDefaultArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComparisonRule model
   */
  interface ComparisonRuleFieldRefs {
    readonly id: FieldRef<"ComparisonRule", 'String'>
    readonly testParameterId: FieldRef<"ComparisonRule", 'String'>
    readonly soilCategory: FieldRef<"ComparisonRule", 'SoilCategory'>
    readonly min: FieldRef<"ComparisonRule", 'Float'>
    readonly max: FieldRef<"ComparisonRule", 'Float'>
    readonly interpretation: FieldRef<"ComparisonRule", 'String'>
    readonly type: FieldRef<"ComparisonRule", 'ComparisonType'>
    readonly createdAt: FieldRef<"ComparisonRule", 'DateTime'>
    readonly updatedAt: FieldRef<"ComparisonRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComparisonRule findUnique
   */
  export type ComparisonRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComparisonRule to fetch.
     */
    where: ComparisonRuleWhereUniqueInput
  }

  /**
   * ComparisonRule findUniqueOrThrow
   */
  export type ComparisonRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComparisonRule to fetch.
     */
    where: ComparisonRuleWhereUniqueInput
  }

  /**
   * ComparisonRule findFirst
   */
  export type ComparisonRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComparisonRule to fetch.
     */
    where?: ComparisonRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparisonRules to fetch.
     */
    orderBy?: ComparisonRuleOrderByWithRelationInput | ComparisonRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComparisonRules.
     */
    cursor?: ComparisonRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparisonRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparisonRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComparisonRules.
     */
    distinct?: ComparisonRuleScalarFieldEnum | ComparisonRuleScalarFieldEnum[]
  }

  /**
   * ComparisonRule findFirstOrThrow
   */
  export type ComparisonRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComparisonRule to fetch.
     */
    where?: ComparisonRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparisonRules to fetch.
     */
    orderBy?: ComparisonRuleOrderByWithRelationInput | ComparisonRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComparisonRules.
     */
    cursor?: ComparisonRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparisonRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparisonRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComparisonRules.
     */
    distinct?: ComparisonRuleScalarFieldEnum | ComparisonRuleScalarFieldEnum[]
  }

  /**
   * ComparisonRule findMany
   */
  export type ComparisonRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * Filter, which ComparisonRules to fetch.
     */
    where?: ComparisonRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComparisonRules to fetch.
     */
    orderBy?: ComparisonRuleOrderByWithRelationInput | ComparisonRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComparisonRules.
     */
    cursor?: ComparisonRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComparisonRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComparisonRules.
     */
    skip?: number
    distinct?: ComparisonRuleScalarFieldEnum | ComparisonRuleScalarFieldEnum[]
  }

  /**
   * ComparisonRule create
   */
  export type ComparisonRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ComparisonRule.
     */
    data: XOR<ComparisonRuleCreateInput, ComparisonRuleUncheckedCreateInput>
  }

  /**
   * ComparisonRule createMany
   */
  export type ComparisonRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComparisonRules.
     */
    data: ComparisonRuleCreateManyInput | ComparisonRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComparisonRule createManyAndReturn
   */
  export type ComparisonRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * The data used to create many ComparisonRules.
     */
    data: ComparisonRuleCreateManyInput | ComparisonRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComparisonRule update
   */
  export type ComparisonRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ComparisonRule.
     */
    data: XOR<ComparisonRuleUpdateInput, ComparisonRuleUncheckedUpdateInput>
    /**
     * Choose, which ComparisonRule to update.
     */
    where: ComparisonRuleWhereUniqueInput
  }

  /**
   * ComparisonRule updateMany
   */
  export type ComparisonRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComparisonRules.
     */
    data: XOR<ComparisonRuleUpdateManyMutationInput, ComparisonRuleUncheckedUpdateManyInput>
    /**
     * Filter which ComparisonRules to update
     */
    where?: ComparisonRuleWhereInput
    /**
     * Limit how many ComparisonRules to update.
     */
    limit?: number
  }

  /**
   * ComparisonRule updateManyAndReturn
   */
  export type ComparisonRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * The data used to update ComparisonRules.
     */
    data: XOR<ComparisonRuleUpdateManyMutationInput, ComparisonRuleUncheckedUpdateManyInput>
    /**
     * Filter which ComparisonRules to update
     */
    where?: ComparisonRuleWhereInput
    /**
     * Limit how many ComparisonRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComparisonRule upsert
   */
  export type ComparisonRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ComparisonRule to update in case it exists.
     */
    where: ComparisonRuleWhereUniqueInput
    /**
     * In case the ComparisonRule found by the `where` argument doesn't exist, create a new ComparisonRule with this data.
     */
    create: XOR<ComparisonRuleCreateInput, ComparisonRuleUncheckedCreateInput>
    /**
     * In case the ComparisonRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComparisonRuleUpdateInput, ComparisonRuleUncheckedUpdateInput>
  }

  /**
   * ComparisonRule delete
   */
  export type ComparisonRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
    /**
     * Filter which ComparisonRule to delete.
     */
    where: ComparisonRuleWhereUniqueInput
  }

  /**
   * ComparisonRule deleteMany
   */
  export type ComparisonRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComparisonRules to delete
     */
    where?: ComparisonRuleWhereInput
    /**
     * Limit how many ComparisonRules to delete.
     */
    limit?: number
  }

  /**
   * ComparisonRule without action
   */
  export type ComparisonRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComparisonRule
     */
    select?: ComparisonRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComparisonRule
     */
    omit?: ComparisonRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComparisonRuleInclude<ExtArgs> | null
  }


  /**
   * Model Pricing
   */

  export type AggregatePricing = {
    _count: PricingCountAggregateOutputType | null
    _avg: PricingAvgAggregateOutputType | null
    _sum: PricingSumAggregateOutputType | null
    _min: PricingMinAggregateOutputType | null
    _max: PricingMaxAggregateOutputType | null
  }

  export type PricingAvgAggregateOutputType = {
    price: number | null
  }

  export type PricingSumAggregateOutputType = {
    price: number | null
  }

  export type PricingMinAggregateOutputType = {
    id: string | null
    clientType: $Enums.ClientType | null
    testParamterId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingMaxAggregateOutputType = {
    id: string | null
    clientType: $Enums.ClientType | null
    testParamterId: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PricingCountAggregateOutputType = {
    id: number
    clientType: number
    testParamterId: number
    price: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PricingAvgAggregateInputType = {
    price?: true
  }

  export type PricingSumAggregateInputType = {
    price?: true
  }

  export type PricingMinAggregateInputType = {
    id?: true
    clientType?: true
    testParamterId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingMaxAggregateInputType = {
    id?: true
    clientType?: true
    testParamterId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PricingCountAggregateInputType = {
    id?: true
    clientType?: true
    testParamterId?: true
    price?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pricing to aggregate.
     */
    where?: PricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pricings to fetch.
     */
    orderBy?: PricingOrderByWithRelationInput | PricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pricings
    **/
    _count?: true | PricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingMaxAggregateInputType
  }

  export type GetPricingAggregateType<T extends PricingAggregateArgs> = {
        [P in keyof T & keyof AggregatePricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricing[P]>
      : GetScalarType<T[P], AggregatePricing[P]>
  }




  export type PricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingWhereInput
    orderBy?: PricingOrderByWithAggregationInput | PricingOrderByWithAggregationInput[]
    by: PricingScalarFieldEnum[] | PricingScalarFieldEnum
    having?: PricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingCountAggregateInputType | true
    _avg?: PricingAvgAggregateInputType
    _sum?: PricingSumAggregateInputType
    _min?: PricingMinAggregateInputType
    _max?: PricingMaxAggregateInputType
  }

  export type PricingGroupByOutputType = {
    id: string
    clientType: $Enums.ClientType
    testParamterId: string
    price: number
    createdAt: Date
    updatedAt: Date
    _count: PricingCountAggregateOutputType | null
    _avg: PricingAvgAggregateOutputType | null
    _sum: PricingSumAggregateOutputType | null
    _min: PricingMinAggregateOutputType | null
    _max: PricingMaxAggregateOutputType | null
  }

  type GetPricingGroupByPayload<T extends PricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingGroupByOutputType[P]>
            : GetScalarType<T[P], PricingGroupByOutputType[P]>
        }
      >
    >


  export type PricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientType?: boolean
    testParamterId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricing"]>

  export type PricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientType?: boolean
    testParamterId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricing"]>

  export type PricingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientType?: boolean
    testParamterId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pricing"]>

  export type PricingSelectScalar = {
    id?: boolean
    clientType?: boolean
    testParamterId?: boolean
    price?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientType" | "testParamterId" | "price" | "createdAt" | "updatedAt", ExtArgs["result"]["pricing"]>
  export type PricingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type PricingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type PricingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    testParamater?: boolean | TestParameterDefaultArgs<ExtArgs>
  }

  export type $PricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pricing"
    objects: {
      testParamater: Prisma.$TestParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientType: $Enums.ClientType
      testParamterId: string
      price: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pricing"]>
    composites: {}
  }

  type PricingGetPayload<S extends boolean | null | undefined | PricingDefaultArgs> = $Result.GetResult<Prisma.$PricingPayload, S>

  type PricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingCountAggregateInputType | true
    }

  export interface PricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pricing'], meta: { name: 'Pricing' } }
    /**
     * Find zero or one Pricing that matches the filter.
     * @param {PricingFindUniqueArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingFindUniqueArgs>(args: SelectSubset<T, PricingFindUniqueArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricingFindUniqueOrThrowArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingFindFirstArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingFindFirstArgs>(args?: SelectSubset<T, PricingFindFirstArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingFindFirstOrThrowArgs} args - Arguments to find a Pricing
     * @example
     * // Get one Pricing
     * const pricing = await prisma.pricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pricings
     * const pricings = await prisma.pricing.findMany()
     * 
     * // Get first 10 Pricings
     * const pricings = await prisma.pricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingWithIdOnly = await prisma.pricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingFindManyArgs>(args?: SelectSubset<T, PricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pricing.
     * @param {PricingCreateArgs} args - Arguments to create a Pricing.
     * @example
     * // Create one Pricing
     * const Pricing = await prisma.pricing.create({
     *   data: {
     *     // ... data to create a Pricing
     *   }
     * })
     * 
     */
    create<T extends PricingCreateArgs>(args: SelectSubset<T, PricingCreateArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pricings.
     * @param {PricingCreateManyArgs} args - Arguments to create many Pricings.
     * @example
     * // Create many Pricings
     * const pricing = await prisma.pricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingCreateManyArgs>(args?: SelectSubset<T, PricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pricings and returns the data saved in the database.
     * @param {PricingCreateManyAndReturnArgs} args - Arguments to create many Pricings.
     * @example
     * // Create many Pricings
     * const pricing = await prisma.pricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pricings and only return the `id`
     * const pricingWithIdOnly = await prisma.pricing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PricingCreateManyAndReturnArgs>(args?: SelectSubset<T, PricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pricing.
     * @param {PricingDeleteArgs} args - Arguments to delete one Pricing.
     * @example
     * // Delete one Pricing
     * const Pricing = await prisma.pricing.delete({
     *   where: {
     *     // ... filter to delete one Pricing
     *   }
     * })
     * 
     */
    delete<T extends PricingDeleteArgs>(args: SelectSubset<T, PricingDeleteArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pricing.
     * @param {PricingUpdateArgs} args - Arguments to update one Pricing.
     * @example
     * // Update one Pricing
     * const pricing = await prisma.pricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingUpdateArgs>(args: SelectSubset<T, PricingUpdateArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pricings.
     * @param {PricingDeleteManyArgs} args - Arguments to filter Pricings to delete.
     * @example
     * // Delete a few Pricings
     * const { count } = await prisma.pricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingDeleteManyArgs>(args?: SelectSubset<T, PricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pricings
     * const pricing = await prisma.pricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingUpdateManyArgs>(args: SelectSubset<T, PricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pricings and returns the data updated in the database.
     * @param {PricingUpdateManyAndReturnArgs} args - Arguments to update many Pricings.
     * @example
     * // Update many Pricings
     * const pricing = await prisma.pricing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pricings and only return the `id`
     * const pricingWithIdOnly = await prisma.pricing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PricingUpdateManyAndReturnArgs>(args: SelectSubset<T, PricingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pricing.
     * @param {PricingUpsertArgs} args - Arguments to update or create a Pricing.
     * @example
     * // Update or create a Pricing
     * const pricing = await prisma.pricing.upsert({
     *   create: {
     *     // ... data to create a Pricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pricing we want to update
     *   }
     * })
     */
    upsert<T extends PricingUpsertArgs>(args: SelectSubset<T, PricingUpsertArgs<ExtArgs>>): Prisma__PricingClient<$Result.GetResult<Prisma.$PricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingCountArgs} args - Arguments to filter Pricings to count.
     * @example
     * // Count the number of Pricings
     * const count = await prisma.pricing.count({
     *   where: {
     *     // ... the filter for the Pricings we want to count
     *   }
     * })
    **/
    count<T extends PricingCountArgs>(
      args?: Subset<T, PricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingAggregateArgs>(args: Subset<T, PricingAggregateArgs>): Prisma.PrismaPromise<GetPricingAggregateType<T>>

    /**
     * Group by Pricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingGroupByArgs['orderBy'] }
        : { orderBy?: PricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pricing model
   */
  readonly fields: PricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    testParamater<T extends TestParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParameterDefaultArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pricing model
   */
  interface PricingFieldRefs {
    readonly id: FieldRef<"Pricing", 'String'>
    readonly clientType: FieldRef<"Pricing", 'ClientType'>
    readonly testParamterId: FieldRef<"Pricing", 'String'>
    readonly price: FieldRef<"Pricing", 'Float'>
    readonly createdAt: FieldRef<"Pricing", 'DateTime'>
    readonly updatedAt: FieldRef<"Pricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pricing findUnique
   */
  export type PricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * Filter, which Pricing to fetch.
     */
    where: PricingWhereUniqueInput
  }

  /**
   * Pricing findUniqueOrThrow
   */
  export type PricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * Filter, which Pricing to fetch.
     */
    where: PricingWhereUniqueInput
  }

  /**
   * Pricing findFirst
   */
  export type PricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * Filter, which Pricing to fetch.
     */
    where?: PricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pricings to fetch.
     */
    orderBy?: PricingOrderByWithRelationInput | PricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pricings.
     */
    cursor?: PricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pricings.
     */
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * Pricing findFirstOrThrow
   */
  export type PricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * Filter, which Pricing to fetch.
     */
    where?: PricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pricings to fetch.
     */
    orderBy?: PricingOrderByWithRelationInput | PricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pricings.
     */
    cursor?: PricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pricings.
     */
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * Pricing findMany
   */
  export type PricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * Filter, which Pricings to fetch.
     */
    where?: PricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pricings to fetch.
     */
    orderBy?: PricingOrderByWithRelationInput | PricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pricings.
     */
    cursor?: PricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pricings.
     */
    skip?: number
    distinct?: PricingScalarFieldEnum | PricingScalarFieldEnum[]
  }

  /**
   * Pricing create
   */
  export type PricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * The data needed to create a Pricing.
     */
    data: XOR<PricingCreateInput, PricingUncheckedCreateInput>
  }

  /**
   * Pricing createMany
   */
  export type PricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pricings.
     */
    data: PricingCreateManyInput | PricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pricing createManyAndReturn
   */
  export type PricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * The data used to create many Pricings.
     */
    data: PricingCreateManyInput | PricingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pricing update
   */
  export type PricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * The data needed to update a Pricing.
     */
    data: XOR<PricingUpdateInput, PricingUncheckedUpdateInput>
    /**
     * Choose, which Pricing to update.
     */
    where: PricingWhereUniqueInput
  }

  /**
   * Pricing updateMany
   */
  export type PricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pricings.
     */
    data: XOR<PricingUpdateManyMutationInput, PricingUncheckedUpdateManyInput>
    /**
     * Filter which Pricings to update
     */
    where?: PricingWhereInput
    /**
     * Limit how many Pricings to update.
     */
    limit?: number
  }

  /**
   * Pricing updateManyAndReturn
   */
  export type PricingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * The data used to update Pricings.
     */
    data: XOR<PricingUpdateManyMutationInput, PricingUncheckedUpdateManyInput>
    /**
     * Filter which Pricings to update
     */
    where?: PricingWhereInput
    /**
     * Limit how many Pricings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pricing upsert
   */
  export type PricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * The filter to search for the Pricing to update in case it exists.
     */
    where: PricingWhereUniqueInput
    /**
     * In case the Pricing found by the `where` argument doesn't exist, create a new Pricing with this data.
     */
    create: XOR<PricingCreateInput, PricingUncheckedCreateInput>
    /**
     * In case the Pricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingUpdateInput, PricingUncheckedUpdateInput>
  }

  /**
   * Pricing delete
   */
  export type PricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
    /**
     * Filter which Pricing to delete.
     */
    where: PricingWhereUniqueInput
  }

  /**
   * Pricing deleteMany
   */
  export type PricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pricings to delete
     */
    where?: PricingWhereInput
    /**
     * Limit how many Pricings to delete.
     */
    limit?: number
  }

  /**
   * Pricing without action
   */
  export type PricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pricing
     */
    select?: PricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pricing
     */
    omit?: PricingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PricingInclude<ExtArgs> | null
  }


  /**
   * Model Institute
   */

  export type AggregateInstitute = {
    _count: InstituteCountAggregateOutputType | null
    _min: InstituteMinAggregateOutputType | null
    _max: InstituteMaxAggregateOutputType | null
  }

  export type InstituteMinAggregateOutputType = {
    id: string | null
    prapok: string | null
    name: string | null
    address: string | null
    issuedby: string | null
    phone: string | null
    updatedAt: Date | null
  }

  export type InstituteMaxAggregateOutputType = {
    id: string | null
    prapok: string | null
    name: string | null
    address: string | null
    issuedby: string | null
    phone: string | null
    updatedAt: Date | null
  }

  export type InstituteCountAggregateOutputType = {
    id: number
    prapok: number
    name: number
    address: number
    issuedby: number
    phone: number
    updatedAt: number
    _all: number
  }


  export type InstituteMinAggregateInputType = {
    id?: true
    prapok?: true
    name?: true
    address?: true
    issuedby?: true
    phone?: true
    updatedAt?: true
  }

  export type InstituteMaxAggregateInputType = {
    id?: true
    prapok?: true
    name?: true
    address?: true
    issuedby?: true
    phone?: true
    updatedAt?: true
  }

  export type InstituteCountAggregateInputType = {
    id?: true
    prapok?: true
    name?: true
    address?: true
    issuedby?: true
    phone?: true
    updatedAt?: true
    _all?: true
  }

  export type InstituteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institute to aggregate.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Institutes
    **/
    _count?: true | InstituteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstituteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstituteMaxAggregateInputType
  }

  export type GetInstituteAggregateType<T extends InstituteAggregateArgs> = {
        [P in keyof T & keyof AggregateInstitute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstitute[P]>
      : GetScalarType<T[P], AggregateInstitute[P]>
  }




  export type InstituteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstituteWhereInput
    orderBy?: InstituteOrderByWithAggregationInput | InstituteOrderByWithAggregationInput[]
    by: InstituteScalarFieldEnum[] | InstituteScalarFieldEnum
    having?: InstituteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstituteCountAggregateInputType | true
    _min?: InstituteMinAggregateInputType
    _max?: InstituteMaxAggregateInputType
  }

  export type InstituteGroupByOutputType = {
    id: string
    prapok: string
    name: string
    address: string
    issuedby: string
    phone: string | null
    updatedAt: Date
    _count: InstituteCountAggregateOutputType | null
    _min: InstituteMinAggregateOutputType | null
    _max: InstituteMaxAggregateOutputType | null
  }

  type GetInstituteGroupByPayload<T extends InstituteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstituteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstituteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstituteGroupByOutputType[P]>
            : GetScalarType<T[P], InstituteGroupByOutputType[P]>
        }
      >
    >


  export type InstituteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prapok?: boolean
    name?: boolean
    address?: boolean
    issuedby?: boolean
    phone?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["institute"]>

  export type InstituteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prapok?: boolean
    name?: boolean
    address?: boolean
    issuedby?: boolean
    phone?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["institute"]>

  export type InstituteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    prapok?: boolean
    name?: boolean
    address?: boolean
    issuedby?: boolean
    phone?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["institute"]>

  export type InstituteSelectScalar = {
    id?: boolean
    prapok?: boolean
    name?: boolean
    address?: boolean
    issuedby?: boolean
    phone?: boolean
    updatedAt?: boolean
  }

  export type InstituteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "prapok" | "name" | "address" | "issuedby" | "phone" | "updatedAt", ExtArgs["result"]["institute"]>

  export type $InstitutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Institute"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      prapok: string
      name: string
      address: string
      issuedby: string
      phone: string | null
      updatedAt: Date
    }, ExtArgs["result"]["institute"]>
    composites: {}
  }

  type InstituteGetPayload<S extends boolean | null | undefined | InstituteDefaultArgs> = $Result.GetResult<Prisma.$InstitutePayload, S>

  type InstituteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstituteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstituteCountAggregateInputType | true
    }

  export interface InstituteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Institute'], meta: { name: 'Institute' } }
    /**
     * Find zero or one Institute that matches the filter.
     * @param {InstituteFindUniqueArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstituteFindUniqueArgs>(args: SelectSubset<T, InstituteFindUniqueArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Institute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstituteFindUniqueOrThrowArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstituteFindUniqueOrThrowArgs>(args: SelectSubset<T, InstituteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFindFirstArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstituteFindFirstArgs>(args?: SelectSubset<T, InstituteFindFirstArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Institute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFindFirstOrThrowArgs} args - Arguments to find a Institute
     * @example
     * // Get one Institute
     * const institute = await prisma.institute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstituteFindFirstOrThrowArgs>(args?: SelectSubset<T, InstituteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Institutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Institutes
     * const institutes = await prisma.institute.findMany()
     * 
     * // Get first 10 Institutes
     * const institutes = await prisma.institute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instituteWithIdOnly = await prisma.institute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstituteFindManyArgs>(args?: SelectSubset<T, InstituteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Institute.
     * @param {InstituteCreateArgs} args - Arguments to create a Institute.
     * @example
     * // Create one Institute
     * const Institute = await prisma.institute.create({
     *   data: {
     *     // ... data to create a Institute
     *   }
     * })
     * 
     */
    create<T extends InstituteCreateArgs>(args: SelectSubset<T, InstituteCreateArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Institutes.
     * @param {InstituteCreateManyArgs} args - Arguments to create many Institutes.
     * @example
     * // Create many Institutes
     * const institute = await prisma.institute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstituteCreateManyArgs>(args?: SelectSubset<T, InstituteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Institutes and returns the data saved in the database.
     * @param {InstituteCreateManyAndReturnArgs} args - Arguments to create many Institutes.
     * @example
     * // Create many Institutes
     * const institute = await prisma.institute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Institutes and only return the `id`
     * const instituteWithIdOnly = await prisma.institute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstituteCreateManyAndReturnArgs>(args?: SelectSubset<T, InstituteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Institute.
     * @param {InstituteDeleteArgs} args - Arguments to delete one Institute.
     * @example
     * // Delete one Institute
     * const Institute = await prisma.institute.delete({
     *   where: {
     *     // ... filter to delete one Institute
     *   }
     * })
     * 
     */
    delete<T extends InstituteDeleteArgs>(args: SelectSubset<T, InstituteDeleteArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Institute.
     * @param {InstituteUpdateArgs} args - Arguments to update one Institute.
     * @example
     * // Update one Institute
     * const institute = await prisma.institute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstituteUpdateArgs>(args: SelectSubset<T, InstituteUpdateArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Institutes.
     * @param {InstituteDeleteManyArgs} args - Arguments to filter Institutes to delete.
     * @example
     * // Delete a few Institutes
     * const { count } = await prisma.institute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstituteDeleteManyArgs>(args?: SelectSubset<T, InstituteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Institutes
     * const institute = await prisma.institute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstituteUpdateManyArgs>(args: SelectSubset<T, InstituteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Institutes and returns the data updated in the database.
     * @param {InstituteUpdateManyAndReturnArgs} args - Arguments to update many Institutes.
     * @example
     * // Update many Institutes
     * const institute = await prisma.institute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Institutes and only return the `id`
     * const instituteWithIdOnly = await prisma.institute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstituteUpdateManyAndReturnArgs>(args: SelectSubset<T, InstituteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Institute.
     * @param {InstituteUpsertArgs} args - Arguments to update or create a Institute.
     * @example
     * // Update or create a Institute
     * const institute = await prisma.institute.upsert({
     *   create: {
     *     // ... data to create a Institute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Institute we want to update
     *   }
     * })
     */
    upsert<T extends InstituteUpsertArgs>(args: SelectSubset<T, InstituteUpsertArgs<ExtArgs>>): Prisma__InstituteClient<$Result.GetResult<Prisma.$InstitutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Institutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteCountArgs} args - Arguments to filter Institutes to count.
     * @example
     * // Count the number of Institutes
     * const count = await prisma.institute.count({
     *   where: {
     *     // ... the filter for the Institutes we want to count
     *   }
     * })
    **/
    count<T extends InstituteCountArgs>(
      args?: Subset<T, InstituteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstituteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Institute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstituteAggregateArgs>(args: Subset<T, InstituteAggregateArgs>): Prisma.PrismaPromise<GetInstituteAggregateType<T>>

    /**
     * Group by Institute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstituteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstituteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstituteGroupByArgs['orderBy'] }
        : { orderBy?: InstituteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstituteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstituteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Institute model
   */
  readonly fields: InstituteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Institute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstituteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Institute model
   */
  interface InstituteFieldRefs {
    readonly id: FieldRef<"Institute", 'String'>
    readonly prapok: FieldRef<"Institute", 'String'>
    readonly name: FieldRef<"Institute", 'String'>
    readonly address: FieldRef<"Institute", 'String'>
    readonly issuedby: FieldRef<"Institute", 'String'>
    readonly phone: FieldRef<"Institute", 'String'>
    readonly updatedAt: FieldRef<"Institute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Institute findUnique
   */
  export type InstituteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute findUniqueOrThrow
   */
  export type InstituteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute findFirst
   */
  export type InstituteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Institute findFirstOrThrow
   */
  export type InstituteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Filter, which Institute to fetch.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Institutes.
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Institutes.
     */
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Institute findMany
   */
  export type InstituteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Filter, which Institutes to fetch.
     */
    where?: InstituteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Institutes to fetch.
     */
    orderBy?: InstituteOrderByWithRelationInput | InstituteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Institutes.
     */
    cursor?: InstituteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Institutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Institutes.
     */
    skip?: number
    distinct?: InstituteScalarFieldEnum | InstituteScalarFieldEnum[]
  }

  /**
   * Institute create
   */
  export type InstituteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The data needed to create a Institute.
     */
    data: XOR<InstituteCreateInput, InstituteUncheckedCreateInput>
  }

  /**
   * Institute createMany
   */
  export type InstituteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Institutes.
     */
    data: InstituteCreateManyInput | InstituteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institute createManyAndReturn
   */
  export type InstituteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The data used to create many Institutes.
     */
    data: InstituteCreateManyInput | InstituteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Institute update
   */
  export type InstituteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The data needed to update a Institute.
     */
    data: XOR<InstituteUpdateInput, InstituteUncheckedUpdateInput>
    /**
     * Choose, which Institute to update.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute updateMany
   */
  export type InstituteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Institutes.
     */
    data: XOR<InstituteUpdateManyMutationInput, InstituteUncheckedUpdateManyInput>
    /**
     * Filter which Institutes to update
     */
    where?: InstituteWhereInput
    /**
     * Limit how many Institutes to update.
     */
    limit?: number
  }

  /**
   * Institute updateManyAndReturn
   */
  export type InstituteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The data used to update Institutes.
     */
    data: XOR<InstituteUpdateManyMutationInput, InstituteUncheckedUpdateManyInput>
    /**
     * Filter which Institutes to update
     */
    where?: InstituteWhereInput
    /**
     * Limit how many Institutes to update.
     */
    limit?: number
  }

  /**
   * Institute upsert
   */
  export type InstituteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * The filter to search for the Institute to update in case it exists.
     */
    where: InstituteWhereUniqueInput
    /**
     * In case the Institute found by the `where` argument doesn't exist, create a new Institute with this data.
     */
    create: XOR<InstituteCreateInput, InstituteUncheckedCreateInput>
    /**
     * In case the Institute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstituteUpdateInput, InstituteUncheckedUpdateInput>
  }

  /**
   * Institute delete
   */
  export type InstituteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
    /**
     * Filter which Institute to delete.
     */
    where: InstituteWhereUniqueInput
  }

  /**
   * Institute deleteMany
   */
  export type InstituteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Institutes to delete
     */
    where?: InstituteWhereInput
    /**
     * Limit how many Institutes to delete.
     */
    limit?: number
  }

  /**
   * Institute without action
   */
  export type InstituteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Institute
     */
    select?: InstituteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Institute
     */
    omit?: InstituteOmit<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderSumAggregateOutputType = {
    totalAmount: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    sarokNumber: string | null
    orderDate: Date | null
    status: $Enums.OrderStatus | null
    operatorId: string | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
    reportId: string | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    sarokNumber: string | null
    orderDate: Date | null
    status: $Enums.OrderStatus | null
    operatorId: string | null
    totalAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    invoiceId: string | null
    reportId: string | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    clientId: number
    sarokNumber: number
    orderDate: number
    status: number
    operatorId: number
    totalAmount: number
    createdAt: number
    updatedAt: number
    invoiceId: number
    reportId: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    totalAmount?: true
  }

  export type OrderSumAggregateInputType = {
    totalAmount?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    clientId?: true
    sarokNumber?: true
    orderDate?: true
    status?: true
    operatorId?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    reportId?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    clientId?: true
    sarokNumber?: true
    orderDate?: true
    status?: true
    operatorId?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    reportId?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    clientId?: true
    sarokNumber?: true
    orderDate?: true
    status?: true
    operatorId?: true
    totalAmount?: true
    createdAt?: true
    updatedAt?: true
    invoiceId?: true
    reportId?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    clientId: string
    sarokNumber: string | null
    orderDate: Date
    status: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt: Date
    updatedAt: Date
    invoiceId: string | null
    reportId: string | null
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    sarokNumber?: boolean
    orderDate?: boolean
    status?: boolean
    operatorId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    reportId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | Order$samplesArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    report?: boolean | Order$reportArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    sarokNumber?: boolean
    orderDate?: boolean
    status?: boolean
    operatorId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    reportId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    sarokNumber?: boolean
    orderDate?: boolean
    status?: boolean
    operatorId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    reportId?: boolean
    client?: boolean | ClientDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    clientId?: boolean
    sarokNumber?: boolean
    orderDate?: boolean
    status?: boolean
    operatorId?: boolean
    totalAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoiceId?: boolean
    reportId?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "sarokNumber" | "orderDate" | "status" | "operatorId" | "totalAmount" | "createdAt" | "updatedAt" | "invoiceId" | "reportId", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | Order$samplesArgs<ExtArgs>
    orderItems?: boolean | Order$orderItemsArgs<ExtArgs>
    invoice?: boolean | Order$invoiceArgs<ExtArgs>
    report?: boolean | Order$reportArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientDefaultArgs<ExtArgs>
    operator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      client: Prisma.$ClientPayload<ExtArgs>
      operator: Prisma.$UserPayload<ExtArgs>
      samples: Prisma.$SamplePayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      report: Prisma.$ReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      sarokNumber: string | null
      orderDate: Date
      status: $Enums.OrderStatus
      operatorId: string
      totalAmount: number
      createdAt: Date
      updatedAt: Date
      invoiceId: string | null
      reportId: string | null
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    operator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    samples<T extends Order$samplesArgs<ExtArgs> = {}>(args?: Subset<T, Order$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderItems<T extends Order$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Order$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoice<T extends Order$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Order$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    report<T extends Order$reportArgs<ExtArgs> = {}>(args?: Subset<T, Order$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly clientId: FieldRef<"Order", 'String'>
    readonly sarokNumber: FieldRef<"Order", 'String'>
    readonly orderDate: FieldRef<"Order", 'DateTime'>
    readonly status: FieldRef<"Order", 'OrderStatus'>
    readonly operatorId: FieldRef<"Order", 'String'>
    readonly totalAmount: FieldRef<"Order", 'Float'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
    readonly invoiceId: FieldRef<"Order", 'String'>
    readonly reportId: FieldRef<"Order", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.samples
   */
  export type Order$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    cursor?: SampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Order.orderItems
   */
  export type Order$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Order.invoice
   */
  export type Order$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Order.report
   */
  export type Order$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    agroTestId: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    agroTestId: string | null
    quantity: number | null
    unitPrice: number | null
    subtotal: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    agroTestId: number
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type OrderItemSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    subtotal?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    agroTestId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    agroTestId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    agroTestId?: true
    quantity?: true
    unitPrice?: true
    subtotal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: string
    orderId: string
    agroTestId: string
    quantity: number
    unitPrice: number
    subtotal: number
    createdAt: Date
    updatedAt: Date
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agroTestId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
    orderTestParameters?: boolean | OrderItem$orderTestParametersArgs<ExtArgs>
    sample?: boolean | OrderItem$sampleArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agroTestId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    agroTestId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>

  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    agroTestId?: boolean
    quantity?: boolean
    unitPrice?: boolean
    subtotal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "agroTestId" | "quantity" | "unitPrice" | "subtotal" | "createdAt" | "updatedAt", ExtArgs["result"]["orderItem"]>
  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
    orderTestParameters?: boolean | OrderItem$orderTestParametersArgs<ExtArgs>
    sample?: boolean | OrderItem$sampleArgs<ExtArgs>
    _count?: boolean | OrderItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }
  export type OrderItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    agroTest?: boolean | AgrotestDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      agroTest: Prisma.$AgrotestPayload<ExtArgs>
      orderTestParameters: Prisma.$OrderTestParameterPayload<ExtArgs>[]
      sample: Prisma.$SamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      agroTestId: string
      quantity: number
      unitPrice: number
      subtotal: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems and returns the data updated in the database.
     * @param {OrderItemUpdateManyAndReturnArgs} args - Arguments to update many OrderItems.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderItems and only return the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderItemUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    agroTest<T extends AgrotestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgrotestDefaultArgs<ExtArgs>>): Prisma__AgrotestClient<$Result.GetResult<Prisma.$AgrotestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderTestParameters<T extends OrderItem$orderTestParametersArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$orderTestParametersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sample<T extends OrderItem$sampleArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$sampleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'String'>
    readonly orderId: FieldRef<"OrderItem", 'String'>
    readonly agroTestId: FieldRef<"OrderItem", 'String'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly unitPrice: FieldRef<"OrderItem", 'Float'>
    readonly subtotal: FieldRef<"OrderItem", 'Float'>
    readonly createdAt: FieldRef<"OrderItem", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem createManyAndReturn
   */
  export type OrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
  }

  /**
   * OrderItem updateManyAndReturn
   */
  export type OrderItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
    /**
     * Limit how many OrderItems to delete.
     */
    limit?: number
  }

  /**
   * OrderItem.orderTestParameters
   */
  export type OrderItem$orderTestParametersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    where?: OrderTestParameterWhereInput
    orderBy?: OrderTestParameterOrderByWithRelationInput | OrderTestParameterOrderByWithRelationInput[]
    cursor?: OrderTestParameterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderTestParameterScalarFieldEnum | OrderTestParameterScalarFieldEnum[]
  }

  /**
   * OrderItem.sample
   */
  export type OrderItem$sampleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    cursor?: SampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderItem
     */
    omit?: OrderItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model OrderTestParameter
   */

  export type AggregateOrderTestParameter = {
    _count: OrderTestParameterCountAggregateOutputType | null
    _min: OrderTestParameterMinAggregateOutputType | null
    _max: OrderTestParameterMaxAggregateOutputType | null
  }

  export type OrderTestParameterMinAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    testParameterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderTestParameterMaxAggregateOutputType = {
    id: string | null
    orderItemId: string | null
    testParameterId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderTestParameterCountAggregateOutputType = {
    id: number
    orderItemId: number
    testParameterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderTestParameterMinAggregateInputType = {
    id?: true
    orderItemId?: true
    testParameterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderTestParameterMaxAggregateInputType = {
    id?: true
    orderItemId?: true
    testParameterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderTestParameterCountAggregateInputType = {
    id?: true
    orderItemId?: true
    testParameterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderTestParameterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderTestParameter to aggregate.
     */
    where?: OrderTestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTestParameters to fetch.
     */
    orderBy?: OrderTestParameterOrderByWithRelationInput | OrderTestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderTestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTestParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderTestParameters
    **/
    _count?: true | OrderTestParameterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderTestParameterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderTestParameterMaxAggregateInputType
  }

  export type GetOrderTestParameterAggregateType<T extends OrderTestParameterAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderTestParameter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderTestParameter[P]>
      : GetScalarType<T[P], AggregateOrderTestParameter[P]>
  }




  export type OrderTestParameterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderTestParameterWhereInput
    orderBy?: OrderTestParameterOrderByWithAggregationInput | OrderTestParameterOrderByWithAggregationInput[]
    by: OrderTestParameterScalarFieldEnum[] | OrderTestParameterScalarFieldEnum
    having?: OrderTestParameterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderTestParameterCountAggregateInputType | true
    _min?: OrderTestParameterMinAggregateInputType
    _max?: OrderTestParameterMaxAggregateInputType
  }

  export type OrderTestParameterGroupByOutputType = {
    id: string
    orderItemId: string
    testParameterId: string
    createdAt: Date
    updatedAt: Date
    _count: OrderTestParameterCountAggregateOutputType | null
    _min: OrderTestParameterMinAggregateOutputType | null
    _max: OrderTestParameterMaxAggregateOutputType | null
  }

  type GetOrderTestParameterGroupByPayload<T extends OrderTestParameterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderTestParameterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderTestParameterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderTestParameterGroupByOutputType[P]>
            : GetScalarType<T[P], OrderTestParameterGroupByOutputType[P]>
        }
      >
    >


  export type OrderTestParameterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    testParameterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderTestParameter"]>

  export type OrderTestParameterSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    testParameterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderTestParameter"]>

  export type OrderTestParameterSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderItemId?: boolean
    testParameterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderTestParameter"]>

  export type OrderTestParameterSelectScalar = {
    id?: boolean
    orderItemId?: boolean
    testParameterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderTestParameterOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderItemId" | "testParameterId" | "createdAt" | "updatedAt", ExtArgs["result"]["orderTestParameter"]>
  export type OrderTestParameterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type OrderTestParameterIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }
  export type OrderTestParameterIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItem?: boolean | OrderItemDefaultArgs<ExtArgs>
    testParameter?: boolean | TestParameterDefaultArgs<ExtArgs>
  }

  export type $OrderTestParameterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderTestParameter"
    objects: {
      orderItem: Prisma.$OrderItemPayload<ExtArgs>
      testParameter: Prisma.$TestParameterPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderItemId: string
      testParameterId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderTestParameter"]>
    composites: {}
  }

  type OrderTestParameterGetPayload<S extends boolean | null | undefined | OrderTestParameterDefaultArgs> = $Result.GetResult<Prisma.$OrderTestParameterPayload, S>

  type OrderTestParameterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderTestParameterFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderTestParameterCountAggregateInputType | true
    }

  export interface OrderTestParameterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderTestParameter'], meta: { name: 'OrderTestParameter' } }
    /**
     * Find zero or one OrderTestParameter that matches the filter.
     * @param {OrderTestParameterFindUniqueArgs} args - Arguments to find a OrderTestParameter
     * @example
     * // Get one OrderTestParameter
     * const orderTestParameter = await prisma.orderTestParameter.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderTestParameterFindUniqueArgs>(args: SelectSubset<T, OrderTestParameterFindUniqueArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderTestParameter that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderTestParameterFindUniqueOrThrowArgs} args - Arguments to find a OrderTestParameter
     * @example
     * // Get one OrderTestParameter
     * const orderTestParameter = await prisma.orderTestParameter.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderTestParameterFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderTestParameterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderTestParameter that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterFindFirstArgs} args - Arguments to find a OrderTestParameter
     * @example
     * // Get one OrderTestParameter
     * const orderTestParameter = await prisma.orderTestParameter.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderTestParameterFindFirstArgs>(args?: SelectSubset<T, OrderTestParameterFindFirstArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderTestParameter that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterFindFirstOrThrowArgs} args - Arguments to find a OrderTestParameter
     * @example
     * // Get one OrderTestParameter
     * const orderTestParameter = await prisma.orderTestParameter.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderTestParameterFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderTestParameterFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderTestParameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderTestParameters
     * const orderTestParameters = await prisma.orderTestParameter.findMany()
     * 
     * // Get first 10 OrderTestParameters
     * const orderTestParameters = await prisma.orderTestParameter.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderTestParameterWithIdOnly = await prisma.orderTestParameter.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderTestParameterFindManyArgs>(args?: SelectSubset<T, OrderTestParameterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderTestParameter.
     * @param {OrderTestParameterCreateArgs} args - Arguments to create a OrderTestParameter.
     * @example
     * // Create one OrderTestParameter
     * const OrderTestParameter = await prisma.orderTestParameter.create({
     *   data: {
     *     // ... data to create a OrderTestParameter
     *   }
     * })
     * 
     */
    create<T extends OrderTestParameterCreateArgs>(args: SelectSubset<T, OrderTestParameterCreateArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderTestParameters.
     * @param {OrderTestParameterCreateManyArgs} args - Arguments to create many OrderTestParameters.
     * @example
     * // Create many OrderTestParameters
     * const orderTestParameter = await prisma.orderTestParameter.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderTestParameterCreateManyArgs>(args?: SelectSubset<T, OrderTestParameterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderTestParameters and returns the data saved in the database.
     * @param {OrderTestParameterCreateManyAndReturnArgs} args - Arguments to create many OrderTestParameters.
     * @example
     * // Create many OrderTestParameters
     * const orderTestParameter = await prisma.orderTestParameter.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderTestParameters and only return the `id`
     * const orderTestParameterWithIdOnly = await prisma.orderTestParameter.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderTestParameterCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderTestParameterCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderTestParameter.
     * @param {OrderTestParameterDeleteArgs} args - Arguments to delete one OrderTestParameter.
     * @example
     * // Delete one OrderTestParameter
     * const OrderTestParameter = await prisma.orderTestParameter.delete({
     *   where: {
     *     // ... filter to delete one OrderTestParameter
     *   }
     * })
     * 
     */
    delete<T extends OrderTestParameterDeleteArgs>(args: SelectSubset<T, OrderTestParameterDeleteArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderTestParameter.
     * @param {OrderTestParameterUpdateArgs} args - Arguments to update one OrderTestParameter.
     * @example
     * // Update one OrderTestParameter
     * const orderTestParameter = await prisma.orderTestParameter.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderTestParameterUpdateArgs>(args: SelectSubset<T, OrderTestParameterUpdateArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderTestParameters.
     * @param {OrderTestParameterDeleteManyArgs} args - Arguments to filter OrderTestParameters to delete.
     * @example
     * // Delete a few OrderTestParameters
     * const { count } = await prisma.orderTestParameter.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderTestParameterDeleteManyArgs>(args?: SelectSubset<T, OrderTestParameterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTestParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderTestParameters
     * const orderTestParameter = await prisma.orderTestParameter.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderTestParameterUpdateManyArgs>(args: SelectSubset<T, OrderTestParameterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderTestParameters and returns the data updated in the database.
     * @param {OrderTestParameterUpdateManyAndReturnArgs} args - Arguments to update many OrderTestParameters.
     * @example
     * // Update many OrderTestParameters
     * const orderTestParameter = await prisma.orderTestParameter.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderTestParameters and only return the `id`
     * const orderTestParameterWithIdOnly = await prisma.orderTestParameter.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderTestParameterUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderTestParameterUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderTestParameter.
     * @param {OrderTestParameterUpsertArgs} args - Arguments to update or create a OrderTestParameter.
     * @example
     * // Update or create a OrderTestParameter
     * const orderTestParameter = await prisma.orderTestParameter.upsert({
     *   create: {
     *     // ... data to create a OrderTestParameter
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderTestParameter we want to update
     *   }
     * })
     */
    upsert<T extends OrderTestParameterUpsertArgs>(args: SelectSubset<T, OrderTestParameterUpsertArgs<ExtArgs>>): Prisma__OrderTestParameterClient<$Result.GetResult<Prisma.$OrderTestParameterPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderTestParameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterCountArgs} args - Arguments to filter OrderTestParameters to count.
     * @example
     * // Count the number of OrderTestParameters
     * const count = await prisma.orderTestParameter.count({
     *   where: {
     *     // ... the filter for the OrderTestParameters we want to count
     *   }
     * })
    **/
    count<T extends OrderTestParameterCountArgs>(
      args?: Subset<T, OrderTestParameterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderTestParameterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderTestParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderTestParameterAggregateArgs>(args: Subset<T, OrderTestParameterAggregateArgs>): Prisma.PrismaPromise<GetOrderTestParameterAggregateType<T>>

    /**
     * Group by OrderTestParameter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderTestParameterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderTestParameterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderTestParameterGroupByArgs['orderBy'] }
        : { orderBy?: OrderTestParameterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderTestParameterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderTestParameterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderTestParameter model
   */
  readonly fields: OrderTestParameterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderTestParameter.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderTestParameterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItem<T extends OrderItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderItemDefaultArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    testParameter<T extends TestParameterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TestParameterDefaultArgs<ExtArgs>>): Prisma__TestParameterClient<$Result.GetResult<Prisma.$TestParameterPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderTestParameter model
   */
  interface OrderTestParameterFieldRefs {
    readonly id: FieldRef<"OrderTestParameter", 'String'>
    readonly orderItemId: FieldRef<"OrderTestParameter", 'String'>
    readonly testParameterId: FieldRef<"OrderTestParameter", 'String'>
    readonly createdAt: FieldRef<"OrderTestParameter", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderTestParameter", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderTestParameter findUnique
   */
  export type OrderTestParameterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * Filter, which OrderTestParameter to fetch.
     */
    where: OrderTestParameterWhereUniqueInput
  }

  /**
   * OrderTestParameter findUniqueOrThrow
   */
  export type OrderTestParameterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * Filter, which OrderTestParameter to fetch.
     */
    where: OrderTestParameterWhereUniqueInput
  }

  /**
   * OrderTestParameter findFirst
   */
  export type OrderTestParameterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * Filter, which OrderTestParameter to fetch.
     */
    where?: OrderTestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTestParameters to fetch.
     */
    orderBy?: OrderTestParameterOrderByWithRelationInput | OrderTestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTestParameters.
     */
    cursor?: OrderTestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTestParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTestParameters.
     */
    distinct?: OrderTestParameterScalarFieldEnum | OrderTestParameterScalarFieldEnum[]
  }

  /**
   * OrderTestParameter findFirstOrThrow
   */
  export type OrderTestParameterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * Filter, which OrderTestParameter to fetch.
     */
    where?: OrderTestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTestParameters to fetch.
     */
    orderBy?: OrderTestParameterOrderByWithRelationInput | OrderTestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderTestParameters.
     */
    cursor?: OrderTestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTestParameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderTestParameters.
     */
    distinct?: OrderTestParameterScalarFieldEnum | OrderTestParameterScalarFieldEnum[]
  }

  /**
   * OrderTestParameter findMany
   */
  export type OrderTestParameterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * Filter, which OrderTestParameters to fetch.
     */
    where?: OrderTestParameterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderTestParameters to fetch.
     */
    orderBy?: OrderTestParameterOrderByWithRelationInput | OrderTestParameterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderTestParameters.
     */
    cursor?: OrderTestParameterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderTestParameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderTestParameters.
     */
    skip?: number
    distinct?: OrderTestParameterScalarFieldEnum | OrderTestParameterScalarFieldEnum[]
  }

  /**
   * OrderTestParameter create
   */
  export type OrderTestParameterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderTestParameter.
     */
    data: XOR<OrderTestParameterCreateInput, OrderTestParameterUncheckedCreateInput>
  }

  /**
   * OrderTestParameter createMany
   */
  export type OrderTestParameterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderTestParameters.
     */
    data: OrderTestParameterCreateManyInput | OrderTestParameterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderTestParameter createManyAndReturn
   */
  export type OrderTestParameterCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * The data used to create many OrderTestParameters.
     */
    data: OrderTestParameterCreateManyInput | OrderTestParameterCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderTestParameter update
   */
  export type OrderTestParameterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderTestParameter.
     */
    data: XOR<OrderTestParameterUpdateInput, OrderTestParameterUncheckedUpdateInput>
    /**
     * Choose, which OrderTestParameter to update.
     */
    where: OrderTestParameterWhereUniqueInput
  }

  /**
   * OrderTestParameter updateMany
   */
  export type OrderTestParameterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderTestParameters.
     */
    data: XOR<OrderTestParameterUpdateManyMutationInput, OrderTestParameterUncheckedUpdateManyInput>
    /**
     * Filter which OrderTestParameters to update
     */
    where?: OrderTestParameterWhereInput
    /**
     * Limit how many OrderTestParameters to update.
     */
    limit?: number
  }

  /**
   * OrderTestParameter updateManyAndReturn
   */
  export type OrderTestParameterUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * The data used to update OrderTestParameters.
     */
    data: XOR<OrderTestParameterUpdateManyMutationInput, OrderTestParameterUncheckedUpdateManyInput>
    /**
     * Filter which OrderTestParameters to update
     */
    where?: OrderTestParameterWhereInput
    /**
     * Limit how many OrderTestParameters to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderTestParameter upsert
   */
  export type OrderTestParameterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderTestParameter to update in case it exists.
     */
    where: OrderTestParameterWhereUniqueInput
    /**
     * In case the OrderTestParameter found by the `where` argument doesn't exist, create a new OrderTestParameter with this data.
     */
    create: XOR<OrderTestParameterCreateInput, OrderTestParameterUncheckedCreateInput>
    /**
     * In case the OrderTestParameter was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderTestParameterUpdateInput, OrderTestParameterUncheckedUpdateInput>
  }

  /**
   * OrderTestParameter delete
   */
  export type OrderTestParameterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
    /**
     * Filter which OrderTestParameter to delete.
     */
    where: OrderTestParameterWhereUniqueInput
  }

  /**
   * OrderTestParameter deleteMany
   */
  export type OrderTestParameterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderTestParameters to delete
     */
    where?: OrderTestParameterWhereInput
    /**
     * Limit how many OrderTestParameters to delete.
     */
    limit?: number
  }

  /**
   * OrderTestParameter without action
   */
  export type OrderTestParameterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderTestParameter
     */
    select?: OrderTestParameterSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderTestParameter
     */
    omit?: OrderTestParameterOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderTestParameterInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    totalAmount: number | null
    paidAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    totalAmount: number | null
    paidAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    clientId: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    totalAmount: number | null
    paidAmount: number | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reportId: string | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    clientId: string | null
    invoiceDate: Date | null
    dueDate: Date | null
    totalAmount: number | null
    paidAmount: number | null
    status: $Enums.InvoiceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    reportId: string | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    orderId: number
    clientId: number
    invoiceDate: number
    dueDate: number
    totalAmount: number
    paidAmount: number
    status: number
    createdAt: number
    updatedAt: number
    reportId: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    totalAmount?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reportId?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reportId?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    invoiceDate?: true
    dueDate?: true
    totalAmount?: true
    paidAmount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    reportId?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    orderId: string
    clientId: string
    invoiceDate: Date
    dueDate: Date | null
    totalAmount: number
    paidAmount: number
    status: $Enums.InvoiceStatus
    createdAt: Date
    updatedAt: Date
    reportId: string | null
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    report?: boolean | Invoice$reportArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceDate?: boolean
    dueDate?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reportId?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "clientId" | "invoiceDate" | "dueDate" | "totalAmount" | "paidAmount" | "status" | "createdAt" | "updatedAt" | "reportId", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    report?: boolean | Invoice$reportArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      report: Prisma.$ReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      clientId: string
      invoiceDate: Date
      dueDate: Date | null
      totalAmount: number
      paidAmount: number
      status: $Enums.InvoiceStatus
      createdAt: Date
      updatedAt: Date
      reportId: string | null
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    report<T extends Invoice$reportArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$reportArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly orderId: FieldRef<"Invoice", 'String'>
    readonly clientId: FieldRef<"Invoice", 'String'>
    readonly invoiceDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly totalAmount: FieldRef<"Invoice", 'Float'>
    readonly paidAmount: FieldRef<"Invoice", 'Float'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly reportId: FieldRef<"Invoice", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.report
   */
  export type Invoice$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    orderId: string | null
    clientId: string | null
    invoiceId: string | null
    reportType: string | null
    reportNumber: string | null
    issueDate: Date | null
    status: $Enums.ReportStatus | null
    recommendations: string | null
    notes: string | null
    generatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    orderId: string | null
    clientId: string | null
    invoiceId: string | null
    reportType: string | null
    reportNumber: string | null
    issueDate: Date | null
    status: $Enums.ReportStatus | null
    recommendations: string | null
    notes: string | null
    generatedByUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    orderId: number
    clientId: number
    invoiceId: number
    reportType: number
    reportNumber: number
    issueDate: number
    status: number
    recommendations: number
    notes: number
    generatedByUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    invoiceId?: true
    reportType?: true
    reportNumber?: true
    issueDate?: true
    status?: true
    recommendations?: true
    notes?: true
    generatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    invoiceId?: true
    reportType?: true
    reportNumber?: true
    issueDate?: true
    status?: true
    recommendations?: true
    notes?: true
    generatedByUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    invoiceId?: true
    reportType?: true
    reportNumber?: true
    issueDate?: true
    status?: true
    recommendations?: true
    notes?: true
    generatedByUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    orderId: string
    clientId: string
    invoiceId: string | null
    reportType: string
    reportNumber: string
    issueDate: Date
    status: $Enums.ReportStatus
    recommendations: string | null
    notes: string | null
    generatedByUserId: string
    createdAt: Date
    updatedAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceId?: boolean
    reportType?: boolean
    reportNumber?: boolean
    issueDate?: boolean
    status?: boolean
    recommendations?: boolean
    notes?: boolean
    generatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoice?: boolean | Report$invoiceArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | Report$samplesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceId?: boolean
    reportType?: boolean
    reportNumber?: boolean
    issueDate?: boolean
    status?: boolean
    recommendations?: boolean
    notes?: boolean
    generatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoice?: boolean | Report$invoiceArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceId?: boolean
    reportType?: boolean
    reportNumber?: boolean
    issueDate?: boolean
    status?: boolean
    recommendations?: boolean
    notes?: boolean
    generatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoice?: boolean | Report$invoiceArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>

  export type ReportSelectScalar = {
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    invoiceId?: boolean
    reportType?: boolean
    reportNumber?: boolean
    issueDate?: boolean
    status?: boolean
    recommendations?: boolean
    notes?: boolean
    generatedByUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "orderId" | "clientId" | "invoiceId" | "reportType" | "reportNumber" | "issueDate" | "status" | "recommendations" | "notes" | "generatedByUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["report"]>
  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoice?: boolean | Report$invoiceArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
    samples?: boolean | Report$samplesArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoice?: boolean | Report$invoiceArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | OrderDefaultArgs<ExtArgs>
    client?: boolean | ClientDefaultArgs<ExtArgs>
    invoice?: boolean | Report$invoiceArgs<ExtArgs>
    generator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs>
      client: Prisma.$ClientPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs> | null
      generator: Prisma.$UserPayload<ExtArgs>
      samples: Prisma.$SamplePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      orderId: string
      clientId: string
      invoiceId: string | null
      reportType: string
      reportNumber: string
      issueDate: Date
      status: $Enums.ReportStatus
      recommendations: string | null
      notes: string | null
      generatedByUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reports and returns the data saved in the database.
     * @param {ReportCreateManyAndReturnArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports and returns the data updated in the database.
     * @param {ReportUpdateManyAndReturnArgs} args - Arguments to update many Reports.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reports and only return the `id`
     * const reportWithIdOnly = await prisma.report.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends ClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientDefaultArgs<ExtArgs>>): Prisma__ClientClient<$Result.GetResult<Prisma.$ClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invoice<T extends Report$invoiceArgs<ExtArgs> = {}>(args?: Subset<T, Report$invoiceArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    generator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    samples<T extends Report$samplesArgs<ExtArgs> = {}>(args?: Subset<T, Report$samplesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SamplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly orderId: FieldRef<"Report", 'String'>
    readonly clientId: FieldRef<"Report", 'String'>
    readonly invoiceId: FieldRef<"Report", 'String'>
    readonly reportType: FieldRef<"Report", 'String'>
    readonly reportNumber: FieldRef<"Report", 'String'>
    readonly issueDate: FieldRef<"Report", 'DateTime'>
    readonly status: FieldRef<"Report", 'ReportStatus'>
    readonly recommendations: FieldRef<"Report", 'String'>
    readonly notes: FieldRef<"Report", 'String'>
    readonly generatedByUserId: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly updatedAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report createManyAndReturn
   */
  export type ReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
  }

  /**
   * Report updateManyAndReturn
   */
  export type ReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
    /**
     * Limit how many Reports to delete.
     */
    limit?: number
  }

  /**
   * Report.invoice
   */
  export type Report$invoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
  }

  /**
   * Report.samples
   */
  export type Report$samplesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sample
     */
    select?: SampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sample
     */
    omit?: SampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SampleInclude<ExtArgs> | null
    where?: SampleWhereInput
    orderBy?: SampleOrderByWithRelationInput | SampleOrderByWithRelationInput[]
    cursor?: SampleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SampleScalarFieldEnum | SampleScalarFieldEnum[]
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Report
     */
    omit?: ReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ClientScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    clientType: 'clientType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientScalarFieldEnum = (typeof ClientScalarFieldEnum)[keyof typeof ClientScalarFieldEnum]


  export const AgrotestScalarFieldEnum: {
    id: 'id',
    name: 'name',
    sampleType: 'sampleType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgrotestScalarFieldEnum = (typeof AgrotestScalarFieldEnum)[keyof typeof AgrotestScalarFieldEnum]


  export const TestParameterScalarFieldEnum: {
    id: 'id',
    agroTestID: 'agroTestID',
    name: 'name',
    unit: 'unit',
    analysisType: 'analysisType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestParameterScalarFieldEnum = (typeof TestParameterScalarFieldEnum)[keyof typeof TestParameterScalarFieldEnum]


  export const SampleScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    orderItemId: 'orderItemId',
    sampleIdNumber: 'sampleIdNumber',
    collectionDate: 'collectionDate',
    sampleType: 'sampleType',
    collectionLocation: 'collectionLocation',
    cropType: 'cropType',
    bunot: 'bunot',
    manchitroUnit: 'manchitroUnit',
    vumiSrini: 'vumiSrini',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reportId: 'reportId'
  };

  export type SampleScalarFieldEnum = (typeof SampleScalarFieldEnum)[keyof typeof SampleScalarFieldEnum]


  export const TestResultScalarFieldEnum: {
    id: 'id',
    sampleId: 'sampleId',
    testParameterId: 'testParameterId',
    value: 'value',
    interpretation: 'interpretation',
    uplandInterpretation: 'uplandInterpretation',
    wetlandInterpretation: 'wetlandInterpretation',
    analysisType: 'analysisType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TestResultScalarFieldEnum = (typeof TestResultScalarFieldEnum)[keyof typeof TestResultScalarFieldEnum]


  export const ComparisonRuleScalarFieldEnum: {
    id: 'id',
    testParameterId: 'testParameterId',
    soilCategory: 'soilCategory',
    min: 'min',
    max: 'max',
    interpretation: 'interpretation',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComparisonRuleScalarFieldEnum = (typeof ComparisonRuleScalarFieldEnum)[keyof typeof ComparisonRuleScalarFieldEnum]


  export const PricingScalarFieldEnum: {
    id: 'id',
    clientType: 'clientType',
    testParamterId: 'testParamterId',
    price: 'price',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PricingScalarFieldEnum = (typeof PricingScalarFieldEnum)[keyof typeof PricingScalarFieldEnum]


  export const InstituteScalarFieldEnum: {
    id: 'id',
    prapok: 'prapok',
    name: 'name',
    address: 'address',
    issuedby: 'issuedby',
    phone: 'phone',
    updatedAt: 'updatedAt'
  };

  export type InstituteScalarFieldEnum = (typeof InstituteScalarFieldEnum)[keyof typeof InstituteScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    sarokNumber: 'sarokNumber',
    orderDate: 'orderDate',
    status: 'status',
    operatorId: 'operatorId',
    totalAmount: 'totalAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    invoiceId: 'invoiceId',
    reportId: 'reportId'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    agroTestId: 'agroTestId',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    subtotal: 'subtotal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const OrderTestParameterScalarFieldEnum: {
    id: 'id',
    orderItemId: 'orderItemId',
    testParameterId: 'testParameterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderTestParameterScalarFieldEnum = (typeof OrderTestParameterScalarFieldEnum)[keyof typeof OrderTestParameterScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    clientId: 'clientId',
    invoiceDate: 'invoiceDate',
    dueDate: 'dueDate',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reportId: 'reportId'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    clientId: 'clientId',
    invoiceId: 'invoiceId',
    reportType: 'reportType',
    reportNumber: 'reportNumber',
    issueDate: 'issueDate',
    status: 'status',
    recommendations: 'recommendations',
    notes: 'notes',
    generatedByUserId: 'generatedByUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ClientType'
   */
  export type EnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType'>
    


  /**
   * Reference to a field of type 'ClientType[]'
   */
  export type ListEnumClientTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientType[]'>
    


  /**
   * Reference to a field of type 'SampleType'
   */
  export type EnumSampleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleType'>
    


  /**
   * Reference to a field of type 'SampleType[]'
   */
  export type ListEnumSampleTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleType[]'>
    


  /**
   * Reference to a field of type 'AnalysisType'
   */
  export type EnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType'>
    


  /**
   * Reference to a field of type 'AnalysisType[]'
   */
  export type ListEnumAnalysisTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalysisType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'SampleStatus'
   */
  export type EnumSampleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleStatus'>
    


  /**
   * Reference to a field of type 'SampleStatus[]'
   */
  export type ListEnumSampleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SampleStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'SoilCategory'
   */
  export type EnumSoilCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SoilCategory'>
    


  /**
   * Reference to a field of type 'SoilCategory[]'
   */
  export type ListEnumSoilCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SoilCategory[]'>
    


  /**
   * Reference to a field of type 'ComparisonType'
   */
  export type EnumComparisonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComparisonType'>
    


  /**
   * Reference to a field of type 'ComparisonType[]'
   */
  export type ListEnumComparisonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComparisonType[]'>
    


  /**
   * Reference to a field of type 'OrderStatus'
   */
  export type EnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus'>
    


  /**
   * Reference to a field of type 'OrderStatus[]'
   */
  export type ListEnumOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'ReportStatus'
   */
  export type EnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus'>
    


  /**
   * Reference to a field of type 'ReportStatus[]'
   */
  export type ListEnumReportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    imageUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    orders?: OrderListRelationFilter
    reports?: ReportListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ClientWhereInput = {
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    id?: StringFilter<"Client"> | string
    name?: StringFilter<"Client"> | string
    address?: StringNullableFilter<"Client"> | string | null
    phone?: StringNullableFilter<"Client"> | string | null
    clientType?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type ClientOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    clientType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type ClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone?: string
    AND?: ClientWhereInput | ClientWhereInput[]
    OR?: ClientWhereInput[]
    NOT?: ClientWhereInput | ClientWhereInput[]
    name?: StringFilter<"Client"> | string
    address?: StringNullableFilter<"Client"> | string | null
    clientType?: EnumClientTypeFilter<"Client"> | $Enums.ClientType
    createdAt?: DateTimeFilter<"Client"> | Date | string
    updatedAt?: DateTimeFilter<"Client"> | Date | string
    orders?: OrderListRelationFilter
    invoices?: InvoiceListRelationFilter
    reports?: ReportListRelationFilter
  }, "id" | "phone">

  export type ClientOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    clientType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientCountOrderByAggregateInput
    _max?: ClientMaxOrderByAggregateInput
    _min?: ClientMinOrderByAggregateInput
  }

  export type ClientScalarWhereWithAggregatesInput = {
    AND?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    OR?: ClientScalarWhereWithAggregatesInput[]
    NOT?: ClientScalarWhereWithAggregatesInput | ClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Client"> | string
    name?: StringWithAggregatesFilter<"Client"> | string
    address?: StringNullableWithAggregatesFilter<"Client"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Client"> | string | null
    clientType?: EnumClientTypeWithAggregatesFilter<"Client"> | $Enums.ClientType
    createdAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Client"> | Date | string
  }

  export type AgrotestWhereInput = {
    AND?: AgrotestWhereInput | AgrotestWhereInput[]
    OR?: AgrotestWhereInput[]
    NOT?: AgrotestWhereInput | AgrotestWhereInput[]
    id?: StringFilter<"Agrotest"> | string
    name?: StringFilter<"Agrotest"> | string
    sampleType?: EnumSampleTypeFilter<"Agrotest"> | $Enums.SampleType
    createdAt?: DateTimeFilter<"Agrotest"> | Date | string
    updatedAt?: DateTimeFilter<"Agrotest"> | Date | string
    testParameter?: TestParameterListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }

  export type AgrotestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    sampleType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testParameter?: TestParameterOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type AgrotestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AgrotestWhereInput | AgrotestWhereInput[]
    OR?: AgrotestWhereInput[]
    NOT?: AgrotestWhereInput | AgrotestWhereInput[]
    sampleType?: EnumSampleTypeFilter<"Agrotest"> | $Enums.SampleType
    createdAt?: DateTimeFilter<"Agrotest"> | Date | string
    updatedAt?: DateTimeFilter<"Agrotest"> | Date | string
    testParameter?: TestParameterListRelationFilter
    orderItems?: OrderItemListRelationFilter
  }, "id" | "name">

  export type AgrotestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    sampleType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgrotestCountOrderByAggregateInput
    _max?: AgrotestMaxOrderByAggregateInput
    _min?: AgrotestMinOrderByAggregateInput
  }

  export type AgrotestScalarWhereWithAggregatesInput = {
    AND?: AgrotestScalarWhereWithAggregatesInput | AgrotestScalarWhereWithAggregatesInput[]
    OR?: AgrotestScalarWhereWithAggregatesInput[]
    NOT?: AgrotestScalarWhereWithAggregatesInput | AgrotestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agrotest"> | string
    name?: StringWithAggregatesFilter<"Agrotest"> | string
    sampleType?: EnumSampleTypeWithAggregatesFilter<"Agrotest"> | $Enums.SampleType
    createdAt?: DateTimeWithAggregatesFilter<"Agrotest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agrotest"> | Date | string
  }

  export type TestParameterWhereInput = {
    AND?: TestParameterWhereInput | TestParameterWhereInput[]
    OR?: TestParameterWhereInput[]
    NOT?: TestParameterWhereInput | TestParameterWhereInput[]
    id?: StringFilter<"TestParameter"> | string
    agroTestID?: StringFilter<"TestParameter"> | string
    name?: StringFilter<"TestParameter"> | string
    unit?: StringNullableFilter<"TestParameter"> | string | null
    analysisType?: EnumAnalysisTypeNullableFilter<"TestParameter"> | $Enums.AnalysisType | null
    createdAt?: DateTimeFilter<"TestParameter"> | Date | string
    updatedAt?: DateTimeFilter<"TestParameter"> | Date | string
    agroTest?: XOR<AgrotestScalarRelationFilter, AgrotestWhereInput>
    pricing?: PricingListRelationFilter
    comparisonRules?: ComparisonRuleListRelationFilter
    testResults?: TestResultListRelationFilter
    orderTestParameters?: OrderTestParameterListRelationFilter
  }

  export type TestParameterOrderByWithRelationInput = {
    id?: SortOrder
    agroTestID?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    analysisType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agroTest?: AgrotestOrderByWithRelationInput
    pricing?: PricingOrderByRelationAggregateInput
    comparisonRules?: ComparisonRuleOrderByRelationAggregateInput
    testResults?: TestResultOrderByRelationAggregateInput
    orderTestParameters?: OrderTestParameterOrderByRelationAggregateInput
  }

  export type TestParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestParameterWhereInput | TestParameterWhereInput[]
    OR?: TestParameterWhereInput[]
    NOT?: TestParameterWhereInput | TestParameterWhereInput[]
    agroTestID?: StringFilter<"TestParameter"> | string
    name?: StringFilter<"TestParameter"> | string
    unit?: StringNullableFilter<"TestParameter"> | string | null
    analysisType?: EnumAnalysisTypeNullableFilter<"TestParameter"> | $Enums.AnalysisType | null
    createdAt?: DateTimeFilter<"TestParameter"> | Date | string
    updatedAt?: DateTimeFilter<"TestParameter"> | Date | string
    agroTest?: XOR<AgrotestScalarRelationFilter, AgrotestWhereInput>
    pricing?: PricingListRelationFilter
    comparisonRules?: ComparisonRuleListRelationFilter
    testResults?: TestResultListRelationFilter
    orderTestParameters?: OrderTestParameterListRelationFilter
  }, "id">

  export type TestParameterOrderByWithAggregationInput = {
    id?: SortOrder
    agroTestID?: SortOrder
    name?: SortOrder
    unit?: SortOrderInput | SortOrder
    analysisType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestParameterCountOrderByAggregateInput
    _max?: TestParameterMaxOrderByAggregateInput
    _min?: TestParameterMinOrderByAggregateInput
  }

  export type TestParameterScalarWhereWithAggregatesInput = {
    AND?: TestParameterScalarWhereWithAggregatesInput | TestParameterScalarWhereWithAggregatesInput[]
    OR?: TestParameterScalarWhereWithAggregatesInput[]
    NOT?: TestParameterScalarWhereWithAggregatesInput | TestParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestParameter"> | string
    agroTestID?: StringWithAggregatesFilter<"TestParameter"> | string
    name?: StringWithAggregatesFilter<"TestParameter"> | string
    unit?: StringNullableWithAggregatesFilter<"TestParameter"> | string | null
    analysisType?: EnumAnalysisTypeNullableWithAggregatesFilter<"TestParameter"> | $Enums.AnalysisType | null
    createdAt?: DateTimeWithAggregatesFilter<"TestParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestParameter"> | Date | string
  }

  export type SampleWhereInput = {
    AND?: SampleWhereInput | SampleWhereInput[]
    OR?: SampleWhereInput[]
    NOT?: SampleWhereInput | SampleWhereInput[]
    id?: StringFilter<"Sample"> | string
    orderId?: StringFilter<"Sample"> | string
    orderItemId?: StringFilter<"Sample"> | string
    sampleIdNumber?: StringFilter<"Sample"> | string
    collectionDate?: DateTimeFilter<"Sample"> | Date | string
    sampleType?: EnumSampleTypeFilter<"Sample"> | $Enums.SampleType
    collectionLocation?: StringNullableFilter<"Sample"> | string | null
    cropType?: StringNullableFilter<"Sample"> | string | null
    bunot?: StringNullableFilter<"Sample"> | string | null
    manchitroUnit?: IntNullableFilter<"Sample"> | number | null
    vumiSrini?: StringNullableFilter<"Sample"> | string | null
    status?: EnumSampleStatusFilter<"Sample"> | $Enums.SampleStatus
    createdAt?: DateTimeFilter<"Sample"> | Date | string
    updatedAt?: DateTimeFilter<"Sample"> | Date | string
    reportId?: StringNullableFilter<"Sample"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    testResults?: TestResultListRelationFilter
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }

  export type SampleOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    sampleIdNumber?: SortOrder
    collectionDate?: SortOrder
    sampleType?: SortOrder
    collectionLocation?: SortOrderInput | SortOrder
    cropType?: SortOrderInput | SortOrder
    bunot?: SortOrderInput | SortOrder
    manchitroUnit?: SortOrderInput | SortOrder
    vumiSrini?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    orderItem?: OrderItemOrderByWithRelationInput
    testResults?: TestResultOrderByRelationAggregateInput
    report?: ReportOrderByWithRelationInput
  }

  export type SampleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sampleIdNumber?: string
    AND?: SampleWhereInput | SampleWhereInput[]
    OR?: SampleWhereInput[]
    NOT?: SampleWhereInput | SampleWhereInput[]
    orderId?: StringFilter<"Sample"> | string
    orderItemId?: StringFilter<"Sample"> | string
    collectionDate?: DateTimeFilter<"Sample"> | Date | string
    sampleType?: EnumSampleTypeFilter<"Sample"> | $Enums.SampleType
    collectionLocation?: StringNullableFilter<"Sample"> | string | null
    cropType?: StringNullableFilter<"Sample"> | string | null
    bunot?: StringNullableFilter<"Sample"> | string | null
    manchitroUnit?: IntNullableFilter<"Sample"> | number | null
    vumiSrini?: StringNullableFilter<"Sample"> | string | null
    status?: EnumSampleStatusFilter<"Sample"> | $Enums.SampleStatus
    createdAt?: DateTimeFilter<"Sample"> | Date | string
    updatedAt?: DateTimeFilter<"Sample"> | Date | string
    reportId?: StringNullableFilter<"Sample"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    testResults?: TestResultListRelationFilter
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }, "id" | "sampleIdNumber">

  export type SampleOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    sampleIdNumber?: SortOrder
    collectionDate?: SortOrder
    sampleType?: SortOrder
    collectionLocation?: SortOrderInput | SortOrder
    cropType?: SortOrderInput | SortOrder
    bunot?: SortOrderInput | SortOrder
    manchitroUnit?: SortOrderInput | SortOrder
    vumiSrini?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrderInput | SortOrder
    _count?: SampleCountOrderByAggregateInput
    _avg?: SampleAvgOrderByAggregateInput
    _max?: SampleMaxOrderByAggregateInput
    _min?: SampleMinOrderByAggregateInput
    _sum?: SampleSumOrderByAggregateInput
  }

  export type SampleScalarWhereWithAggregatesInput = {
    AND?: SampleScalarWhereWithAggregatesInput | SampleScalarWhereWithAggregatesInput[]
    OR?: SampleScalarWhereWithAggregatesInput[]
    NOT?: SampleScalarWhereWithAggregatesInput | SampleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sample"> | string
    orderId?: StringWithAggregatesFilter<"Sample"> | string
    orderItemId?: StringWithAggregatesFilter<"Sample"> | string
    sampleIdNumber?: StringWithAggregatesFilter<"Sample"> | string
    collectionDate?: DateTimeWithAggregatesFilter<"Sample"> | Date | string
    sampleType?: EnumSampleTypeWithAggregatesFilter<"Sample"> | $Enums.SampleType
    collectionLocation?: StringNullableWithAggregatesFilter<"Sample"> | string | null
    cropType?: StringNullableWithAggregatesFilter<"Sample"> | string | null
    bunot?: StringNullableWithAggregatesFilter<"Sample"> | string | null
    manchitroUnit?: IntNullableWithAggregatesFilter<"Sample"> | number | null
    vumiSrini?: StringNullableWithAggregatesFilter<"Sample"> | string | null
    status?: EnumSampleStatusWithAggregatesFilter<"Sample"> | $Enums.SampleStatus
    createdAt?: DateTimeWithAggregatesFilter<"Sample"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sample"> | Date | string
    reportId?: StringNullableWithAggregatesFilter<"Sample"> | string | null
  }

  export type TestResultWhereInput = {
    AND?: TestResultWhereInput | TestResultWhereInput[]
    OR?: TestResultWhereInput[]
    NOT?: TestResultWhereInput | TestResultWhereInput[]
    id?: StringFilter<"TestResult"> | string
    sampleId?: StringFilter<"TestResult"> | string
    testParameterId?: StringFilter<"TestResult"> | string
    value?: FloatNullableFilter<"TestResult"> | number | null
    interpretation?: StringNullableFilter<"TestResult"> | string | null
    uplandInterpretation?: StringNullableFilter<"TestResult"> | string | null
    wetlandInterpretation?: StringNullableFilter<"TestResult"> | string | null
    analysisType?: EnumAnalysisTypeNullableFilter<"TestResult"> | $Enums.AnalysisType | null
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
    updatedAt?: DateTimeFilter<"TestResult"> | Date | string
    sample?: XOR<SampleScalarRelationFilter, SampleWhereInput>
    testParamater?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }

  export type TestResultOrderByWithRelationInput = {
    id?: SortOrder
    sampleId?: SortOrder
    testParameterId?: SortOrder
    value?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    uplandInterpretation?: SortOrderInput | SortOrder
    wetlandInterpretation?: SortOrderInput | SortOrder
    analysisType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sample?: SampleOrderByWithRelationInput
    testParamater?: TestParameterOrderByWithRelationInput
  }

  export type TestResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TestResultWhereInput | TestResultWhereInput[]
    OR?: TestResultWhereInput[]
    NOT?: TestResultWhereInput | TestResultWhereInput[]
    sampleId?: StringFilter<"TestResult"> | string
    testParameterId?: StringFilter<"TestResult"> | string
    value?: FloatNullableFilter<"TestResult"> | number | null
    interpretation?: StringNullableFilter<"TestResult"> | string | null
    uplandInterpretation?: StringNullableFilter<"TestResult"> | string | null
    wetlandInterpretation?: StringNullableFilter<"TestResult"> | string | null
    analysisType?: EnumAnalysisTypeNullableFilter<"TestResult"> | $Enums.AnalysisType | null
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
    updatedAt?: DateTimeFilter<"TestResult"> | Date | string
    sample?: XOR<SampleScalarRelationFilter, SampleWhereInput>
    testParamater?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }, "id">

  export type TestResultOrderByWithAggregationInput = {
    id?: SortOrder
    sampleId?: SortOrder
    testParameterId?: SortOrder
    value?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    uplandInterpretation?: SortOrderInput | SortOrder
    wetlandInterpretation?: SortOrderInput | SortOrder
    analysisType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TestResultCountOrderByAggregateInput
    _avg?: TestResultAvgOrderByAggregateInput
    _max?: TestResultMaxOrderByAggregateInput
    _min?: TestResultMinOrderByAggregateInput
    _sum?: TestResultSumOrderByAggregateInput
  }

  export type TestResultScalarWhereWithAggregatesInput = {
    AND?: TestResultScalarWhereWithAggregatesInput | TestResultScalarWhereWithAggregatesInput[]
    OR?: TestResultScalarWhereWithAggregatesInput[]
    NOT?: TestResultScalarWhereWithAggregatesInput | TestResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TestResult"> | string
    sampleId?: StringWithAggregatesFilter<"TestResult"> | string
    testParameterId?: StringWithAggregatesFilter<"TestResult"> | string
    value?: FloatNullableWithAggregatesFilter<"TestResult"> | number | null
    interpretation?: StringNullableWithAggregatesFilter<"TestResult"> | string | null
    uplandInterpretation?: StringNullableWithAggregatesFilter<"TestResult"> | string | null
    wetlandInterpretation?: StringNullableWithAggregatesFilter<"TestResult"> | string | null
    analysisType?: EnumAnalysisTypeNullableWithAggregatesFilter<"TestResult"> | $Enums.AnalysisType | null
    createdAt?: DateTimeWithAggregatesFilter<"TestResult"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TestResult"> | Date | string
  }

  export type ComparisonRuleWhereInput = {
    AND?: ComparisonRuleWhereInput | ComparisonRuleWhereInput[]
    OR?: ComparisonRuleWhereInput[]
    NOT?: ComparisonRuleWhereInput | ComparisonRuleWhereInput[]
    id?: StringFilter<"ComparisonRule"> | string
    testParameterId?: StringFilter<"ComparisonRule"> | string
    soilCategory?: EnumSoilCategoryNullableFilter<"ComparisonRule"> | $Enums.SoilCategory | null
    min?: FloatNullableFilter<"ComparisonRule"> | number | null
    max?: FloatNullableFilter<"ComparisonRule"> | number | null
    interpretation?: StringNullableFilter<"ComparisonRule"> | string | null
    type?: EnumComparisonTypeFilter<"ComparisonRule"> | $Enums.ComparisonType
    createdAt?: DateTimeFilter<"ComparisonRule"> | Date | string
    updatedAt?: DateTimeFilter<"ComparisonRule"> | Date | string
    testParameter?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }

  export type ComparisonRuleOrderByWithRelationInput = {
    id?: SortOrder
    testParameterId?: SortOrder
    soilCategory?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    max?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testParameter?: TestParameterOrderByWithRelationInput
  }

  export type ComparisonRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComparisonRuleWhereInput | ComparisonRuleWhereInput[]
    OR?: ComparisonRuleWhereInput[]
    NOT?: ComparisonRuleWhereInput | ComparisonRuleWhereInput[]
    testParameterId?: StringFilter<"ComparisonRule"> | string
    soilCategory?: EnumSoilCategoryNullableFilter<"ComparisonRule"> | $Enums.SoilCategory | null
    min?: FloatNullableFilter<"ComparisonRule"> | number | null
    max?: FloatNullableFilter<"ComparisonRule"> | number | null
    interpretation?: StringNullableFilter<"ComparisonRule"> | string | null
    type?: EnumComparisonTypeFilter<"ComparisonRule"> | $Enums.ComparisonType
    createdAt?: DateTimeFilter<"ComparisonRule"> | Date | string
    updatedAt?: DateTimeFilter<"ComparisonRule"> | Date | string
    testParameter?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }, "id">

  export type ComparisonRuleOrderByWithAggregationInput = {
    id?: SortOrder
    testParameterId?: SortOrder
    soilCategory?: SortOrderInput | SortOrder
    min?: SortOrderInput | SortOrder
    max?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComparisonRuleCountOrderByAggregateInput
    _avg?: ComparisonRuleAvgOrderByAggregateInput
    _max?: ComparisonRuleMaxOrderByAggregateInput
    _min?: ComparisonRuleMinOrderByAggregateInput
    _sum?: ComparisonRuleSumOrderByAggregateInput
  }

  export type ComparisonRuleScalarWhereWithAggregatesInput = {
    AND?: ComparisonRuleScalarWhereWithAggregatesInput | ComparisonRuleScalarWhereWithAggregatesInput[]
    OR?: ComparisonRuleScalarWhereWithAggregatesInput[]
    NOT?: ComparisonRuleScalarWhereWithAggregatesInput | ComparisonRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComparisonRule"> | string
    testParameterId?: StringWithAggregatesFilter<"ComparisonRule"> | string
    soilCategory?: EnumSoilCategoryNullableWithAggregatesFilter<"ComparisonRule"> | $Enums.SoilCategory | null
    min?: FloatNullableWithAggregatesFilter<"ComparisonRule"> | number | null
    max?: FloatNullableWithAggregatesFilter<"ComparisonRule"> | number | null
    interpretation?: StringNullableWithAggregatesFilter<"ComparisonRule"> | string | null
    type?: EnumComparisonTypeWithAggregatesFilter<"ComparisonRule"> | $Enums.ComparisonType
    createdAt?: DateTimeWithAggregatesFilter<"ComparisonRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComparisonRule"> | Date | string
  }

  export type PricingWhereInput = {
    AND?: PricingWhereInput | PricingWhereInput[]
    OR?: PricingWhereInput[]
    NOT?: PricingWhereInput | PricingWhereInput[]
    id?: StringFilter<"Pricing"> | string
    clientType?: EnumClientTypeFilter<"Pricing"> | $Enums.ClientType
    testParamterId?: StringFilter<"Pricing"> | string
    price?: FloatFilter<"Pricing"> | number
    createdAt?: DateTimeFilter<"Pricing"> | Date | string
    updatedAt?: DateTimeFilter<"Pricing"> | Date | string
    testParamater?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }

  export type PricingOrderByWithRelationInput = {
    id?: SortOrder
    clientType?: SortOrder
    testParamterId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    testParamater?: TestParameterOrderByWithRelationInput
  }

  export type PricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientType_testParamterId?: PricingClientTypeTestParamterIdCompoundUniqueInput
    AND?: PricingWhereInput | PricingWhereInput[]
    OR?: PricingWhereInput[]
    NOT?: PricingWhereInput | PricingWhereInput[]
    clientType?: EnumClientTypeFilter<"Pricing"> | $Enums.ClientType
    testParamterId?: StringFilter<"Pricing"> | string
    price?: FloatFilter<"Pricing"> | number
    createdAt?: DateTimeFilter<"Pricing"> | Date | string
    updatedAt?: DateTimeFilter<"Pricing"> | Date | string
    testParamater?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }, "id" | "clientType_testParamterId">

  export type PricingOrderByWithAggregationInput = {
    id?: SortOrder
    clientType?: SortOrder
    testParamterId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PricingCountOrderByAggregateInput
    _avg?: PricingAvgOrderByAggregateInput
    _max?: PricingMaxOrderByAggregateInput
    _min?: PricingMinOrderByAggregateInput
    _sum?: PricingSumOrderByAggregateInput
  }

  export type PricingScalarWhereWithAggregatesInput = {
    AND?: PricingScalarWhereWithAggregatesInput | PricingScalarWhereWithAggregatesInput[]
    OR?: PricingScalarWhereWithAggregatesInput[]
    NOT?: PricingScalarWhereWithAggregatesInput | PricingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pricing"> | string
    clientType?: EnumClientTypeWithAggregatesFilter<"Pricing"> | $Enums.ClientType
    testParamterId?: StringWithAggregatesFilter<"Pricing"> | string
    price?: FloatWithAggregatesFilter<"Pricing"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Pricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pricing"> | Date | string
  }

  export type InstituteWhereInput = {
    AND?: InstituteWhereInput | InstituteWhereInput[]
    OR?: InstituteWhereInput[]
    NOT?: InstituteWhereInput | InstituteWhereInput[]
    id?: StringFilter<"Institute"> | string
    prapok?: StringFilter<"Institute"> | string
    name?: StringFilter<"Institute"> | string
    address?: StringFilter<"Institute"> | string
    issuedby?: StringFilter<"Institute"> | string
    phone?: StringNullableFilter<"Institute"> | string | null
    updatedAt?: DateTimeFilter<"Institute"> | Date | string
  }

  export type InstituteOrderByWithRelationInput = {
    id?: SortOrder
    prapok?: SortOrder
    name?: SortOrder
    address?: SortOrder
    issuedby?: SortOrder
    phone?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
  }

  export type InstituteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstituteWhereInput | InstituteWhereInput[]
    OR?: InstituteWhereInput[]
    NOT?: InstituteWhereInput | InstituteWhereInput[]
    prapok?: StringFilter<"Institute"> | string
    name?: StringFilter<"Institute"> | string
    address?: StringFilter<"Institute"> | string
    issuedby?: StringFilter<"Institute"> | string
    phone?: StringNullableFilter<"Institute"> | string | null
    updatedAt?: DateTimeFilter<"Institute"> | Date | string
  }, "id">

  export type InstituteOrderByWithAggregationInput = {
    id?: SortOrder
    prapok?: SortOrder
    name?: SortOrder
    address?: SortOrder
    issuedby?: SortOrder
    phone?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    _count?: InstituteCountOrderByAggregateInput
    _max?: InstituteMaxOrderByAggregateInput
    _min?: InstituteMinOrderByAggregateInput
  }

  export type InstituteScalarWhereWithAggregatesInput = {
    AND?: InstituteScalarWhereWithAggregatesInput | InstituteScalarWhereWithAggregatesInput[]
    OR?: InstituteScalarWhereWithAggregatesInput[]
    NOT?: InstituteScalarWhereWithAggregatesInput | InstituteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Institute"> | string
    prapok?: StringWithAggregatesFilter<"Institute"> | string
    name?: StringWithAggregatesFilter<"Institute"> | string
    address?: StringWithAggregatesFilter<"Institute"> | string
    issuedby?: StringWithAggregatesFilter<"Institute"> | string
    phone?: StringNullableWithAggregatesFilter<"Institute"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Institute"> | Date | string
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    sarokNumber?: StringNullableFilter<"Order"> | string | null
    orderDate?: DateTimeFilter<"Order"> | Date | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    operatorId?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    invoiceId?: StringNullableFilter<"Order"> | string | null
    reportId?: StringNullableFilter<"Order"> | string | null
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    operator?: XOR<UserScalarRelationFilter, UserWhereInput>
    samples?: SampleListRelationFilter
    orderItems?: OrderItemListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    sarokNumber?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    operatorId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    client?: ClientOrderByWithRelationInput
    operator?: UserOrderByWithRelationInput
    samples?: SampleOrderByRelationAggregateInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    invoice?: InvoiceOrderByWithRelationInput
    report?: ReportOrderByWithRelationInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sarokNumber?: string
    invoiceId?: string
    reportId?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    clientId?: StringFilter<"Order"> | string
    orderDate?: DateTimeFilter<"Order"> | Date | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    operatorId?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    operator?: XOR<UserScalarRelationFilter, UserWhereInput>
    samples?: SampleListRelationFilter
    orderItems?: OrderItemListRelationFilter
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }, "id" | "sarokNumber" | "invoiceId" | "reportId">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    sarokNumber?: SortOrderInput | SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    operatorId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    reportId?: SortOrderInput | SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    clientId?: StringWithAggregatesFilter<"Order"> | string
    sarokNumber?: StringNullableWithAggregatesFilter<"Order"> | string | null
    orderDate?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    status?: EnumOrderStatusWithAggregatesFilter<"Order"> | $Enums.OrderStatus
    operatorId?: StringWithAggregatesFilter<"Order"> | string
    totalAmount?: FloatWithAggregatesFilter<"Order"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    invoiceId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    reportId?: StringNullableWithAggregatesFilter<"Order"> | string | null
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    agroTestId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    agroTest?: XOR<AgrotestScalarRelationFilter, AgrotestWhereInput>
    orderTestParameters?: OrderTestParameterListRelationFilter
    sample?: SampleListRelationFilter
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    agroTestId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    agroTest?: AgrotestOrderByWithRelationInput
    orderTestParameters?: OrderTestParameterOrderByRelationAggregateInput
    sample?: SampleOrderByRelationAggregateInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: StringFilter<"OrderItem"> | string
    agroTestId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    agroTest?: XOR<AgrotestScalarRelationFilter, AgrotestWhereInput>
    orderTestParameters?: OrderTestParameterListRelationFilter
    sample?: SampleListRelationFilter
  }, "id">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    agroTestId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderItem"> | string
    orderId?: StringWithAggregatesFilter<"OrderItem"> | string
    agroTestId?: StringWithAggregatesFilter<"OrderItem"> | string
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    unitPrice?: FloatWithAggregatesFilter<"OrderItem"> | number
    subtotal?: FloatWithAggregatesFilter<"OrderItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderItem"> | Date | string
  }

  export type OrderTestParameterWhereInput = {
    AND?: OrderTestParameterWhereInput | OrderTestParameterWhereInput[]
    OR?: OrderTestParameterWhereInput[]
    NOT?: OrderTestParameterWhereInput | OrderTestParameterWhereInput[]
    id?: StringFilter<"OrderTestParameter"> | string
    orderItemId?: StringFilter<"OrderTestParameter"> | string
    testParameterId?: StringFilter<"OrderTestParameter"> | string
    createdAt?: DateTimeFilter<"OrderTestParameter"> | Date | string
    updatedAt?: DateTimeFilter<"OrderTestParameter"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    testParameter?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }

  export type OrderTestParameterOrderByWithRelationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    testParameterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orderItem?: OrderItemOrderByWithRelationInput
    testParameter?: TestParameterOrderByWithRelationInput
  }

  export type OrderTestParameterWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderItemId_testParameterId?: OrderTestParameterOrderItemIdTestParameterIdCompoundUniqueInput
    AND?: OrderTestParameterWhereInput | OrderTestParameterWhereInput[]
    OR?: OrderTestParameterWhereInput[]
    NOT?: OrderTestParameterWhereInput | OrderTestParameterWhereInput[]
    orderItemId?: StringFilter<"OrderTestParameter"> | string
    testParameterId?: StringFilter<"OrderTestParameter"> | string
    createdAt?: DateTimeFilter<"OrderTestParameter"> | Date | string
    updatedAt?: DateTimeFilter<"OrderTestParameter"> | Date | string
    orderItem?: XOR<OrderItemScalarRelationFilter, OrderItemWhereInput>
    testParameter?: XOR<TestParameterScalarRelationFilter, TestParameterWhereInput>
  }, "id" | "orderItemId_testParameterId">

  export type OrderTestParameterOrderByWithAggregationInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    testParameterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderTestParameterCountOrderByAggregateInput
    _max?: OrderTestParameterMaxOrderByAggregateInput
    _min?: OrderTestParameterMinOrderByAggregateInput
  }

  export type OrderTestParameterScalarWhereWithAggregatesInput = {
    AND?: OrderTestParameterScalarWhereWithAggregatesInput | OrderTestParameterScalarWhereWithAggregatesInput[]
    OR?: OrderTestParameterScalarWhereWithAggregatesInput[]
    NOT?: OrderTestParameterScalarWhereWithAggregatesInput | OrderTestParameterScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderTestParameter"> | string
    orderItemId?: StringWithAggregatesFilter<"OrderTestParameter"> | string
    testParameterId?: StringWithAggregatesFilter<"OrderTestParameter"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OrderTestParameter"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderTestParameter"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    orderId?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    totalAmount?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    reportId?: StringNullableFilter<"Invoice"> | string | null
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    report?: ReportOrderByWithRelationInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    reportId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    clientId?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    totalAmount?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    report?: XOR<ReportNullableScalarRelationFilter, ReportWhereInput> | null
  }, "id" | "orderId" | "reportId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrderInput | SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    orderId?: StringWithAggregatesFilter<"Invoice"> | string
    clientId?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    totalAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    paidAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    reportId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    orderId?: StringFilter<"Report"> | string
    clientId?: StringFilter<"Report"> | string
    invoiceId?: StringNullableFilter<"Report"> | string | null
    reportType?: StringFilter<"Report"> | string
    reportNumber?: StringFilter<"Report"> | string
    issueDate?: DateTimeFilter<"Report"> | Date | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    recommendations?: StringNullableFilter<"Report"> | string | null
    notes?: StringNullableFilter<"Report"> | string | null
    generatedByUserId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    generator?: XOR<UserScalarRelationFilter, UserWhereInput>
    samples?: SampleListRelationFilter
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    reportType?: SortOrder
    reportNumber?: SortOrder
    issueDate?: SortOrder
    status?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    generatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    order?: OrderOrderByWithRelationInput
    client?: ClientOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
    generator?: UserOrderByWithRelationInput
    samples?: SampleOrderByRelationAggregateInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    orderId?: string
    invoiceId?: string
    reportNumber?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    clientId?: StringFilter<"Report"> | string
    reportType?: StringFilter<"Report"> | string
    issueDate?: DateTimeFilter<"Report"> | Date | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    recommendations?: StringNullableFilter<"Report"> | string | null
    notes?: StringNullableFilter<"Report"> | string | null
    generatedByUserId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
    client?: XOR<ClientScalarRelationFilter, ClientWhereInput>
    invoice?: XOR<InvoiceNullableScalarRelationFilter, InvoiceWhereInput> | null
    generator?: XOR<UserScalarRelationFilter, UserWhereInput>
    samples?: SampleListRelationFilter
  }, "id" | "orderId" | "invoiceId" | "reportNumber">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceId?: SortOrderInput | SortOrder
    reportType?: SortOrder
    reportNumber?: SortOrder
    issueDate?: SortOrder
    status?: SortOrder
    recommendations?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    generatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    orderId?: StringWithAggregatesFilter<"Report"> | string
    clientId?: StringWithAggregatesFilter<"Report"> | string
    invoiceId?: StringNullableWithAggregatesFilter<"Report"> | string | null
    reportType?: StringWithAggregatesFilter<"Report"> | string
    reportNumber?: StringWithAggregatesFilter<"Report"> | string
    issueDate?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    status?: EnumReportStatusWithAggregatesFilter<"Report"> | $Enums.ReportStatus
    recommendations?: StringNullableWithAggregatesFilter<"Report"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Report"> | string | null
    generatedByUserId?: StringWithAggregatesFilter<"Report"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOperatorInput
    reports?: ReportCreateNestedManyWithoutGeneratorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOperatorInput
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOperatorNestedInput
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOperatorNestedInput
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgrotestCreateInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
    testParameter?: TestParameterCreateNestedManyWithoutAgroTestInput
    orderItems?: OrderItemCreateNestedManyWithoutAgroTestInput
  }

  export type AgrotestUncheckedCreateInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
    testParameter?: TestParameterUncheckedCreateNestedManyWithoutAgroTestInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutAgroTestInput
  }

  export type AgrotestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParameter?: TestParameterUpdateManyWithoutAgroTestNestedInput
    orderItems?: OrderItemUpdateManyWithoutAgroTestNestedInput
  }

  export type AgrotestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParameter?: TestParameterUncheckedUpdateManyWithoutAgroTestNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutAgroTestNestedInput
  }

  export type AgrotestCreateManyInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgrotestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgrotestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestParameterCreateInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agroTest: AgrotestCreateNestedOneWithoutTestParameterInput
    pricing?: PricingCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterUncheckedCreateInput = {
    id?: string
    agroTestID: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: PricingUncheckedCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleUncheckedCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultUncheckedCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agroTest?: AgrotestUpdateOneRequiredWithoutTestParameterNestedInput
    pricing?: PricingUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: PricingUncheckedUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUncheckedUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUncheckedUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterCreateManyInput = {
    id?: string
    agroTestID: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleCreateInput = {
    id?: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutSamplesInput
    orderItem: OrderItemCreateNestedOneWithoutSampleInput
    testResults?: TestResultCreateNestedManyWithoutSampleInput
    report?: ReportCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateInput = {
    id?: string
    orderId: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    testResults?: TestResultUncheckedCreateNestedManyWithoutSampleInput
  }

  export type SampleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutSamplesNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutSampleNestedInput
    testResults?: TestResultUpdateManyWithoutSampleNestedInput
    report?: ReportUpdateOneWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    testResults?: TestResultUncheckedUpdateManyWithoutSampleNestedInput
  }

  export type SampleCreateManyInput = {
    id?: string
    orderId: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type SampleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestResultCreateInput = {
    id?: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sample: SampleCreateNestedOneWithoutTestResultsInput
    testParamater: TestParameterCreateNestedOneWithoutTestResultsInput
  }

  export type TestResultUncheckedCreateInput = {
    id?: string
    sampleId: string
    testParameterId: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sample?: SampleUpdateOneRequiredWithoutTestResultsNestedInput
    testParamater?: TestParameterUpdateOneRequiredWithoutTestResultsNestedInput
  }

  export type TestResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleId?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultCreateManyInput = {
    id?: string
    sampleId: string
    testParameterId: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleId?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparisonRuleCreateInput = {
    id?: string
    soilCategory?: $Enums.SoilCategory | null
    min?: number | null
    max?: number | null
    interpretation?: string | null
    type?: $Enums.ComparisonType
    createdAt?: Date | string
    updatedAt?: Date | string
    testParameter: TestParameterCreateNestedOneWithoutComparisonRulesInput
  }

  export type ComparisonRuleUncheckedCreateInput = {
    id?: string
    testParameterId: string
    soilCategory?: $Enums.SoilCategory | null
    min?: number | null
    max?: number | null
    interpretation?: string | null
    type?: $Enums.ComparisonType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparisonRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParameter?: TestParameterUpdateOneRequiredWithoutComparisonRulesNestedInput
  }

  export type ComparisonRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparisonRuleCreateManyInput = {
    id?: string
    testParameterId: string
    soilCategory?: $Enums.SoilCategory | null
    min?: number | null
    max?: number | null
    interpretation?: string | null
    type?: $Enums.ComparisonType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparisonRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparisonRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCreateInput = {
    id?: string
    clientType: $Enums.ClientType
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
    testParamater: TestParameterCreateNestedOneWithoutPricingInput
  }

  export type PricingUncheckedCreateInput = {
    id?: string
    clientType: $Enums.ClientType
    testParamterId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParamater?: TestParameterUpdateOneRequiredWithoutPricingNestedInput
  }

  export type PricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    testParamterId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCreateManyInput = {
    id?: string
    clientType: $Enums.ClientType
    testParamterId: string
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    testParamterId?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstituteCreateInput = {
    id?: string
    prapok: string
    name: string
    address: string
    issuedby: string
    phone?: string | null
    updatedAt?: Date | string
  }

  export type InstituteUncheckedCreateInput = {
    id?: string
    prapok: string
    name: string
    address: string
    issuedby: string
    phone?: string | null
    updatedAt?: Date | string
  }

  export type InstituteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prapok?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    issuedby?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstituteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    prapok?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    issuedby?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstituteCreateManyInput = {
    id?: string
    prapok: string
    name: string
    address: string
    issuedby: string
    phone?: string | null
    updatedAt?: Date | string
  }

  export type InstituteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    prapok?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    issuedby?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstituteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    prapok?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    issuedby?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    operator: UserCreateNestedOneWithoutOrdersInput
    samples?: SampleCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    report?: ReportCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    samples?: SampleUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    report?: ReportUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    operator?: UserUpdateOneRequiredWithoutOrdersNestedInput
    samples?: SampleUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    report?: ReportUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    samples?: SampleUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    report?: ReportUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateInput = {
    id?: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
    agroTest: AgrotestCreateNestedOneWithoutOrderItemsInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutOrderItemInput
    sample?: SampleCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: string
    orderId: string
    agroTestId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutOrderItemInput
    sample?: SampleUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    agroTest?: AgrotestUpdateOneRequiredWithoutOrderItemsNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutOrderItemNestedInput
    sample?: SampleUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agroTestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutOrderItemNestedInput
    sample?: SampleUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemCreateManyInput = {
    id?: string
    orderId: string
    agroTestId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agroTestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutOrderTestParametersInput
    testParameter: TestParameterCreateNestedOneWithoutOrderTestParametersInput
  }

  export type OrderTestParameterUncheckedCreateInput = {
    id?: string
    orderItemId: string
    testParameterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderTestParameterUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutOrderTestParametersNestedInput
    testParameter?: TestParameterUpdateOneRequiredWithoutOrderTestParametersNestedInput
  }

  export type OrderTestParameterUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterCreateManyInput = {
    id?: string
    orderItemId: string
    testParameterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderTestParameterUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    order: OrderCreateNestedOneWithoutInvoiceInput
    client: ClientCreateNestedOneWithoutInvoicesInput
    report?: ReportCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    report?: ReportUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    report?: ReportUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ReportUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportCreateInput = {
    id?: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReportInput
    client: ClientCreateNestedOneWithoutReportsInput
    invoice?: InvoiceCreateNestedOneWithoutReportInput
    generator: UserCreateNestedOneWithoutReportsInput
    samples?: SampleCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: SampleUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReportNestedInput
    client?: ClientUpdateOneRequiredWithoutReportsNestedInput
    invoice?: InvoiceUpdateOneWithoutReportNestedInput
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
    samples?: SampleUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: SampleUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    clientType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    clientType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    clientType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type EnumSampleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeFilter<$PrismaModel> | $Enums.SampleType
  }

  export type TestParameterListRelationFilter = {
    every?: TestParameterWhereInput
    some?: TestParameterWhereInput
    none?: TestParameterWhereInput
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type TestParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgrotestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sampleType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgrotestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sampleType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgrotestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    sampleType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSampleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SampleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleTypeFilter<$PrismaModel>
    _max?: NestedEnumSampleTypeFilter<$PrismaModel>
  }

  export type EnumAnalysisTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAnalysisTypeNullableFilter<$PrismaModel> | $Enums.AnalysisType | null
  }

  export type AgrotestScalarRelationFilter = {
    is?: AgrotestWhereInput
    isNot?: AgrotestWhereInput
  }

  export type PricingListRelationFilter = {
    every?: PricingWhereInput
    some?: PricingWhereInput
    none?: PricingWhereInput
  }

  export type ComparisonRuleListRelationFilter = {
    every?: ComparisonRuleWhereInput
    some?: ComparisonRuleWhereInput
    none?: ComparisonRuleWhereInput
  }

  export type TestResultListRelationFilter = {
    every?: TestResultWhereInput
    some?: TestResultWhereInput
    none?: TestResultWhereInput
  }

  export type OrderTestParameterListRelationFilter = {
    every?: OrderTestParameterWhereInput
    some?: OrderTestParameterWhereInput
    none?: OrderTestParameterWhereInput
  }

  export type PricingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComparisonRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderTestParameterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TestParameterCountOrderByAggregateInput = {
    id?: SortOrder
    agroTestID?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    agroTestID?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestParameterMinOrderByAggregateInput = {
    id?: SortOrder
    agroTestID?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAnalysisTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAnalysisTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSampleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleStatus | EnumSampleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleStatusFilter<$PrismaModel> | $Enums.SampleStatus
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type OrderItemScalarRelationFilter = {
    is?: OrderItemWhereInput
    isNot?: OrderItemWhereInput
  }

  export type ReportNullableScalarRelationFilter = {
    is?: ReportWhereInput | null
    isNot?: ReportWhereInput | null
  }

  export type SampleCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    sampleIdNumber?: SortOrder
    collectionDate?: SortOrder
    sampleType?: SortOrder
    collectionLocation?: SortOrder
    cropType?: SortOrder
    bunot?: SortOrder
    manchitroUnit?: SortOrder
    vumiSrini?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrder
  }

  export type SampleAvgOrderByAggregateInput = {
    manchitroUnit?: SortOrder
  }

  export type SampleMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    sampleIdNumber?: SortOrder
    collectionDate?: SortOrder
    sampleType?: SortOrder
    collectionLocation?: SortOrder
    cropType?: SortOrder
    bunot?: SortOrder
    manchitroUnit?: SortOrder
    vumiSrini?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrder
  }

  export type SampleMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    orderItemId?: SortOrder
    sampleIdNumber?: SortOrder
    collectionDate?: SortOrder
    sampleType?: SortOrder
    collectionLocation?: SortOrder
    cropType?: SortOrder
    bunot?: SortOrder
    manchitroUnit?: SortOrder
    vumiSrini?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrder
  }

  export type SampleSumOrderByAggregateInput = {
    manchitroUnit?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSampleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleStatus | EnumSampleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SampleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleStatusFilter<$PrismaModel>
    _max?: NestedEnumSampleStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type SampleScalarRelationFilter = {
    is?: SampleWhereInput
    isNot?: SampleWhereInput
  }

  export type TestParameterScalarRelationFilter = {
    is?: TestParameterWhereInput
    isNot?: TestParameterWhereInput
  }

  export type TestResultCountOrderByAggregateInput = {
    id?: SortOrder
    sampleId?: SortOrder
    testParameterId?: SortOrder
    value?: SortOrder
    interpretation?: SortOrder
    uplandInterpretation?: SortOrder
    wetlandInterpretation?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestResultAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TestResultMaxOrderByAggregateInput = {
    id?: SortOrder
    sampleId?: SortOrder
    testParameterId?: SortOrder
    value?: SortOrder
    interpretation?: SortOrder
    uplandInterpretation?: SortOrder
    wetlandInterpretation?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestResultMinOrderByAggregateInput = {
    id?: SortOrder
    sampleId?: SortOrder
    testParameterId?: SortOrder
    value?: SortOrder
    interpretation?: SortOrder
    uplandInterpretation?: SortOrder
    wetlandInterpretation?: SortOrder
    analysisType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TestResultSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumSoilCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SoilCategory | EnumSoilCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSoilCategoryNullableFilter<$PrismaModel> | $Enums.SoilCategory | null
  }

  export type EnumComparisonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonType | EnumComparisonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonTypeFilter<$PrismaModel> | $Enums.ComparisonType
  }

  export type ComparisonRuleCountOrderByAggregateInput = {
    id?: SortOrder
    testParameterId?: SortOrder
    soilCategory?: SortOrder
    min?: SortOrder
    max?: SortOrder
    interpretation?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComparisonRuleAvgOrderByAggregateInput = {
    min?: SortOrder
    max?: SortOrder
  }

  export type ComparisonRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    testParameterId?: SortOrder
    soilCategory?: SortOrder
    min?: SortOrder
    max?: SortOrder
    interpretation?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComparisonRuleMinOrderByAggregateInput = {
    id?: SortOrder
    testParameterId?: SortOrder
    soilCategory?: SortOrder
    min?: SortOrder
    max?: SortOrder
    interpretation?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComparisonRuleSumOrderByAggregateInput = {
    min?: SortOrder
    max?: SortOrder
  }

  export type EnumSoilCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SoilCategory | EnumSoilCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSoilCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.SoilCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSoilCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumSoilCategoryNullableFilter<$PrismaModel>
  }

  export type EnumComparisonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonType | EnumComparisonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonTypeWithAggregatesFilter<$PrismaModel> | $Enums.ComparisonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComparisonTypeFilter<$PrismaModel>
    _max?: NestedEnumComparisonTypeFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PricingClientTypeTestParamterIdCompoundUniqueInput = {
    clientType: $Enums.ClientType
    testParamterId: string
  }

  export type PricingCountOrderByAggregateInput = {
    id?: SortOrder
    clientType?: SortOrder
    testParamterId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PricingMaxOrderByAggregateInput = {
    id?: SortOrder
    clientType?: SortOrder
    testParamterId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingMinOrderByAggregateInput = {
    id?: SortOrder
    clientType?: SortOrder
    testParamterId?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PricingSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InstituteCountOrderByAggregateInput = {
    id?: SortOrder
    prapok?: SortOrder
    name?: SortOrder
    address?: SortOrder
    issuedby?: SortOrder
    phone?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstituteMaxOrderByAggregateInput = {
    id?: SortOrder
    prapok?: SortOrder
    name?: SortOrder
    address?: SortOrder
    issuedby?: SortOrder
    phone?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstituteMinOrderByAggregateInput = {
    id?: SortOrder
    prapok?: SortOrder
    name?: SortOrder
    address?: SortOrder
    issuedby?: SortOrder
    phone?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type ClientScalarRelationFilter = {
    is?: ClientWhereInput
    isNot?: ClientWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SampleListRelationFilter = {
    every?: SampleWhereInput
    some?: SampleWhereInput
    none?: SampleWhereInput
  }

  export type InvoiceNullableScalarRelationFilter = {
    is?: InvoiceWhereInput | null
    isNot?: InvoiceWhereInput | null
  }

  export type SampleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    sarokNumber?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    operatorId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
    reportId?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    sarokNumber?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    operatorId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
    reportId?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    sarokNumber?: SortOrder
    orderDate?: SortOrder
    status?: SortOrder
    operatorId?: SortOrder
    totalAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoiceId?: SortOrder
    reportId?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    totalAmount?: SortOrder
  }

  export type EnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agroTestId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agroTestId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    agroTestId?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    subtotal?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type OrderTestParameterOrderItemIdTestParameterIdCompoundUniqueInput = {
    orderItemId: string
    testParameterId: string
  }

  export type OrderTestParameterCountOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    testParameterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderTestParameterMaxOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    testParameterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderTestParameterMinOrderByAggregateInput = {
    id?: SortOrder
    orderItemId?: SortOrder
    testParameterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceDate?: SortOrder
    dueDate?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reportId?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    totalAmount?: SortOrder
    paidAmount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type EnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceId?: SortOrder
    reportType?: SortOrder
    reportNumber?: SortOrder
    issueDate?: SortOrder
    status?: SortOrder
    recommendations?: SortOrder
    notes?: SortOrder
    generatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceId?: SortOrder
    reportType?: SortOrder
    reportNumber?: SortOrder
    issueDate?: SortOrder
    status?: SortOrder
    recommendations?: SortOrder
    notes?: SortOrder
    generatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    invoiceId?: SortOrder
    reportType?: SortOrder
    reportNumber?: SortOrder
    issueDate?: SortOrder
    status?: SortOrder
    recommendations?: SortOrder
    notes?: SortOrder
    generatedByUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type OrderCreateNestedManyWithoutOperatorInput = {
    create?: XOR<OrderCreateWithoutOperatorInput, OrderUncheckedCreateWithoutOperatorInput> | OrderCreateWithoutOperatorInput[] | OrderUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOperatorInput | OrderCreateOrConnectWithoutOperatorInput[]
    createMany?: OrderCreateManyOperatorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOperatorInput = {
    create?: XOR<OrderCreateWithoutOperatorInput, OrderUncheckedCreateWithoutOperatorInput> | OrderCreateWithoutOperatorInput[] | OrderUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOperatorInput | OrderCreateOrConnectWithoutOperatorInput[]
    createMany?: OrderCreateManyOperatorInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutGeneratorInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type OrderUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<OrderCreateWithoutOperatorInput, OrderUncheckedCreateWithoutOperatorInput> | OrderCreateWithoutOperatorInput[] | OrderUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOperatorInput | OrderCreateOrConnectWithoutOperatorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOperatorInput | OrderUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: OrderCreateManyOperatorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOperatorInput | OrderUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOperatorInput | OrderUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGeneratorInput | ReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGeneratorInput | ReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGeneratorInput | ReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOperatorNestedInput = {
    create?: XOR<OrderCreateWithoutOperatorInput, OrderUncheckedCreateWithoutOperatorInput> | OrderCreateWithoutOperatorInput[] | OrderUncheckedCreateWithoutOperatorInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOperatorInput | OrderCreateOrConnectWithoutOperatorInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOperatorInput | OrderUpsertWithWhereUniqueWithoutOperatorInput[]
    createMany?: OrderCreateManyOperatorInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOperatorInput | OrderUpdateWithWhereUniqueWithoutOperatorInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOperatorInput | OrderUpdateManyWithWhereWithoutOperatorInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutGeneratorNestedInput = {
    create?: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput> | ReportCreateWithoutGeneratorInput[] | ReportUncheckedCreateWithoutGeneratorInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutGeneratorInput | ReportCreateOrConnectWithoutGeneratorInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutGeneratorInput | ReportUpsertWithWhereUniqueWithoutGeneratorInput[]
    createMany?: ReportCreateManyGeneratorInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutGeneratorInput | ReportUpdateWithWhereUniqueWithoutGeneratorInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutGeneratorInput | ReportUpdateManyWithWhereWithoutGeneratorInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type OrderCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutClientInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumClientTypeFieldUpdateOperationsInput = {
    set?: $Enums.ClientType
  }

  export type OrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutClientInput | ReportUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutClientInput | ReportUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutClientInput | ReportUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput> | OrderCreateWithoutClientInput[] | OrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutClientInput | OrderCreateOrConnectWithoutClientInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutClientInput | OrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: OrderCreateManyClientInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutClientInput | OrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutClientInput | OrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutClientInput | ReportUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutClientInput | ReportUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutClientInput | ReportUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TestParameterCreateNestedManyWithoutAgroTestInput = {
    create?: XOR<TestParameterCreateWithoutAgroTestInput, TestParameterUncheckedCreateWithoutAgroTestInput> | TestParameterCreateWithoutAgroTestInput[] | TestParameterUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: TestParameterCreateOrConnectWithoutAgroTestInput | TestParameterCreateOrConnectWithoutAgroTestInput[]
    createMany?: TestParameterCreateManyAgroTestInputEnvelope
    connect?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutAgroTestInput = {
    create?: XOR<OrderItemCreateWithoutAgroTestInput, OrderItemUncheckedCreateWithoutAgroTestInput> | OrderItemCreateWithoutAgroTestInput[] | OrderItemUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutAgroTestInput | OrderItemCreateOrConnectWithoutAgroTestInput[]
    createMany?: OrderItemCreateManyAgroTestInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type TestParameterUncheckedCreateNestedManyWithoutAgroTestInput = {
    create?: XOR<TestParameterCreateWithoutAgroTestInput, TestParameterUncheckedCreateWithoutAgroTestInput> | TestParameterCreateWithoutAgroTestInput[] | TestParameterUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: TestParameterCreateOrConnectWithoutAgroTestInput | TestParameterCreateOrConnectWithoutAgroTestInput[]
    createMany?: TestParameterCreateManyAgroTestInputEnvelope
    connect?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutAgroTestInput = {
    create?: XOR<OrderItemCreateWithoutAgroTestInput, OrderItemUncheckedCreateWithoutAgroTestInput> | OrderItemCreateWithoutAgroTestInput[] | OrderItemUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutAgroTestInput | OrderItemCreateOrConnectWithoutAgroTestInput[]
    createMany?: OrderItemCreateManyAgroTestInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type EnumSampleTypeFieldUpdateOperationsInput = {
    set?: $Enums.SampleType
  }

  export type TestParameterUpdateManyWithoutAgroTestNestedInput = {
    create?: XOR<TestParameterCreateWithoutAgroTestInput, TestParameterUncheckedCreateWithoutAgroTestInput> | TestParameterCreateWithoutAgroTestInput[] | TestParameterUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: TestParameterCreateOrConnectWithoutAgroTestInput | TestParameterCreateOrConnectWithoutAgroTestInput[]
    upsert?: TestParameterUpsertWithWhereUniqueWithoutAgroTestInput | TestParameterUpsertWithWhereUniqueWithoutAgroTestInput[]
    createMany?: TestParameterCreateManyAgroTestInputEnvelope
    set?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    disconnect?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    delete?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    connect?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    update?: TestParameterUpdateWithWhereUniqueWithoutAgroTestInput | TestParameterUpdateWithWhereUniqueWithoutAgroTestInput[]
    updateMany?: TestParameterUpdateManyWithWhereWithoutAgroTestInput | TestParameterUpdateManyWithWhereWithoutAgroTestInput[]
    deleteMany?: TestParameterScalarWhereInput | TestParameterScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutAgroTestNestedInput = {
    create?: XOR<OrderItemCreateWithoutAgroTestInput, OrderItemUncheckedCreateWithoutAgroTestInput> | OrderItemCreateWithoutAgroTestInput[] | OrderItemUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutAgroTestInput | OrderItemCreateOrConnectWithoutAgroTestInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutAgroTestInput | OrderItemUpsertWithWhereUniqueWithoutAgroTestInput[]
    createMany?: OrderItemCreateManyAgroTestInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutAgroTestInput | OrderItemUpdateWithWhereUniqueWithoutAgroTestInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutAgroTestInput | OrderItemUpdateManyWithWhereWithoutAgroTestInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type TestParameterUncheckedUpdateManyWithoutAgroTestNestedInput = {
    create?: XOR<TestParameterCreateWithoutAgroTestInput, TestParameterUncheckedCreateWithoutAgroTestInput> | TestParameterCreateWithoutAgroTestInput[] | TestParameterUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: TestParameterCreateOrConnectWithoutAgroTestInput | TestParameterCreateOrConnectWithoutAgroTestInput[]
    upsert?: TestParameterUpsertWithWhereUniqueWithoutAgroTestInput | TestParameterUpsertWithWhereUniqueWithoutAgroTestInput[]
    createMany?: TestParameterCreateManyAgroTestInputEnvelope
    set?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    disconnect?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    delete?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    connect?: TestParameterWhereUniqueInput | TestParameterWhereUniqueInput[]
    update?: TestParameterUpdateWithWhereUniqueWithoutAgroTestInput | TestParameterUpdateWithWhereUniqueWithoutAgroTestInput[]
    updateMany?: TestParameterUpdateManyWithWhereWithoutAgroTestInput | TestParameterUpdateManyWithWhereWithoutAgroTestInput[]
    deleteMany?: TestParameterScalarWhereInput | TestParameterScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutAgroTestNestedInput = {
    create?: XOR<OrderItemCreateWithoutAgroTestInput, OrderItemUncheckedCreateWithoutAgroTestInput> | OrderItemCreateWithoutAgroTestInput[] | OrderItemUncheckedCreateWithoutAgroTestInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutAgroTestInput | OrderItemCreateOrConnectWithoutAgroTestInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutAgroTestInput | OrderItemUpsertWithWhereUniqueWithoutAgroTestInput[]
    createMany?: OrderItemCreateManyAgroTestInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutAgroTestInput | OrderItemUpdateWithWhereUniqueWithoutAgroTestInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutAgroTestInput | OrderItemUpdateManyWithWhereWithoutAgroTestInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type AgrotestCreateNestedOneWithoutTestParameterInput = {
    create?: XOR<AgrotestCreateWithoutTestParameterInput, AgrotestUncheckedCreateWithoutTestParameterInput>
    connectOrCreate?: AgrotestCreateOrConnectWithoutTestParameterInput
    connect?: AgrotestWhereUniqueInput
  }

  export type PricingCreateNestedManyWithoutTestParamaterInput = {
    create?: XOR<PricingCreateWithoutTestParamaterInput, PricingUncheckedCreateWithoutTestParamaterInput> | PricingCreateWithoutTestParamaterInput[] | PricingUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: PricingCreateOrConnectWithoutTestParamaterInput | PricingCreateOrConnectWithoutTestParamaterInput[]
    createMany?: PricingCreateManyTestParamaterInputEnvelope
    connect?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
  }

  export type ComparisonRuleCreateNestedManyWithoutTestParameterInput = {
    create?: XOR<ComparisonRuleCreateWithoutTestParameterInput, ComparisonRuleUncheckedCreateWithoutTestParameterInput> | ComparisonRuleCreateWithoutTestParameterInput[] | ComparisonRuleUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: ComparisonRuleCreateOrConnectWithoutTestParameterInput | ComparisonRuleCreateOrConnectWithoutTestParameterInput[]
    createMany?: ComparisonRuleCreateManyTestParameterInputEnvelope
    connect?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
  }

  export type TestResultCreateNestedManyWithoutTestParamaterInput = {
    create?: XOR<TestResultCreateWithoutTestParamaterInput, TestResultUncheckedCreateWithoutTestParamaterInput> | TestResultCreateWithoutTestParamaterInput[] | TestResultUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutTestParamaterInput | TestResultCreateOrConnectWithoutTestParamaterInput[]
    createMany?: TestResultCreateManyTestParamaterInputEnvelope
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
  }

  export type OrderTestParameterCreateNestedManyWithoutTestParameterInput = {
    create?: XOR<OrderTestParameterCreateWithoutTestParameterInput, OrderTestParameterUncheckedCreateWithoutTestParameterInput> | OrderTestParameterCreateWithoutTestParameterInput[] | OrderTestParameterUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutTestParameterInput | OrderTestParameterCreateOrConnectWithoutTestParameterInput[]
    createMany?: OrderTestParameterCreateManyTestParameterInputEnvelope
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
  }

  export type PricingUncheckedCreateNestedManyWithoutTestParamaterInput = {
    create?: XOR<PricingCreateWithoutTestParamaterInput, PricingUncheckedCreateWithoutTestParamaterInput> | PricingCreateWithoutTestParamaterInput[] | PricingUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: PricingCreateOrConnectWithoutTestParamaterInput | PricingCreateOrConnectWithoutTestParamaterInput[]
    createMany?: PricingCreateManyTestParamaterInputEnvelope
    connect?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
  }

  export type ComparisonRuleUncheckedCreateNestedManyWithoutTestParameterInput = {
    create?: XOR<ComparisonRuleCreateWithoutTestParameterInput, ComparisonRuleUncheckedCreateWithoutTestParameterInput> | ComparisonRuleCreateWithoutTestParameterInput[] | ComparisonRuleUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: ComparisonRuleCreateOrConnectWithoutTestParameterInput | ComparisonRuleCreateOrConnectWithoutTestParameterInput[]
    createMany?: ComparisonRuleCreateManyTestParameterInputEnvelope
    connect?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
  }

  export type TestResultUncheckedCreateNestedManyWithoutTestParamaterInput = {
    create?: XOR<TestResultCreateWithoutTestParamaterInput, TestResultUncheckedCreateWithoutTestParamaterInput> | TestResultCreateWithoutTestParamaterInput[] | TestResultUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutTestParamaterInput | TestResultCreateOrConnectWithoutTestParamaterInput[]
    createMany?: TestResultCreateManyTestParamaterInputEnvelope
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
  }

  export type OrderTestParameterUncheckedCreateNestedManyWithoutTestParameterInput = {
    create?: XOR<OrderTestParameterCreateWithoutTestParameterInput, OrderTestParameterUncheckedCreateWithoutTestParameterInput> | OrderTestParameterCreateWithoutTestParameterInput[] | OrderTestParameterUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutTestParameterInput | OrderTestParameterCreateOrConnectWithoutTestParameterInput[]
    createMany?: OrderTestParameterCreateManyTestParameterInputEnvelope
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
  }

  export type NullableEnumAnalysisTypeFieldUpdateOperationsInput = {
    set?: $Enums.AnalysisType | null
  }

  export type AgrotestUpdateOneRequiredWithoutTestParameterNestedInput = {
    create?: XOR<AgrotestCreateWithoutTestParameterInput, AgrotestUncheckedCreateWithoutTestParameterInput>
    connectOrCreate?: AgrotestCreateOrConnectWithoutTestParameterInput
    upsert?: AgrotestUpsertWithoutTestParameterInput
    connect?: AgrotestWhereUniqueInput
    update?: XOR<XOR<AgrotestUpdateToOneWithWhereWithoutTestParameterInput, AgrotestUpdateWithoutTestParameterInput>, AgrotestUncheckedUpdateWithoutTestParameterInput>
  }

  export type PricingUpdateManyWithoutTestParamaterNestedInput = {
    create?: XOR<PricingCreateWithoutTestParamaterInput, PricingUncheckedCreateWithoutTestParamaterInput> | PricingCreateWithoutTestParamaterInput[] | PricingUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: PricingCreateOrConnectWithoutTestParamaterInput | PricingCreateOrConnectWithoutTestParamaterInput[]
    upsert?: PricingUpsertWithWhereUniqueWithoutTestParamaterInput | PricingUpsertWithWhereUniqueWithoutTestParamaterInput[]
    createMany?: PricingCreateManyTestParamaterInputEnvelope
    set?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    disconnect?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    delete?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    connect?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    update?: PricingUpdateWithWhereUniqueWithoutTestParamaterInput | PricingUpdateWithWhereUniqueWithoutTestParamaterInput[]
    updateMany?: PricingUpdateManyWithWhereWithoutTestParamaterInput | PricingUpdateManyWithWhereWithoutTestParamaterInput[]
    deleteMany?: PricingScalarWhereInput | PricingScalarWhereInput[]
  }

  export type ComparisonRuleUpdateManyWithoutTestParameterNestedInput = {
    create?: XOR<ComparisonRuleCreateWithoutTestParameterInput, ComparisonRuleUncheckedCreateWithoutTestParameterInput> | ComparisonRuleCreateWithoutTestParameterInput[] | ComparisonRuleUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: ComparisonRuleCreateOrConnectWithoutTestParameterInput | ComparisonRuleCreateOrConnectWithoutTestParameterInput[]
    upsert?: ComparisonRuleUpsertWithWhereUniqueWithoutTestParameterInput | ComparisonRuleUpsertWithWhereUniqueWithoutTestParameterInput[]
    createMany?: ComparisonRuleCreateManyTestParameterInputEnvelope
    set?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    disconnect?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    delete?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    connect?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    update?: ComparisonRuleUpdateWithWhereUniqueWithoutTestParameterInput | ComparisonRuleUpdateWithWhereUniqueWithoutTestParameterInput[]
    updateMany?: ComparisonRuleUpdateManyWithWhereWithoutTestParameterInput | ComparisonRuleUpdateManyWithWhereWithoutTestParameterInput[]
    deleteMany?: ComparisonRuleScalarWhereInput | ComparisonRuleScalarWhereInput[]
  }

  export type TestResultUpdateManyWithoutTestParamaterNestedInput = {
    create?: XOR<TestResultCreateWithoutTestParamaterInput, TestResultUncheckedCreateWithoutTestParamaterInput> | TestResultCreateWithoutTestParamaterInput[] | TestResultUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutTestParamaterInput | TestResultCreateOrConnectWithoutTestParamaterInput[]
    upsert?: TestResultUpsertWithWhereUniqueWithoutTestParamaterInput | TestResultUpsertWithWhereUniqueWithoutTestParamaterInput[]
    createMany?: TestResultCreateManyTestParamaterInputEnvelope
    set?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    disconnect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    delete?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    update?: TestResultUpdateWithWhereUniqueWithoutTestParamaterInput | TestResultUpdateWithWhereUniqueWithoutTestParamaterInput[]
    updateMany?: TestResultUpdateManyWithWhereWithoutTestParamaterInput | TestResultUpdateManyWithWhereWithoutTestParamaterInput[]
    deleteMany?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
  }

  export type OrderTestParameterUpdateManyWithoutTestParameterNestedInput = {
    create?: XOR<OrderTestParameterCreateWithoutTestParameterInput, OrderTestParameterUncheckedCreateWithoutTestParameterInput> | OrderTestParameterCreateWithoutTestParameterInput[] | OrderTestParameterUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutTestParameterInput | OrderTestParameterCreateOrConnectWithoutTestParameterInput[]
    upsert?: OrderTestParameterUpsertWithWhereUniqueWithoutTestParameterInput | OrderTestParameterUpsertWithWhereUniqueWithoutTestParameterInput[]
    createMany?: OrderTestParameterCreateManyTestParameterInputEnvelope
    set?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    disconnect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    delete?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    update?: OrderTestParameterUpdateWithWhereUniqueWithoutTestParameterInput | OrderTestParameterUpdateWithWhereUniqueWithoutTestParameterInput[]
    updateMany?: OrderTestParameterUpdateManyWithWhereWithoutTestParameterInput | OrderTestParameterUpdateManyWithWhereWithoutTestParameterInput[]
    deleteMany?: OrderTestParameterScalarWhereInput | OrderTestParameterScalarWhereInput[]
  }

  export type PricingUncheckedUpdateManyWithoutTestParamaterNestedInput = {
    create?: XOR<PricingCreateWithoutTestParamaterInput, PricingUncheckedCreateWithoutTestParamaterInput> | PricingCreateWithoutTestParamaterInput[] | PricingUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: PricingCreateOrConnectWithoutTestParamaterInput | PricingCreateOrConnectWithoutTestParamaterInput[]
    upsert?: PricingUpsertWithWhereUniqueWithoutTestParamaterInput | PricingUpsertWithWhereUniqueWithoutTestParamaterInput[]
    createMany?: PricingCreateManyTestParamaterInputEnvelope
    set?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    disconnect?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    delete?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    connect?: PricingWhereUniqueInput | PricingWhereUniqueInput[]
    update?: PricingUpdateWithWhereUniqueWithoutTestParamaterInput | PricingUpdateWithWhereUniqueWithoutTestParamaterInput[]
    updateMany?: PricingUpdateManyWithWhereWithoutTestParamaterInput | PricingUpdateManyWithWhereWithoutTestParamaterInput[]
    deleteMany?: PricingScalarWhereInput | PricingScalarWhereInput[]
  }

  export type ComparisonRuleUncheckedUpdateManyWithoutTestParameterNestedInput = {
    create?: XOR<ComparisonRuleCreateWithoutTestParameterInput, ComparisonRuleUncheckedCreateWithoutTestParameterInput> | ComparisonRuleCreateWithoutTestParameterInput[] | ComparisonRuleUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: ComparisonRuleCreateOrConnectWithoutTestParameterInput | ComparisonRuleCreateOrConnectWithoutTestParameterInput[]
    upsert?: ComparisonRuleUpsertWithWhereUniqueWithoutTestParameterInput | ComparisonRuleUpsertWithWhereUniqueWithoutTestParameterInput[]
    createMany?: ComparisonRuleCreateManyTestParameterInputEnvelope
    set?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    disconnect?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    delete?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    connect?: ComparisonRuleWhereUniqueInput | ComparisonRuleWhereUniqueInput[]
    update?: ComparisonRuleUpdateWithWhereUniqueWithoutTestParameterInput | ComparisonRuleUpdateWithWhereUniqueWithoutTestParameterInput[]
    updateMany?: ComparisonRuleUpdateManyWithWhereWithoutTestParameterInput | ComparisonRuleUpdateManyWithWhereWithoutTestParameterInput[]
    deleteMany?: ComparisonRuleScalarWhereInput | ComparisonRuleScalarWhereInput[]
  }

  export type TestResultUncheckedUpdateManyWithoutTestParamaterNestedInput = {
    create?: XOR<TestResultCreateWithoutTestParamaterInput, TestResultUncheckedCreateWithoutTestParamaterInput> | TestResultCreateWithoutTestParamaterInput[] | TestResultUncheckedCreateWithoutTestParamaterInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutTestParamaterInput | TestResultCreateOrConnectWithoutTestParamaterInput[]
    upsert?: TestResultUpsertWithWhereUniqueWithoutTestParamaterInput | TestResultUpsertWithWhereUniqueWithoutTestParamaterInput[]
    createMany?: TestResultCreateManyTestParamaterInputEnvelope
    set?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    disconnect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    delete?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    update?: TestResultUpdateWithWhereUniqueWithoutTestParamaterInput | TestResultUpdateWithWhereUniqueWithoutTestParamaterInput[]
    updateMany?: TestResultUpdateManyWithWhereWithoutTestParamaterInput | TestResultUpdateManyWithWhereWithoutTestParamaterInput[]
    deleteMany?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
  }

  export type OrderTestParameterUncheckedUpdateManyWithoutTestParameterNestedInput = {
    create?: XOR<OrderTestParameterCreateWithoutTestParameterInput, OrderTestParameterUncheckedCreateWithoutTestParameterInput> | OrderTestParameterCreateWithoutTestParameterInput[] | OrderTestParameterUncheckedCreateWithoutTestParameterInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutTestParameterInput | OrderTestParameterCreateOrConnectWithoutTestParameterInput[]
    upsert?: OrderTestParameterUpsertWithWhereUniqueWithoutTestParameterInput | OrderTestParameterUpsertWithWhereUniqueWithoutTestParameterInput[]
    createMany?: OrderTestParameterCreateManyTestParameterInputEnvelope
    set?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    disconnect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    delete?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    update?: OrderTestParameterUpdateWithWhereUniqueWithoutTestParameterInput | OrderTestParameterUpdateWithWhereUniqueWithoutTestParameterInput[]
    updateMany?: OrderTestParameterUpdateManyWithWhereWithoutTestParameterInput | OrderTestParameterUpdateManyWithWhereWithoutTestParameterInput[]
    deleteMany?: OrderTestParameterScalarWhereInput | OrderTestParameterScalarWhereInput[]
  }

  export type OrderCreateNestedOneWithoutSamplesInput = {
    create?: XOR<OrderCreateWithoutSamplesInput, OrderUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSamplesInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderItemCreateNestedOneWithoutSampleInput = {
    create?: XOR<OrderItemCreateWithoutSampleInput, OrderItemUncheckedCreateWithoutSampleInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutSampleInput
    connect?: OrderItemWhereUniqueInput
  }

  export type TestResultCreateNestedManyWithoutSampleInput = {
    create?: XOR<TestResultCreateWithoutSampleInput, TestResultUncheckedCreateWithoutSampleInput> | TestResultCreateWithoutSampleInput[] | TestResultUncheckedCreateWithoutSampleInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutSampleInput | TestResultCreateOrConnectWithoutSampleInput[]
    createMany?: TestResultCreateManySampleInputEnvelope
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
  }

  export type ReportCreateNestedOneWithoutSamplesInput = {
    create?: XOR<ReportCreateWithoutSamplesInput, ReportUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutSamplesInput
    connect?: ReportWhereUniqueInput
  }

  export type TestResultUncheckedCreateNestedManyWithoutSampleInput = {
    create?: XOR<TestResultCreateWithoutSampleInput, TestResultUncheckedCreateWithoutSampleInput> | TestResultCreateWithoutSampleInput[] | TestResultUncheckedCreateWithoutSampleInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutSampleInput | TestResultCreateOrConnectWithoutSampleInput[]
    createMany?: TestResultCreateManySampleInputEnvelope
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumSampleStatusFieldUpdateOperationsInput = {
    set?: $Enums.SampleStatus
  }

  export type OrderUpdateOneRequiredWithoutSamplesNestedInput = {
    create?: XOR<OrderCreateWithoutSamplesInput, OrderUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: OrderCreateOrConnectWithoutSamplesInput
    upsert?: OrderUpsertWithoutSamplesInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutSamplesInput, OrderUpdateWithoutSamplesInput>, OrderUncheckedUpdateWithoutSamplesInput>
  }

  export type OrderItemUpdateOneRequiredWithoutSampleNestedInput = {
    create?: XOR<OrderItemCreateWithoutSampleInput, OrderItemUncheckedCreateWithoutSampleInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutSampleInput
    upsert?: OrderItemUpsertWithoutSampleInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutSampleInput, OrderItemUpdateWithoutSampleInput>, OrderItemUncheckedUpdateWithoutSampleInput>
  }

  export type TestResultUpdateManyWithoutSampleNestedInput = {
    create?: XOR<TestResultCreateWithoutSampleInput, TestResultUncheckedCreateWithoutSampleInput> | TestResultCreateWithoutSampleInput[] | TestResultUncheckedCreateWithoutSampleInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutSampleInput | TestResultCreateOrConnectWithoutSampleInput[]
    upsert?: TestResultUpsertWithWhereUniqueWithoutSampleInput | TestResultUpsertWithWhereUniqueWithoutSampleInput[]
    createMany?: TestResultCreateManySampleInputEnvelope
    set?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    disconnect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    delete?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    update?: TestResultUpdateWithWhereUniqueWithoutSampleInput | TestResultUpdateWithWhereUniqueWithoutSampleInput[]
    updateMany?: TestResultUpdateManyWithWhereWithoutSampleInput | TestResultUpdateManyWithWhereWithoutSampleInput[]
    deleteMany?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
  }

  export type ReportUpdateOneWithoutSamplesNestedInput = {
    create?: XOR<ReportCreateWithoutSamplesInput, ReportUncheckedCreateWithoutSamplesInput>
    connectOrCreate?: ReportCreateOrConnectWithoutSamplesInput
    upsert?: ReportUpsertWithoutSamplesInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutSamplesInput, ReportUpdateWithoutSamplesInput>, ReportUncheckedUpdateWithoutSamplesInput>
  }

  export type TestResultUncheckedUpdateManyWithoutSampleNestedInput = {
    create?: XOR<TestResultCreateWithoutSampleInput, TestResultUncheckedCreateWithoutSampleInput> | TestResultCreateWithoutSampleInput[] | TestResultUncheckedCreateWithoutSampleInput[]
    connectOrCreate?: TestResultCreateOrConnectWithoutSampleInput | TestResultCreateOrConnectWithoutSampleInput[]
    upsert?: TestResultUpsertWithWhereUniqueWithoutSampleInput | TestResultUpsertWithWhereUniqueWithoutSampleInput[]
    createMany?: TestResultCreateManySampleInputEnvelope
    set?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    disconnect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    delete?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    connect?: TestResultWhereUniqueInput | TestResultWhereUniqueInput[]
    update?: TestResultUpdateWithWhereUniqueWithoutSampleInput | TestResultUpdateWithWhereUniqueWithoutSampleInput[]
    updateMany?: TestResultUpdateManyWithWhereWithoutSampleInput | TestResultUpdateManyWithWhereWithoutSampleInput[]
    deleteMany?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
  }

  export type SampleCreateNestedOneWithoutTestResultsInput = {
    create?: XOR<SampleCreateWithoutTestResultsInput, SampleUncheckedCreateWithoutTestResultsInput>
    connectOrCreate?: SampleCreateOrConnectWithoutTestResultsInput
    connect?: SampleWhereUniqueInput
  }

  export type TestParameterCreateNestedOneWithoutTestResultsInput = {
    create?: XOR<TestParameterCreateWithoutTestResultsInput, TestParameterUncheckedCreateWithoutTestResultsInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutTestResultsInput
    connect?: TestParameterWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SampleUpdateOneRequiredWithoutTestResultsNestedInput = {
    create?: XOR<SampleCreateWithoutTestResultsInput, SampleUncheckedCreateWithoutTestResultsInput>
    connectOrCreate?: SampleCreateOrConnectWithoutTestResultsInput
    upsert?: SampleUpsertWithoutTestResultsInput
    connect?: SampleWhereUniqueInput
    update?: XOR<XOR<SampleUpdateToOneWithWhereWithoutTestResultsInput, SampleUpdateWithoutTestResultsInput>, SampleUncheckedUpdateWithoutTestResultsInput>
  }

  export type TestParameterUpdateOneRequiredWithoutTestResultsNestedInput = {
    create?: XOR<TestParameterCreateWithoutTestResultsInput, TestParameterUncheckedCreateWithoutTestResultsInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutTestResultsInput
    upsert?: TestParameterUpsertWithoutTestResultsInput
    connect?: TestParameterWhereUniqueInput
    update?: XOR<XOR<TestParameterUpdateToOneWithWhereWithoutTestResultsInput, TestParameterUpdateWithoutTestResultsInput>, TestParameterUncheckedUpdateWithoutTestResultsInput>
  }

  export type TestParameterCreateNestedOneWithoutComparisonRulesInput = {
    create?: XOR<TestParameterCreateWithoutComparisonRulesInput, TestParameterUncheckedCreateWithoutComparisonRulesInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutComparisonRulesInput
    connect?: TestParameterWhereUniqueInput
  }

  export type NullableEnumSoilCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SoilCategory | null
  }

  export type EnumComparisonTypeFieldUpdateOperationsInput = {
    set?: $Enums.ComparisonType
  }

  export type TestParameterUpdateOneRequiredWithoutComparisonRulesNestedInput = {
    create?: XOR<TestParameterCreateWithoutComparisonRulesInput, TestParameterUncheckedCreateWithoutComparisonRulesInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutComparisonRulesInput
    upsert?: TestParameterUpsertWithoutComparisonRulesInput
    connect?: TestParameterWhereUniqueInput
    update?: XOR<XOR<TestParameterUpdateToOneWithWhereWithoutComparisonRulesInput, TestParameterUpdateWithoutComparisonRulesInput>, TestParameterUncheckedUpdateWithoutComparisonRulesInput>
  }

  export type TestParameterCreateNestedOneWithoutPricingInput = {
    create?: XOR<TestParameterCreateWithoutPricingInput, TestParameterUncheckedCreateWithoutPricingInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutPricingInput
    connect?: TestParameterWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TestParameterUpdateOneRequiredWithoutPricingNestedInput = {
    create?: XOR<TestParameterCreateWithoutPricingInput, TestParameterUncheckedCreateWithoutPricingInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutPricingInput
    upsert?: TestParameterUpsertWithoutPricingInput
    connect?: TestParameterWhereUniqueInput
    update?: XOR<XOR<TestParameterUpdateToOneWithWhereWithoutPricingInput, TestParameterUpdateWithoutPricingInput>, TestParameterUncheckedUpdateWithoutPricingInput>
  }

  export type ClientCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    connect?: ClientWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOrdersInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type SampleCreateNestedManyWithoutOrderInput = {
    create?: XOR<SampleCreateWithoutOrderInput, SampleUncheckedCreateWithoutOrderInput> | SampleCreateWithoutOrderInput[] | SampleUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderInput | SampleCreateOrConnectWithoutOrderInput[]
    createMany?: SampleCreateManyOrderInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ReportCreateNestedOneWithoutOrderInput = {
    create?: XOR<ReportCreateWithoutOrderInput, ReportUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReportCreateOrConnectWithoutOrderInput
    connect?: ReportWhereUniqueInput
  }

  export type SampleUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<SampleCreateWithoutOrderInput, SampleUncheckedCreateWithoutOrderInput> | SampleCreateWithoutOrderInput[] | SampleUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderInput | SampleCreateOrConnectWithoutOrderInput[]
    createMany?: SampleCreateManyOrderInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ReportUncheckedCreateNestedOneWithoutOrderInput = {
    create?: XOR<ReportCreateWithoutOrderInput, ReportUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReportCreateOrConnectWithoutOrderInput
    connect?: ReportWhereUniqueInput
  }

  export type EnumOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatus
  }

  export type ClientUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ClientCreateOrConnectWithoutOrdersInput
    upsert?: ClientUpsertWithoutOrdersInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutOrdersInput, ClientUpdateWithoutOrdersInput>, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutOrdersInput
    upsert?: UserUpsertWithoutOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOrdersInput, UserUpdateWithoutOrdersInput>, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type SampleUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SampleCreateWithoutOrderInput, SampleUncheckedCreateWithoutOrderInput> | SampleCreateWithoutOrderInput[] | SampleUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderInput | SampleCreateOrConnectWithoutOrderInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutOrderInput | SampleUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SampleCreateManyOrderInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutOrderInput | SampleUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutOrderInput | SampleUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type ReportUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ReportCreateWithoutOrderInput, ReportUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReportCreateOrConnectWithoutOrderInput
    upsert?: ReportUpsertWithoutOrderInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutOrderInput, ReportUpdateWithoutOrderInput>, ReportUncheckedUpdateWithoutOrderInput>
  }

  export type SampleUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<SampleCreateWithoutOrderInput, SampleUncheckedCreateWithoutOrderInput> | SampleCreateWithoutOrderInput[] | SampleUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderInput | SampleCreateOrConnectWithoutOrderInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutOrderInput | SampleUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: SampleCreateManyOrderInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutOrderInput | SampleUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutOrderInput | SampleUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutOrderInput
    upsert?: InvoiceUpsertWithoutOrderInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutOrderInput, InvoiceUpdateWithoutOrderInput>, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type ReportUncheckedUpdateOneWithoutOrderNestedInput = {
    create?: XOR<ReportCreateWithoutOrderInput, ReportUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ReportCreateOrConnectWithoutOrderInput
    upsert?: ReportUpsertWithoutOrderInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutOrderInput, ReportUpdateWithoutOrderInput>, ReportUncheckedUpdateWithoutOrderInput>
  }

  export type OrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
  }

  export type AgrotestCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<AgrotestCreateWithoutOrderItemsInput, AgrotestUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: AgrotestCreateOrConnectWithoutOrderItemsInput
    connect?: AgrotestWhereUniqueInput
  }

  export type OrderTestParameterCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<OrderTestParameterCreateWithoutOrderItemInput, OrderTestParameterUncheckedCreateWithoutOrderItemInput> | OrderTestParameterCreateWithoutOrderItemInput[] | OrderTestParameterUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutOrderItemInput | OrderTestParameterCreateOrConnectWithoutOrderItemInput[]
    createMany?: OrderTestParameterCreateManyOrderItemInputEnvelope
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
  }

  export type SampleCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<SampleCreateWithoutOrderItemInput, SampleUncheckedCreateWithoutOrderItemInput> | SampleCreateWithoutOrderItemInput[] | SampleUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderItemInput | SampleCreateOrConnectWithoutOrderItemInput[]
    createMany?: SampleCreateManyOrderItemInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type OrderTestParameterUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<OrderTestParameterCreateWithoutOrderItemInput, OrderTestParameterUncheckedCreateWithoutOrderItemInput> | OrderTestParameterCreateWithoutOrderItemInput[] | OrderTestParameterUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutOrderItemInput | OrderTestParameterCreateOrConnectWithoutOrderItemInput[]
    createMany?: OrderTestParameterCreateManyOrderItemInputEnvelope
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
  }

  export type SampleUncheckedCreateNestedManyWithoutOrderItemInput = {
    create?: XOR<SampleCreateWithoutOrderItemInput, SampleUncheckedCreateWithoutOrderItemInput> | SampleCreateWithoutOrderItemInput[] | SampleUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderItemInput | SampleCreateOrConnectWithoutOrderItemInput[]
    createMany?: SampleCreateManyOrderItemInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: OrderCreateOrConnectWithoutOrderItemsInput
    upsert?: OrderUpsertWithoutOrderItemsInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutOrderItemsInput, OrderUpdateWithoutOrderItemsInput>, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type AgrotestUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<AgrotestCreateWithoutOrderItemsInput, AgrotestUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: AgrotestCreateOrConnectWithoutOrderItemsInput
    upsert?: AgrotestUpsertWithoutOrderItemsInput
    connect?: AgrotestWhereUniqueInput
    update?: XOR<XOR<AgrotestUpdateToOneWithWhereWithoutOrderItemsInput, AgrotestUpdateWithoutOrderItemsInput>, AgrotestUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderTestParameterUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<OrderTestParameterCreateWithoutOrderItemInput, OrderTestParameterUncheckedCreateWithoutOrderItemInput> | OrderTestParameterCreateWithoutOrderItemInput[] | OrderTestParameterUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutOrderItemInput | OrderTestParameterCreateOrConnectWithoutOrderItemInput[]
    upsert?: OrderTestParameterUpsertWithWhereUniqueWithoutOrderItemInput | OrderTestParameterUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: OrderTestParameterCreateManyOrderItemInputEnvelope
    set?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    disconnect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    delete?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    update?: OrderTestParameterUpdateWithWhereUniqueWithoutOrderItemInput | OrderTestParameterUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: OrderTestParameterUpdateManyWithWhereWithoutOrderItemInput | OrderTestParameterUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: OrderTestParameterScalarWhereInput | OrderTestParameterScalarWhereInput[]
  }

  export type SampleUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<SampleCreateWithoutOrderItemInput, SampleUncheckedCreateWithoutOrderItemInput> | SampleCreateWithoutOrderItemInput[] | SampleUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderItemInput | SampleCreateOrConnectWithoutOrderItemInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutOrderItemInput | SampleUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: SampleCreateManyOrderItemInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutOrderItemInput | SampleUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutOrderItemInput | SampleUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type OrderTestParameterUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<OrderTestParameterCreateWithoutOrderItemInput, OrderTestParameterUncheckedCreateWithoutOrderItemInput> | OrderTestParameterCreateWithoutOrderItemInput[] | OrderTestParameterUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: OrderTestParameterCreateOrConnectWithoutOrderItemInput | OrderTestParameterCreateOrConnectWithoutOrderItemInput[]
    upsert?: OrderTestParameterUpsertWithWhereUniqueWithoutOrderItemInput | OrderTestParameterUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: OrderTestParameterCreateManyOrderItemInputEnvelope
    set?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    disconnect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    delete?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    connect?: OrderTestParameterWhereUniqueInput | OrderTestParameterWhereUniqueInput[]
    update?: OrderTestParameterUpdateWithWhereUniqueWithoutOrderItemInput | OrderTestParameterUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: OrderTestParameterUpdateManyWithWhereWithoutOrderItemInput | OrderTestParameterUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: OrderTestParameterScalarWhereInput | OrderTestParameterScalarWhereInput[]
  }

  export type SampleUncheckedUpdateManyWithoutOrderItemNestedInput = {
    create?: XOR<SampleCreateWithoutOrderItemInput, SampleUncheckedCreateWithoutOrderItemInput> | SampleCreateWithoutOrderItemInput[] | SampleUncheckedCreateWithoutOrderItemInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutOrderItemInput | SampleCreateOrConnectWithoutOrderItemInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutOrderItemInput | SampleUpsertWithWhereUniqueWithoutOrderItemInput[]
    createMany?: SampleCreateManyOrderItemInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutOrderItemInput | SampleUpdateWithWhereUniqueWithoutOrderItemInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutOrderItemInput | SampleUpdateManyWithWhereWithoutOrderItemInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type OrderItemCreateNestedOneWithoutOrderTestParametersInput = {
    create?: XOR<OrderItemCreateWithoutOrderTestParametersInput, OrderItemUncheckedCreateWithoutOrderTestParametersInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderTestParametersInput
    connect?: OrderItemWhereUniqueInput
  }

  export type TestParameterCreateNestedOneWithoutOrderTestParametersInput = {
    create?: XOR<TestParameterCreateWithoutOrderTestParametersInput, TestParameterUncheckedCreateWithoutOrderTestParametersInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutOrderTestParametersInput
    connect?: TestParameterWhereUniqueInput
  }

  export type OrderItemUpdateOneRequiredWithoutOrderTestParametersNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderTestParametersInput, OrderItemUncheckedCreateWithoutOrderTestParametersInput>
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderTestParametersInput
    upsert?: OrderItemUpsertWithoutOrderTestParametersInput
    connect?: OrderItemWhereUniqueInput
    update?: XOR<XOR<OrderItemUpdateToOneWithWhereWithoutOrderTestParametersInput, OrderItemUpdateWithoutOrderTestParametersInput>, OrderItemUncheckedUpdateWithoutOrderTestParametersInput>
  }

  export type TestParameterUpdateOneRequiredWithoutOrderTestParametersNestedInput = {
    create?: XOR<TestParameterCreateWithoutOrderTestParametersInput, TestParameterUncheckedCreateWithoutOrderTestParametersInput>
    connectOrCreate?: TestParameterCreateOrConnectWithoutOrderTestParametersInput
    upsert?: TestParameterUpsertWithoutOrderTestParametersInput
    connect?: TestParameterWhereUniqueInput
    update?: XOR<XOR<TestParameterUpdateToOneWithWhereWithoutOrderTestParametersInput, TestParameterUpdateWithoutOrderTestParametersInput>, TestParameterUncheckedUpdateWithoutOrderTestParametersInput>
  }

  export type OrderCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
  }

  export type ReportCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ReportCreateWithoutInvoiceInput, ReportUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ReportCreateOrConnectWithoutInvoiceInput
    connect?: ReportWhereUniqueInput
  }

  export type ReportUncheckedCreateNestedOneWithoutInvoiceInput = {
    create?: XOR<ReportCreateWithoutInvoiceInput, ReportUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ReportCreateOrConnectWithoutInvoiceInput
    connect?: ReportWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type OrderUpdateOneRequiredWithoutInvoiceNestedInput = {
    create?: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: OrderCreateOrConnectWithoutInvoiceInput
    upsert?: OrderUpsertWithoutInvoiceInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutInvoiceInput, OrderUpdateWithoutInvoiceInput>, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type ClientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ClientCreateOrConnectWithoutInvoicesInput
    upsert?: ClientUpsertWithoutInvoicesInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutInvoicesInput, ClientUpdateWithoutInvoicesInput>, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ReportUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ReportCreateWithoutInvoiceInput, ReportUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ReportCreateOrConnectWithoutInvoiceInput
    upsert?: ReportUpsertWithoutInvoiceInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutInvoiceInput, ReportUpdateWithoutInvoiceInput>, ReportUncheckedUpdateWithoutInvoiceInput>
  }

  export type ReportUncheckedUpdateOneWithoutInvoiceNestedInput = {
    create?: XOR<ReportCreateWithoutInvoiceInput, ReportUncheckedCreateWithoutInvoiceInput>
    connectOrCreate?: ReportCreateOrConnectWithoutInvoiceInput
    upsert?: ReportUpsertWithoutInvoiceInput
    disconnect?: ReportWhereInput | boolean
    delete?: ReportWhereInput | boolean
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutInvoiceInput, ReportUpdateWithoutInvoiceInput>, ReportUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrderCreateNestedOneWithoutReportInput = {
    create?: XOR<OrderCreateWithoutReportInput, OrderUncheckedCreateWithoutReportInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReportInput
    connect?: OrderWhereUniqueInput
  }

  export type ClientCreateNestedOneWithoutReportsInput = {
    create?: XOR<ClientCreateWithoutReportsInput, ClientUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReportsInput
    connect?: ClientWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutReportInput = {
    create?: XOR<InvoiceCreateWithoutReportInput, InvoiceUncheckedCreateWithoutReportInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutReportInput
    connect?: InvoiceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReportsInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    connect?: UserWhereUniqueInput
  }

  export type SampleCreateNestedManyWithoutReportInput = {
    create?: XOR<SampleCreateWithoutReportInput, SampleUncheckedCreateWithoutReportInput> | SampleCreateWithoutReportInput[] | SampleUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutReportInput | SampleCreateOrConnectWithoutReportInput[]
    createMany?: SampleCreateManyReportInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type SampleUncheckedCreateNestedManyWithoutReportInput = {
    create?: XOR<SampleCreateWithoutReportInput, SampleUncheckedCreateWithoutReportInput> | SampleCreateWithoutReportInput[] | SampleUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutReportInput | SampleCreateOrConnectWithoutReportInput[]
    createMany?: SampleCreateManyReportInputEnvelope
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
  }

  export type EnumReportStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReportStatus
  }

  export type OrderUpdateOneRequiredWithoutReportNestedInput = {
    create?: XOR<OrderCreateWithoutReportInput, OrderUncheckedCreateWithoutReportInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReportInput
    upsert?: OrderUpsertWithoutReportInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReportInput, OrderUpdateWithoutReportInput>, OrderUncheckedUpdateWithoutReportInput>
  }

  export type ClientUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ClientCreateWithoutReportsInput, ClientUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ClientCreateOrConnectWithoutReportsInput
    upsert?: ClientUpsertWithoutReportsInput
    connect?: ClientWhereUniqueInput
    update?: XOR<XOR<ClientUpdateToOneWithWhereWithoutReportsInput, ClientUpdateWithoutReportsInput>, ClientUncheckedUpdateWithoutReportsInput>
  }

  export type InvoiceUpdateOneWithoutReportNestedInput = {
    create?: XOR<InvoiceCreateWithoutReportInput, InvoiceUncheckedCreateWithoutReportInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutReportInput
    upsert?: InvoiceUpsertWithoutReportInput
    disconnect?: InvoiceWhereInput | boolean
    delete?: InvoiceWhereInput | boolean
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutReportInput, InvoiceUpdateWithoutReportInput>, InvoiceUncheckedUpdateWithoutReportInput>
  }

  export type UserUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReportsInput
    upsert?: UserUpsertWithoutReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReportsInput, UserUpdateWithoutReportsInput>, UserUncheckedUpdateWithoutReportsInput>
  }

  export type SampleUpdateManyWithoutReportNestedInput = {
    create?: XOR<SampleCreateWithoutReportInput, SampleUncheckedCreateWithoutReportInput> | SampleCreateWithoutReportInput[] | SampleUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutReportInput | SampleCreateOrConnectWithoutReportInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutReportInput | SampleUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: SampleCreateManyReportInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutReportInput | SampleUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutReportInput | SampleUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type SampleUncheckedUpdateManyWithoutReportNestedInput = {
    create?: XOR<SampleCreateWithoutReportInput, SampleUncheckedCreateWithoutReportInput> | SampleCreateWithoutReportInput[] | SampleUncheckedCreateWithoutReportInput[]
    connectOrCreate?: SampleCreateOrConnectWithoutReportInput | SampleCreateOrConnectWithoutReportInput[]
    upsert?: SampleUpsertWithWhereUniqueWithoutReportInput | SampleUpsertWithWhereUniqueWithoutReportInput[]
    createMany?: SampleCreateManyReportInputEnvelope
    set?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    disconnect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    delete?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    connect?: SampleWhereUniqueInput | SampleWhereUniqueInput[]
    update?: SampleUpdateWithWhereUniqueWithoutReportInput | SampleUpdateWithWhereUniqueWithoutReportInput[]
    updateMany?: SampleUpdateManyWithWhereWithoutReportInput | SampleUpdateManyWithWhereWithoutReportInput[]
    deleteMany?: SampleScalarWhereInput | SampleScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumClientTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeFilter<$PrismaModel> | $Enums.ClientType
  }

  export type NestedEnumClientTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientType | EnumClientTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientType[] | ListEnumClientTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumClientTypeWithAggregatesFilter<$PrismaModel> | $Enums.ClientType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientTypeFilter<$PrismaModel>
    _max?: NestedEnumClientTypeFilter<$PrismaModel>
  }

  export type NestedEnumSampleTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeFilter<$PrismaModel> | $Enums.SampleType
  }

  export type NestedEnumSampleTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleType | EnumSampleTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleType[] | ListEnumSampleTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleTypeWithAggregatesFilter<$PrismaModel> | $Enums.SampleType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleTypeFilter<$PrismaModel>
    _max?: NestedEnumSampleTypeFilter<$PrismaModel>
  }

  export type NestedEnumAnalysisTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAnalysisTypeNullableFilter<$PrismaModel> | $Enums.AnalysisType | null
  }

  export type NestedEnumAnalysisTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalysisType | EnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AnalysisType[] | ListEnumAnalysisTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAnalysisTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AnalysisType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAnalysisTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAnalysisTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSampleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleStatus | EnumSampleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleStatusFilter<$PrismaModel> | $Enums.SampleStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumSampleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SampleStatus | EnumSampleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SampleStatus[] | ListEnumSampleStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSampleStatusWithAggregatesFilter<$PrismaModel> | $Enums.SampleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSampleStatusFilter<$PrismaModel>
    _max?: NestedEnumSampleStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumSoilCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.SoilCategory | EnumSoilCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSoilCategoryNullableFilter<$PrismaModel> | $Enums.SoilCategory | null
  }

  export type NestedEnumComparisonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonType | EnumComparisonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonTypeFilter<$PrismaModel> | $Enums.ComparisonType
  }

  export type NestedEnumSoilCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SoilCategory | EnumSoilCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.SoilCategory[] | ListEnumSoilCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSoilCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.SoilCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSoilCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumSoilCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumComparisonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComparisonType | EnumComparisonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComparisonType[] | ListEnumComparisonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumComparisonTypeWithAggregatesFilter<$PrismaModel> | $Enums.ComparisonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComparisonTypeFilter<$PrismaModel>
    _max?: NestedEnumComparisonTypeFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusFilter<$PrismaModel> | $Enums.OrderStatus
  }

  export type NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatus | EnumOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatus[] | ListEnumOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumReportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusFilter<$PrismaModel> | $Enums.ReportStatus
  }

  export type NestedEnumReportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportStatus | EnumReportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportStatus[] | ListEnumReportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumReportStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportStatusFilter<$PrismaModel>
    _max?: NestedEnumReportStatusFilter<$PrismaModel>
  }

  export type OrderCreateWithoutOperatorInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    samples?: SampleCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    report?: ReportCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOperatorInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    samples?: SampleUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    report?: ReportUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOperatorInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOperatorInput, OrderUncheckedCreateWithoutOperatorInput>
  }

  export type OrderCreateManyOperatorInputEnvelope = {
    data: OrderCreateManyOperatorInput | OrderCreateManyOperatorInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutGeneratorInput = {
    id?: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReportInput
    client: ClientCreateNestedOneWithoutReportsInput
    invoice?: InvoiceCreateNestedOneWithoutReportInput
    samples?: SampleCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutGeneratorInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: SampleUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutGeneratorInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput>
  }

  export type ReportCreateManyGeneratorInputEnvelope = {
    data: ReportCreateManyGeneratorInput | ReportCreateManyGeneratorInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOperatorInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOperatorInput, OrderUncheckedUpdateWithoutOperatorInput>
    create: XOR<OrderCreateWithoutOperatorInput, OrderUncheckedCreateWithoutOperatorInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOperatorInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOperatorInput, OrderUncheckedUpdateWithoutOperatorInput>
  }

  export type OrderUpdateManyWithWhereWithoutOperatorInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOperatorInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    clientId?: StringFilter<"Order"> | string
    sarokNumber?: StringNullableFilter<"Order"> | string | null
    orderDate?: DateTimeFilter<"Order"> | Date | string
    status?: EnumOrderStatusFilter<"Order"> | $Enums.OrderStatus
    operatorId?: StringFilter<"Order"> | string
    totalAmount?: FloatFilter<"Order"> | number
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    invoiceId?: StringNullableFilter<"Order"> | string | null
    reportId?: StringNullableFilter<"Order"> | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutGeneratorInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutGeneratorInput, ReportUncheckedUpdateWithoutGeneratorInput>
    create: XOR<ReportCreateWithoutGeneratorInput, ReportUncheckedCreateWithoutGeneratorInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutGeneratorInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutGeneratorInput, ReportUncheckedUpdateWithoutGeneratorInput>
  }

  export type ReportUpdateManyWithWhereWithoutGeneratorInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutGeneratorInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    orderId?: StringFilter<"Report"> | string
    clientId?: StringFilter<"Report"> | string
    invoiceId?: StringNullableFilter<"Report"> | string | null
    reportType?: StringFilter<"Report"> | string
    reportNumber?: StringFilter<"Report"> | string
    issueDate?: DateTimeFilter<"Report"> | Date | string
    status?: EnumReportStatusFilter<"Report"> | $Enums.ReportStatus
    recommendations?: StringNullableFilter<"Report"> | string | null
    notes?: StringNullableFilter<"Report"> | string | null
    generatedByUserId?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    updatedAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type OrderCreateWithoutClientInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    operator: UserCreateNestedOneWithoutOrdersInput
    samples?: SampleCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    report?: ReportCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutClientInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    samples?: SampleUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    report?: ReportUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutClientInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderCreateManyClientInputEnvelope = {
    data: OrderCreateManyClientInput | OrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    order: OrderCreateNestedOneWithoutInvoiceInput
    report?: ReportCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    orderId: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    report?: ReportUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutClientInput = {
    id?: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReportInput
    invoice?: InvoiceCreateNestedOneWithoutReportInput
    generator: UserCreateNestedOneWithoutReportsInput
    samples?: SampleCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutClientInput = {
    id?: string
    orderId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: SampleUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutClientInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput>
  }

  export type ReportCreateManyClientInputEnvelope = {
    data: ReportCreateManyClientInput | ReportCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
    create: XOR<OrderCreateWithoutClientInput, OrderUncheckedCreateWithoutClientInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutClientInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutClientInput, OrderUncheckedUpdateWithoutClientInput>
  }

  export type OrderUpdateManyWithWhereWithoutClientInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    orderId?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    invoiceDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    totalAmount?: FloatFilter<"Invoice"> | number
    paidAmount?: FloatFilter<"Invoice"> | number
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    reportId?: StringNullableFilter<"Invoice"> | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutClientInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutClientInput, ReportUncheckedUpdateWithoutClientInput>
    create: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutClientInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutClientInput, ReportUncheckedUpdateWithoutClientInput>
  }

  export type ReportUpdateManyWithWhereWithoutClientInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutClientInput>
  }

  export type TestParameterCreateWithoutAgroTestInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: PricingCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterUncheckedCreateWithoutAgroTestInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: PricingUncheckedCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleUncheckedCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultUncheckedCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterCreateOrConnectWithoutAgroTestInput = {
    where: TestParameterWhereUniqueInput
    create: XOR<TestParameterCreateWithoutAgroTestInput, TestParameterUncheckedCreateWithoutAgroTestInput>
  }

  export type TestParameterCreateManyAgroTestInputEnvelope = {
    data: TestParameterCreateManyAgroTestInput | TestParameterCreateManyAgroTestInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutAgroTestInput = {
    id?: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutOrderItemInput
    sample?: SampleCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutAgroTestInput = {
    id?: string
    orderId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutOrderItemInput
    sample?: SampleUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutAgroTestInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutAgroTestInput, OrderItemUncheckedCreateWithoutAgroTestInput>
  }

  export type OrderItemCreateManyAgroTestInputEnvelope = {
    data: OrderItemCreateManyAgroTestInput | OrderItemCreateManyAgroTestInput[]
    skipDuplicates?: boolean
  }

  export type TestParameterUpsertWithWhereUniqueWithoutAgroTestInput = {
    where: TestParameterWhereUniqueInput
    update: XOR<TestParameterUpdateWithoutAgroTestInput, TestParameterUncheckedUpdateWithoutAgroTestInput>
    create: XOR<TestParameterCreateWithoutAgroTestInput, TestParameterUncheckedCreateWithoutAgroTestInput>
  }

  export type TestParameterUpdateWithWhereUniqueWithoutAgroTestInput = {
    where: TestParameterWhereUniqueInput
    data: XOR<TestParameterUpdateWithoutAgroTestInput, TestParameterUncheckedUpdateWithoutAgroTestInput>
  }

  export type TestParameterUpdateManyWithWhereWithoutAgroTestInput = {
    where: TestParameterScalarWhereInput
    data: XOR<TestParameterUpdateManyMutationInput, TestParameterUncheckedUpdateManyWithoutAgroTestInput>
  }

  export type TestParameterScalarWhereInput = {
    AND?: TestParameterScalarWhereInput | TestParameterScalarWhereInput[]
    OR?: TestParameterScalarWhereInput[]
    NOT?: TestParameterScalarWhereInput | TestParameterScalarWhereInput[]
    id?: StringFilter<"TestParameter"> | string
    agroTestID?: StringFilter<"TestParameter"> | string
    name?: StringFilter<"TestParameter"> | string
    unit?: StringNullableFilter<"TestParameter"> | string | null
    analysisType?: EnumAnalysisTypeNullableFilter<"TestParameter"> | $Enums.AnalysisType | null
    createdAt?: DateTimeFilter<"TestParameter"> | Date | string
    updatedAt?: DateTimeFilter<"TestParameter"> | Date | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutAgroTestInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutAgroTestInput, OrderItemUncheckedUpdateWithoutAgroTestInput>
    create: XOR<OrderItemCreateWithoutAgroTestInput, OrderItemUncheckedCreateWithoutAgroTestInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutAgroTestInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutAgroTestInput, OrderItemUncheckedUpdateWithoutAgroTestInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutAgroTestInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutAgroTestInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: StringFilter<"OrderItem"> | string
    orderId?: StringFilter<"OrderItem"> | string
    agroTestId?: StringFilter<"OrderItem"> | string
    quantity?: IntFilter<"OrderItem"> | number
    unitPrice?: FloatFilter<"OrderItem"> | number
    subtotal?: FloatFilter<"OrderItem"> | number
    createdAt?: DateTimeFilter<"OrderItem"> | Date | string
    updatedAt?: DateTimeFilter<"OrderItem"> | Date | string
  }

  export type AgrotestCreateWithoutTestParameterInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemCreateNestedManyWithoutAgroTestInput
  }

  export type AgrotestUncheckedCreateWithoutTestParameterInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutAgroTestInput
  }

  export type AgrotestCreateOrConnectWithoutTestParameterInput = {
    where: AgrotestWhereUniqueInput
    create: XOR<AgrotestCreateWithoutTestParameterInput, AgrotestUncheckedCreateWithoutTestParameterInput>
  }

  export type PricingCreateWithoutTestParamaterInput = {
    id?: string
    clientType: $Enums.ClientType
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingUncheckedCreateWithoutTestParamaterInput = {
    id?: string
    clientType: $Enums.ClientType
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingCreateOrConnectWithoutTestParamaterInput = {
    where: PricingWhereUniqueInput
    create: XOR<PricingCreateWithoutTestParamaterInput, PricingUncheckedCreateWithoutTestParamaterInput>
  }

  export type PricingCreateManyTestParamaterInputEnvelope = {
    data: PricingCreateManyTestParamaterInput | PricingCreateManyTestParamaterInput[]
    skipDuplicates?: boolean
  }

  export type ComparisonRuleCreateWithoutTestParameterInput = {
    id?: string
    soilCategory?: $Enums.SoilCategory | null
    min?: number | null
    max?: number | null
    interpretation?: string | null
    type?: $Enums.ComparisonType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparisonRuleUncheckedCreateWithoutTestParameterInput = {
    id?: string
    soilCategory?: $Enums.SoilCategory | null
    min?: number | null
    max?: number | null
    interpretation?: string | null
    type?: $Enums.ComparisonType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparisonRuleCreateOrConnectWithoutTestParameterInput = {
    where: ComparisonRuleWhereUniqueInput
    create: XOR<ComparisonRuleCreateWithoutTestParameterInput, ComparisonRuleUncheckedCreateWithoutTestParameterInput>
  }

  export type ComparisonRuleCreateManyTestParameterInputEnvelope = {
    data: ComparisonRuleCreateManyTestParameterInput | ComparisonRuleCreateManyTestParameterInput[]
    skipDuplicates?: boolean
  }

  export type TestResultCreateWithoutTestParamaterInput = {
    id?: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sample: SampleCreateNestedOneWithoutTestResultsInput
  }

  export type TestResultUncheckedCreateWithoutTestParamaterInput = {
    id?: string
    sampleId: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestResultCreateOrConnectWithoutTestParamaterInput = {
    where: TestResultWhereUniqueInput
    create: XOR<TestResultCreateWithoutTestParamaterInput, TestResultUncheckedCreateWithoutTestParamaterInput>
  }

  export type TestResultCreateManyTestParamaterInputEnvelope = {
    data: TestResultCreateManyTestParamaterInput | TestResultCreateManyTestParamaterInput[]
    skipDuplicates?: boolean
  }

  export type OrderTestParameterCreateWithoutTestParameterInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutOrderTestParametersInput
  }

  export type OrderTestParameterUncheckedCreateWithoutTestParameterInput = {
    id?: string
    orderItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderTestParameterCreateOrConnectWithoutTestParameterInput = {
    where: OrderTestParameterWhereUniqueInput
    create: XOR<OrderTestParameterCreateWithoutTestParameterInput, OrderTestParameterUncheckedCreateWithoutTestParameterInput>
  }

  export type OrderTestParameterCreateManyTestParameterInputEnvelope = {
    data: OrderTestParameterCreateManyTestParameterInput | OrderTestParameterCreateManyTestParameterInput[]
    skipDuplicates?: boolean
  }

  export type AgrotestUpsertWithoutTestParameterInput = {
    update: XOR<AgrotestUpdateWithoutTestParameterInput, AgrotestUncheckedUpdateWithoutTestParameterInput>
    create: XOR<AgrotestCreateWithoutTestParameterInput, AgrotestUncheckedCreateWithoutTestParameterInput>
    where?: AgrotestWhereInput
  }

  export type AgrotestUpdateToOneWithWhereWithoutTestParameterInput = {
    where?: AgrotestWhereInput
    data: XOR<AgrotestUpdateWithoutTestParameterInput, AgrotestUncheckedUpdateWithoutTestParameterInput>
  }

  export type AgrotestUpdateWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUpdateManyWithoutAgroTestNestedInput
  }

  export type AgrotestUncheckedUpdateWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutAgroTestNestedInput
  }

  export type PricingUpsertWithWhereUniqueWithoutTestParamaterInput = {
    where: PricingWhereUniqueInput
    update: XOR<PricingUpdateWithoutTestParamaterInput, PricingUncheckedUpdateWithoutTestParamaterInput>
    create: XOR<PricingCreateWithoutTestParamaterInput, PricingUncheckedCreateWithoutTestParamaterInput>
  }

  export type PricingUpdateWithWhereUniqueWithoutTestParamaterInput = {
    where: PricingWhereUniqueInput
    data: XOR<PricingUpdateWithoutTestParamaterInput, PricingUncheckedUpdateWithoutTestParamaterInput>
  }

  export type PricingUpdateManyWithWhereWithoutTestParamaterInput = {
    where: PricingScalarWhereInput
    data: XOR<PricingUpdateManyMutationInput, PricingUncheckedUpdateManyWithoutTestParamaterInput>
  }

  export type PricingScalarWhereInput = {
    AND?: PricingScalarWhereInput | PricingScalarWhereInput[]
    OR?: PricingScalarWhereInput[]
    NOT?: PricingScalarWhereInput | PricingScalarWhereInput[]
    id?: StringFilter<"Pricing"> | string
    clientType?: EnumClientTypeFilter<"Pricing"> | $Enums.ClientType
    testParamterId?: StringFilter<"Pricing"> | string
    price?: FloatFilter<"Pricing"> | number
    createdAt?: DateTimeFilter<"Pricing"> | Date | string
    updatedAt?: DateTimeFilter<"Pricing"> | Date | string
  }

  export type ComparisonRuleUpsertWithWhereUniqueWithoutTestParameterInput = {
    where: ComparisonRuleWhereUniqueInput
    update: XOR<ComparisonRuleUpdateWithoutTestParameterInput, ComparisonRuleUncheckedUpdateWithoutTestParameterInput>
    create: XOR<ComparisonRuleCreateWithoutTestParameterInput, ComparisonRuleUncheckedCreateWithoutTestParameterInput>
  }

  export type ComparisonRuleUpdateWithWhereUniqueWithoutTestParameterInput = {
    where: ComparisonRuleWhereUniqueInput
    data: XOR<ComparisonRuleUpdateWithoutTestParameterInput, ComparisonRuleUncheckedUpdateWithoutTestParameterInput>
  }

  export type ComparisonRuleUpdateManyWithWhereWithoutTestParameterInput = {
    where: ComparisonRuleScalarWhereInput
    data: XOR<ComparisonRuleUpdateManyMutationInput, ComparisonRuleUncheckedUpdateManyWithoutTestParameterInput>
  }

  export type ComparisonRuleScalarWhereInput = {
    AND?: ComparisonRuleScalarWhereInput | ComparisonRuleScalarWhereInput[]
    OR?: ComparisonRuleScalarWhereInput[]
    NOT?: ComparisonRuleScalarWhereInput | ComparisonRuleScalarWhereInput[]
    id?: StringFilter<"ComparisonRule"> | string
    testParameterId?: StringFilter<"ComparisonRule"> | string
    soilCategory?: EnumSoilCategoryNullableFilter<"ComparisonRule"> | $Enums.SoilCategory | null
    min?: FloatNullableFilter<"ComparisonRule"> | number | null
    max?: FloatNullableFilter<"ComparisonRule"> | number | null
    interpretation?: StringNullableFilter<"ComparisonRule"> | string | null
    type?: EnumComparisonTypeFilter<"ComparisonRule"> | $Enums.ComparisonType
    createdAt?: DateTimeFilter<"ComparisonRule"> | Date | string
    updatedAt?: DateTimeFilter<"ComparisonRule"> | Date | string
  }

  export type TestResultUpsertWithWhereUniqueWithoutTestParamaterInput = {
    where: TestResultWhereUniqueInput
    update: XOR<TestResultUpdateWithoutTestParamaterInput, TestResultUncheckedUpdateWithoutTestParamaterInput>
    create: XOR<TestResultCreateWithoutTestParamaterInput, TestResultUncheckedCreateWithoutTestParamaterInput>
  }

  export type TestResultUpdateWithWhereUniqueWithoutTestParamaterInput = {
    where: TestResultWhereUniqueInput
    data: XOR<TestResultUpdateWithoutTestParamaterInput, TestResultUncheckedUpdateWithoutTestParamaterInput>
  }

  export type TestResultUpdateManyWithWhereWithoutTestParamaterInput = {
    where: TestResultScalarWhereInput
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyWithoutTestParamaterInput>
  }

  export type TestResultScalarWhereInput = {
    AND?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
    OR?: TestResultScalarWhereInput[]
    NOT?: TestResultScalarWhereInput | TestResultScalarWhereInput[]
    id?: StringFilter<"TestResult"> | string
    sampleId?: StringFilter<"TestResult"> | string
    testParameterId?: StringFilter<"TestResult"> | string
    value?: FloatNullableFilter<"TestResult"> | number | null
    interpretation?: StringNullableFilter<"TestResult"> | string | null
    uplandInterpretation?: StringNullableFilter<"TestResult"> | string | null
    wetlandInterpretation?: StringNullableFilter<"TestResult"> | string | null
    analysisType?: EnumAnalysisTypeNullableFilter<"TestResult"> | $Enums.AnalysisType | null
    createdAt?: DateTimeFilter<"TestResult"> | Date | string
    updatedAt?: DateTimeFilter<"TestResult"> | Date | string
  }

  export type OrderTestParameterUpsertWithWhereUniqueWithoutTestParameterInput = {
    where: OrderTestParameterWhereUniqueInput
    update: XOR<OrderTestParameterUpdateWithoutTestParameterInput, OrderTestParameterUncheckedUpdateWithoutTestParameterInput>
    create: XOR<OrderTestParameterCreateWithoutTestParameterInput, OrderTestParameterUncheckedCreateWithoutTestParameterInput>
  }

  export type OrderTestParameterUpdateWithWhereUniqueWithoutTestParameterInput = {
    where: OrderTestParameterWhereUniqueInput
    data: XOR<OrderTestParameterUpdateWithoutTestParameterInput, OrderTestParameterUncheckedUpdateWithoutTestParameterInput>
  }

  export type OrderTestParameterUpdateManyWithWhereWithoutTestParameterInput = {
    where: OrderTestParameterScalarWhereInput
    data: XOR<OrderTestParameterUpdateManyMutationInput, OrderTestParameterUncheckedUpdateManyWithoutTestParameterInput>
  }

  export type OrderTestParameterScalarWhereInput = {
    AND?: OrderTestParameterScalarWhereInput | OrderTestParameterScalarWhereInput[]
    OR?: OrderTestParameterScalarWhereInput[]
    NOT?: OrderTestParameterScalarWhereInput | OrderTestParameterScalarWhereInput[]
    id?: StringFilter<"OrderTestParameter"> | string
    orderItemId?: StringFilter<"OrderTestParameter"> | string
    testParameterId?: StringFilter<"OrderTestParameter"> | string
    createdAt?: DateTimeFilter<"OrderTestParameter"> | Date | string
    updatedAt?: DateTimeFilter<"OrderTestParameter"> | Date | string
  }

  export type OrderCreateWithoutSamplesInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    operator: UserCreateNestedOneWithoutOrdersInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    report?: ReportCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutSamplesInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    report?: ReportUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutSamplesInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutSamplesInput, OrderUncheckedCreateWithoutSamplesInput>
  }

  export type OrderItemCreateWithoutSampleInput = {
    id?: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
    agroTest: AgrotestCreateNestedOneWithoutOrderItemsInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutSampleInput = {
    id?: string
    orderId: string
    agroTestId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutSampleInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutSampleInput, OrderItemUncheckedCreateWithoutSampleInput>
  }

  export type TestResultCreateWithoutSampleInput = {
    id?: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    testParamater: TestParameterCreateNestedOneWithoutTestResultsInput
  }

  export type TestResultUncheckedCreateWithoutSampleInput = {
    id?: string
    testParameterId: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestResultCreateOrConnectWithoutSampleInput = {
    where: TestResultWhereUniqueInput
    create: XOR<TestResultCreateWithoutSampleInput, TestResultUncheckedCreateWithoutSampleInput>
  }

  export type TestResultCreateManySampleInputEnvelope = {
    data: TestResultCreateManySampleInput | TestResultCreateManySampleInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutSamplesInput = {
    id?: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReportInput
    client: ClientCreateNestedOneWithoutReportsInput
    invoice?: InvoiceCreateNestedOneWithoutReportInput
    generator: UserCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutSamplesInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutSamplesInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutSamplesInput, ReportUncheckedCreateWithoutSamplesInput>
  }

  export type OrderUpsertWithoutSamplesInput = {
    update: XOR<OrderUpdateWithoutSamplesInput, OrderUncheckedUpdateWithoutSamplesInput>
    create: XOR<OrderCreateWithoutSamplesInput, OrderUncheckedCreateWithoutSamplesInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutSamplesInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutSamplesInput, OrderUncheckedUpdateWithoutSamplesInput>
  }

  export type OrderUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    operator?: UserUpdateOneRequiredWithoutOrdersNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    report?: ReportUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    report?: ReportUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderItemUpsertWithoutSampleInput = {
    update: XOR<OrderItemUpdateWithoutSampleInput, OrderItemUncheckedUpdateWithoutSampleInput>
    create: XOR<OrderItemCreateWithoutSampleInput, OrderItemUncheckedCreateWithoutSampleInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutSampleInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutSampleInput, OrderItemUncheckedUpdateWithoutSampleInput>
  }

  export type OrderItemUpdateWithoutSampleInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    agroTest?: AgrotestUpdateOneRequiredWithoutOrderItemsNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutSampleInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agroTestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type TestResultUpsertWithWhereUniqueWithoutSampleInput = {
    where: TestResultWhereUniqueInput
    update: XOR<TestResultUpdateWithoutSampleInput, TestResultUncheckedUpdateWithoutSampleInput>
    create: XOR<TestResultCreateWithoutSampleInput, TestResultUncheckedCreateWithoutSampleInput>
  }

  export type TestResultUpdateWithWhereUniqueWithoutSampleInput = {
    where: TestResultWhereUniqueInput
    data: XOR<TestResultUpdateWithoutSampleInput, TestResultUncheckedUpdateWithoutSampleInput>
  }

  export type TestResultUpdateManyWithWhereWithoutSampleInput = {
    where: TestResultScalarWhereInput
    data: XOR<TestResultUpdateManyMutationInput, TestResultUncheckedUpdateManyWithoutSampleInput>
  }

  export type ReportUpsertWithoutSamplesInput = {
    update: XOR<ReportUpdateWithoutSamplesInput, ReportUncheckedUpdateWithoutSamplesInput>
    create: XOR<ReportCreateWithoutSamplesInput, ReportUncheckedCreateWithoutSamplesInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutSamplesInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutSamplesInput, ReportUncheckedUpdateWithoutSamplesInput>
  }

  export type ReportUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReportNestedInput
    client?: ClientUpdateOneRequiredWithoutReportsNestedInput
    invoice?: InvoiceUpdateOneWithoutReportNestedInput
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutSamplesInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleCreateWithoutTestResultsInput = {
    id?: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutSamplesInput
    orderItem: OrderItemCreateNestedOneWithoutSampleInput
    report?: ReportCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateWithoutTestResultsInput = {
    id?: string
    orderId: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type SampleCreateOrConnectWithoutTestResultsInput = {
    where: SampleWhereUniqueInput
    create: XOR<SampleCreateWithoutTestResultsInput, SampleUncheckedCreateWithoutTestResultsInput>
  }

  export type TestParameterCreateWithoutTestResultsInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agroTest: AgrotestCreateNestedOneWithoutTestParameterInput
    pricing?: PricingCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleCreateNestedManyWithoutTestParameterInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterUncheckedCreateWithoutTestResultsInput = {
    id?: string
    agroTestID: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: PricingUncheckedCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleUncheckedCreateNestedManyWithoutTestParameterInput
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterCreateOrConnectWithoutTestResultsInput = {
    where: TestParameterWhereUniqueInput
    create: XOR<TestParameterCreateWithoutTestResultsInput, TestParameterUncheckedCreateWithoutTestResultsInput>
  }

  export type SampleUpsertWithoutTestResultsInput = {
    update: XOR<SampleUpdateWithoutTestResultsInput, SampleUncheckedUpdateWithoutTestResultsInput>
    create: XOR<SampleCreateWithoutTestResultsInput, SampleUncheckedCreateWithoutTestResultsInput>
    where?: SampleWhereInput
  }

  export type SampleUpdateToOneWithWhereWithoutTestResultsInput = {
    where?: SampleWhereInput
    data: XOR<SampleUpdateWithoutTestResultsInput, SampleUncheckedUpdateWithoutTestResultsInput>
  }

  export type SampleUpdateWithoutTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutSamplesNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutSampleNestedInput
    report?: ReportUpdateOneWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateWithoutTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TestParameterUpsertWithoutTestResultsInput = {
    update: XOR<TestParameterUpdateWithoutTestResultsInput, TestParameterUncheckedUpdateWithoutTestResultsInput>
    create: XOR<TestParameterCreateWithoutTestResultsInput, TestParameterUncheckedCreateWithoutTestResultsInput>
    where?: TestParameterWhereInput
  }

  export type TestParameterUpdateToOneWithWhereWithoutTestResultsInput = {
    where?: TestParameterWhereInput
    data: XOR<TestParameterUpdateWithoutTestResultsInput, TestParameterUncheckedUpdateWithoutTestResultsInput>
  }

  export type TestParameterUpdateWithoutTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agroTest?: AgrotestUpdateOneRequiredWithoutTestParameterNestedInput
    pricing?: PricingUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUpdateManyWithoutTestParameterNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterUncheckedUpdateWithoutTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: PricingUncheckedUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUncheckedUpdateManyWithoutTestParameterNestedInput
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterCreateWithoutComparisonRulesInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agroTest: AgrotestCreateNestedOneWithoutTestParameterInput
    pricing?: PricingCreateNestedManyWithoutTestParamaterInput
    testResults?: TestResultCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterUncheckedCreateWithoutComparisonRulesInput = {
    id?: string
    agroTestID: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: PricingUncheckedCreateNestedManyWithoutTestParamaterInput
    testResults?: TestResultUncheckedCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterCreateOrConnectWithoutComparisonRulesInput = {
    where: TestParameterWhereUniqueInput
    create: XOR<TestParameterCreateWithoutComparisonRulesInput, TestParameterUncheckedCreateWithoutComparisonRulesInput>
  }

  export type TestParameterUpsertWithoutComparisonRulesInput = {
    update: XOR<TestParameterUpdateWithoutComparisonRulesInput, TestParameterUncheckedUpdateWithoutComparisonRulesInput>
    create: XOR<TestParameterCreateWithoutComparisonRulesInput, TestParameterUncheckedCreateWithoutComparisonRulesInput>
    where?: TestParameterWhereInput
  }

  export type TestParameterUpdateToOneWithWhereWithoutComparisonRulesInput = {
    where?: TestParameterWhereInput
    data: XOR<TestParameterUpdateWithoutComparisonRulesInput, TestParameterUncheckedUpdateWithoutComparisonRulesInput>
  }

  export type TestParameterUpdateWithoutComparisonRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agroTest?: AgrotestUpdateOneRequiredWithoutTestParameterNestedInput
    pricing?: PricingUpdateManyWithoutTestParamaterNestedInput
    testResults?: TestResultUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterUncheckedUpdateWithoutComparisonRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: PricingUncheckedUpdateManyWithoutTestParamaterNestedInput
    testResults?: TestResultUncheckedUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterCreateWithoutPricingInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agroTest: AgrotestCreateNestedOneWithoutTestParameterInput
    comparisonRules?: ComparisonRuleCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterUncheckedCreateWithoutPricingInput = {
    id?: string
    agroTestID: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comparisonRules?: ComparisonRuleUncheckedCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultUncheckedCreateNestedManyWithoutTestParamaterInput
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutTestParameterInput
  }

  export type TestParameterCreateOrConnectWithoutPricingInput = {
    where: TestParameterWhereUniqueInput
    create: XOR<TestParameterCreateWithoutPricingInput, TestParameterUncheckedCreateWithoutPricingInput>
  }

  export type TestParameterUpsertWithoutPricingInput = {
    update: XOR<TestParameterUpdateWithoutPricingInput, TestParameterUncheckedUpdateWithoutPricingInput>
    create: XOR<TestParameterCreateWithoutPricingInput, TestParameterUncheckedCreateWithoutPricingInput>
    where?: TestParameterWhereInput
  }

  export type TestParameterUpdateToOneWithWhereWithoutPricingInput = {
    where?: TestParameterWhereInput
    data: XOR<TestParameterUpdateWithoutPricingInput, TestParameterUncheckedUpdateWithoutPricingInput>
  }

  export type TestParameterUpdateWithoutPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agroTest?: AgrotestUpdateOneRequiredWithoutTestParameterNestedInput
    comparisonRules?: ComparisonRuleUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterUncheckedUpdateWithoutPricingInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comparisonRules?: ComparisonRuleUncheckedUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUncheckedUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutTestParameterNestedInput
  }

  export type ClientCreateWithoutOrdersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutOrdersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutOrdersInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
  }

  export type UserCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    reports?: ReportCreateNestedManyWithoutGeneratorInput
  }

  export type UserUncheckedCreateWithoutOrdersInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutGeneratorInput
  }

  export type UserCreateOrConnectWithoutOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
  }

  export type SampleCreateWithoutOrderInput = {
    id?: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItem: OrderItemCreateNestedOneWithoutSampleInput
    testResults?: TestResultCreateNestedManyWithoutSampleInput
    report?: ReportCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateWithoutOrderInput = {
    id?: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    testResults?: TestResultUncheckedCreateNestedManyWithoutSampleInput
  }

  export type SampleCreateOrConnectWithoutOrderInput = {
    where: SampleWhereUniqueInput
    create: XOR<SampleCreateWithoutOrderInput, SampleUncheckedCreateWithoutOrderInput>
  }

  export type SampleCreateManyOrderInputEnvelope = {
    data: SampleCreateManyOrderInput | SampleCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemCreateWithoutOrderInput = {
    id?: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    agroTest: AgrotestCreateNestedOneWithoutOrderItemsInput
    orderTestParameters?: OrderTestParameterCreateNestedManyWithoutOrderItemInput
    sample?: SampleCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: string
    agroTestId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderTestParameters?: OrderTestParameterUncheckedCreateNestedManyWithoutOrderItemInput
    sample?: SampleUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutOrderInput = {
    id?: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    client: ClientCreateNestedOneWithoutInvoicesInput
    report?: ReportCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutOrderInput = {
    id?: string
    clientId: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    report?: ReportUncheckedCreateNestedOneWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutOrderInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
  }

  export type ReportCreateWithoutOrderInput = {
    id?: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientCreateNestedOneWithoutReportsInput
    invoice?: InvoiceCreateNestedOneWithoutReportInput
    generator: UserCreateNestedOneWithoutReportsInput
    samples?: SampleCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutOrderInput = {
    id?: string
    clientId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: SampleUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutOrderInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutOrderInput, ReportUncheckedCreateWithoutOrderInput>
  }

  export type ClientUpsertWithoutOrdersInput = {
    update: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
    create: XOR<ClientCreateWithoutOrdersInput, ClientUncheckedCreateWithoutOrdersInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutOrdersInput, ClientUncheckedUpdateWithoutOrdersInput>
  }

  export type ClientUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type UserUpsertWithoutOrdersInput = {
    update: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
    create: XOR<UserCreateWithoutOrdersInput, UserUncheckedCreateWithoutOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOrdersInput, UserUncheckedUpdateWithoutOrdersInput>
  }

  export type UserUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutGeneratorNestedInput
  }

  export type UserUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutGeneratorNestedInput
  }

  export type SampleUpsertWithWhereUniqueWithoutOrderInput = {
    where: SampleWhereUniqueInput
    update: XOR<SampleUpdateWithoutOrderInput, SampleUncheckedUpdateWithoutOrderInput>
    create: XOR<SampleCreateWithoutOrderInput, SampleUncheckedCreateWithoutOrderInput>
  }

  export type SampleUpdateWithWhereUniqueWithoutOrderInput = {
    where: SampleWhereUniqueInput
    data: XOR<SampleUpdateWithoutOrderInput, SampleUncheckedUpdateWithoutOrderInput>
  }

  export type SampleUpdateManyWithWhereWithoutOrderInput = {
    where: SampleScalarWhereInput
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyWithoutOrderInput>
  }

  export type SampleScalarWhereInput = {
    AND?: SampleScalarWhereInput | SampleScalarWhereInput[]
    OR?: SampleScalarWhereInput[]
    NOT?: SampleScalarWhereInput | SampleScalarWhereInput[]
    id?: StringFilter<"Sample"> | string
    orderId?: StringFilter<"Sample"> | string
    orderItemId?: StringFilter<"Sample"> | string
    sampleIdNumber?: StringFilter<"Sample"> | string
    collectionDate?: DateTimeFilter<"Sample"> | Date | string
    sampleType?: EnumSampleTypeFilter<"Sample"> | $Enums.SampleType
    collectionLocation?: StringNullableFilter<"Sample"> | string | null
    cropType?: StringNullableFilter<"Sample"> | string | null
    bunot?: StringNullableFilter<"Sample"> | string | null
    manchitroUnit?: IntNullableFilter<"Sample"> | number | null
    vumiSrini?: StringNullableFilter<"Sample"> | string | null
    status?: EnumSampleStatusFilter<"Sample"> | $Enums.SampleStatus
    createdAt?: DateTimeFilter<"Sample"> | Date | string
    updatedAt?: DateTimeFilter<"Sample"> | Date | string
    reportId?: StringNullableFilter<"Sample"> | string | null
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type InvoiceUpsertWithoutOrderInput = {
    update: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
    create: XOR<InvoiceCreateWithoutOrderInput, InvoiceUncheckedCreateWithoutOrderInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutOrderInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutOrderInput, InvoiceUncheckedUpdateWithoutOrderInput>
  }

  export type InvoiceUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
    report?: ReportUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ReportUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type ReportUpsertWithoutOrderInput = {
    update: XOR<ReportUpdateWithoutOrderInput, ReportUncheckedUpdateWithoutOrderInput>
    create: XOR<ReportCreateWithoutOrderInput, ReportUncheckedCreateWithoutOrderInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutOrderInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutOrderInput, ReportUncheckedUpdateWithoutOrderInput>
  }

  export type ReportUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientUpdateOneRequiredWithoutReportsNestedInput
    invoice?: InvoiceUpdateOneWithoutReportNestedInput
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
    samples?: SampleUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: SampleUncheckedUpdateManyWithoutReportNestedInput
  }

  export type OrderCreateWithoutOrderItemsInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    operator: UserCreateNestedOneWithoutOrdersInput
    samples?: SampleCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
    report?: ReportCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    samples?: SampleUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
    report?: ReportUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderItemsInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type AgrotestCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
    testParameter?: TestParameterCreateNestedManyWithoutAgroTestInput
  }

  export type AgrotestUncheckedCreateWithoutOrderItemsInput = {
    id?: string
    name: string
    sampleType: $Enums.SampleType
    createdAt?: Date | string
    updatedAt?: Date | string
    testParameter?: TestParameterUncheckedCreateNestedManyWithoutAgroTestInput
  }

  export type AgrotestCreateOrConnectWithoutOrderItemsInput = {
    where: AgrotestWhereUniqueInput
    create: XOR<AgrotestCreateWithoutOrderItemsInput, AgrotestUncheckedCreateWithoutOrderItemsInput>
  }

  export type OrderTestParameterCreateWithoutOrderItemInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    testParameter: TestParameterCreateNestedOneWithoutOrderTestParametersInput
  }

  export type OrderTestParameterUncheckedCreateWithoutOrderItemInput = {
    id?: string
    testParameterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderTestParameterCreateOrConnectWithoutOrderItemInput = {
    where: OrderTestParameterWhereUniqueInput
    create: XOR<OrderTestParameterCreateWithoutOrderItemInput, OrderTestParameterUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderTestParameterCreateManyOrderItemInputEnvelope = {
    data: OrderTestParameterCreateManyOrderItemInput | OrderTestParameterCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type SampleCreateWithoutOrderItemInput = {
    id?: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutSamplesInput
    testResults?: TestResultCreateNestedManyWithoutSampleInput
    report?: ReportCreateNestedOneWithoutSamplesInput
  }

  export type SampleUncheckedCreateWithoutOrderItemInput = {
    id?: string
    orderId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    testResults?: TestResultUncheckedCreateNestedManyWithoutSampleInput
  }

  export type SampleCreateOrConnectWithoutOrderItemInput = {
    where: SampleWhereUniqueInput
    create: XOR<SampleCreateWithoutOrderItemInput, SampleUncheckedCreateWithoutOrderItemInput>
  }

  export type SampleCreateManyOrderItemInputEnvelope = {
    data: SampleCreateManyOrderItemInput | SampleCreateManyOrderItemInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutOrderItemsInput = {
    update: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<OrderCreateWithoutOrderItemsInput, OrderUncheckedCreateWithoutOrderItemsInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutOrderItemsInput, OrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type OrderUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    operator?: UserUpdateOneRequiredWithoutOrdersNestedInput
    samples?: SampleUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    report?: ReportUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    samples?: SampleUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    report?: ReportUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type AgrotestUpsertWithoutOrderItemsInput = {
    update: XOR<AgrotestUpdateWithoutOrderItemsInput, AgrotestUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<AgrotestCreateWithoutOrderItemsInput, AgrotestUncheckedCreateWithoutOrderItemsInput>
    where?: AgrotestWhereInput
  }

  export type AgrotestUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: AgrotestWhereInput
    data: XOR<AgrotestUpdateWithoutOrderItemsInput, AgrotestUncheckedUpdateWithoutOrderItemsInput>
  }

  export type AgrotestUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParameter?: TestParameterUpdateManyWithoutAgroTestNestedInput
  }

  export type AgrotestUncheckedUpdateWithoutOrderItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParameter?: TestParameterUncheckedUpdateManyWithoutAgroTestNestedInput
  }

  export type OrderTestParameterUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: OrderTestParameterWhereUniqueInput
    update: XOR<OrderTestParameterUpdateWithoutOrderItemInput, OrderTestParameterUncheckedUpdateWithoutOrderItemInput>
    create: XOR<OrderTestParameterCreateWithoutOrderItemInput, OrderTestParameterUncheckedCreateWithoutOrderItemInput>
  }

  export type OrderTestParameterUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: OrderTestParameterWhereUniqueInput
    data: XOR<OrderTestParameterUpdateWithoutOrderItemInput, OrderTestParameterUncheckedUpdateWithoutOrderItemInput>
  }

  export type OrderTestParameterUpdateManyWithWhereWithoutOrderItemInput = {
    where: OrderTestParameterScalarWhereInput
    data: XOR<OrderTestParameterUpdateManyMutationInput, OrderTestParameterUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type SampleUpsertWithWhereUniqueWithoutOrderItemInput = {
    where: SampleWhereUniqueInput
    update: XOR<SampleUpdateWithoutOrderItemInput, SampleUncheckedUpdateWithoutOrderItemInput>
    create: XOR<SampleCreateWithoutOrderItemInput, SampleUncheckedCreateWithoutOrderItemInput>
  }

  export type SampleUpdateWithWhereUniqueWithoutOrderItemInput = {
    where: SampleWhereUniqueInput
    data: XOR<SampleUpdateWithoutOrderItemInput, SampleUncheckedUpdateWithoutOrderItemInput>
  }

  export type SampleUpdateManyWithWhereWithoutOrderItemInput = {
    where: SampleScalarWhereInput
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyWithoutOrderItemInput>
  }

  export type OrderItemCreateWithoutOrderTestParametersInput = {
    id?: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutOrderItemsInput
    agroTest: AgrotestCreateNestedOneWithoutOrderItemsInput
    sample?: SampleCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemUncheckedCreateWithoutOrderTestParametersInput = {
    id?: string
    orderId: string
    agroTestId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sample?: SampleUncheckedCreateNestedManyWithoutOrderItemInput
  }

  export type OrderItemCreateOrConnectWithoutOrderTestParametersInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderTestParametersInput, OrderItemUncheckedCreateWithoutOrderTestParametersInput>
  }

  export type TestParameterCreateWithoutOrderTestParametersInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agroTest: AgrotestCreateNestedOneWithoutTestParameterInput
    pricing?: PricingCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultCreateNestedManyWithoutTestParamaterInput
  }

  export type TestParameterUncheckedCreateWithoutOrderTestParametersInput = {
    id?: string
    agroTestID: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricing?: PricingUncheckedCreateNestedManyWithoutTestParamaterInput
    comparisonRules?: ComparisonRuleUncheckedCreateNestedManyWithoutTestParameterInput
    testResults?: TestResultUncheckedCreateNestedManyWithoutTestParamaterInput
  }

  export type TestParameterCreateOrConnectWithoutOrderTestParametersInput = {
    where: TestParameterWhereUniqueInput
    create: XOR<TestParameterCreateWithoutOrderTestParametersInput, TestParameterUncheckedCreateWithoutOrderTestParametersInput>
  }

  export type OrderItemUpsertWithoutOrderTestParametersInput = {
    update: XOR<OrderItemUpdateWithoutOrderTestParametersInput, OrderItemUncheckedUpdateWithoutOrderTestParametersInput>
    create: XOR<OrderItemCreateWithoutOrderTestParametersInput, OrderItemUncheckedCreateWithoutOrderTestParametersInput>
    where?: OrderItemWhereInput
  }

  export type OrderItemUpdateToOneWithWhereWithoutOrderTestParametersInput = {
    where?: OrderItemWhereInput
    data: XOR<OrderItemUpdateWithoutOrderTestParametersInput, OrderItemUncheckedUpdateWithoutOrderTestParametersInput>
  }

  export type OrderItemUpdateWithoutOrderTestParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    agroTest?: AgrotestUpdateOneRequiredWithoutOrderItemsNestedInput
    sample?: SampleUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderTestParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    agroTestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sample?: SampleUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type TestParameterUpsertWithoutOrderTestParametersInput = {
    update: XOR<TestParameterUpdateWithoutOrderTestParametersInput, TestParameterUncheckedUpdateWithoutOrderTestParametersInput>
    create: XOR<TestParameterCreateWithoutOrderTestParametersInput, TestParameterUncheckedCreateWithoutOrderTestParametersInput>
    where?: TestParameterWhereInput
  }

  export type TestParameterUpdateToOneWithWhereWithoutOrderTestParametersInput = {
    where?: TestParameterWhereInput
    data: XOR<TestParameterUpdateWithoutOrderTestParametersInput, TestParameterUncheckedUpdateWithoutOrderTestParametersInput>
  }

  export type TestParameterUpdateWithoutOrderTestParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agroTest?: AgrotestUpdateOneRequiredWithoutTestParameterNestedInput
    pricing?: PricingUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUpdateManyWithoutTestParamaterNestedInput
  }

  export type TestParameterUncheckedUpdateWithoutOrderTestParametersInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestID?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: PricingUncheckedUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUncheckedUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUncheckedUpdateManyWithoutTestParamaterNestedInput
  }

  export type OrderCreateWithoutInvoiceInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    operator: UserCreateNestedOneWithoutOrdersInput
    samples?: SampleCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    report?: ReportCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutInvoiceInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    samples?: SampleUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    report?: ReportUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutInvoiceInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
  }

  export type ClientCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutInvoicesInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
  }

  export type ReportCreateWithoutInvoiceInput = {
    id?: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutReportInput
    client: ClientCreateNestedOneWithoutReportsInput
    generator: UserCreateNestedOneWithoutReportsInput
    samples?: SampleCreateNestedManyWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutInvoiceInput = {
    id?: string
    orderId: string
    clientId: string
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    samples?: SampleUncheckedCreateNestedManyWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutInvoiceInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutInvoiceInput, ReportUncheckedCreateWithoutInvoiceInput>
  }

  export type OrderUpsertWithoutInvoiceInput = {
    update: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
    create: XOR<OrderCreateWithoutInvoiceInput, OrderUncheckedCreateWithoutInvoiceInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutInvoiceInput, OrderUncheckedUpdateWithoutInvoiceInput>
  }

  export type OrderUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    operator?: UserUpdateOneRequiredWithoutOrdersNestedInput
    samples?: SampleUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    report?: ReportUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    samples?: SampleUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    report?: ReportUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ClientUpsertWithoutInvoicesInput = {
    update: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ClientCreateWithoutInvoicesInput, ClientUncheckedCreateWithoutInvoicesInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutInvoicesInput, ClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type ClientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ReportUpsertWithoutInvoiceInput = {
    update: XOR<ReportUpdateWithoutInvoiceInput, ReportUncheckedUpdateWithoutInvoiceInput>
    create: XOR<ReportCreateWithoutInvoiceInput, ReportUncheckedCreateWithoutInvoiceInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutInvoiceInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutInvoiceInput, ReportUncheckedUpdateWithoutInvoiceInput>
  }

  export type ReportUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReportNestedInput
    client?: ClientUpdateOneRequiredWithoutReportsNestedInput
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
    samples?: SampleUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: SampleUncheckedUpdateManyWithoutReportNestedInput
  }

  export type OrderCreateWithoutReportInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    client: ClientCreateNestedOneWithoutOrdersInput
    operator: UserCreateNestedOneWithoutOrdersInput
    samples?: SampleCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    invoice?: InvoiceCreateNestedOneWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReportInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
    samples?: SampleUncheckedCreateNestedManyWithoutOrderInput
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    invoice?: InvoiceUncheckedCreateNestedOneWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReportInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReportInput, OrderUncheckedCreateWithoutReportInput>
  }

  export type ClientCreateWithoutReportsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type ClientUncheckedCreateWithoutReportsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    clientType: $Enums.ClientType
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientCreateOrConnectWithoutReportsInput = {
    where: ClientWhereUniqueInput
    create: XOR<ClientCreateWithoutReportsInput, ClientUncheckedCreateWithoutReportsInput>
  }

  export type InvoiceCreateWithoutReportInput = {
    id?: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
    order: OrderCreateNestedOneWithoutInvoiceInput
    client: ClientCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutReportInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type InvoiceCreateOrConnectWithoutReportInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutReportInput, InvoiceUncheckedCreateWithoutReportInput>
  }

  export type UserCreateWithoutReportsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOperatorInput
  }

  export type UserUncheckedCreateWithoutReportsInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOperatorInput
  }

  export type UserCreateOrConnectWithoutReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
  }

  export type SampleCreateWithoutReportInput = {
    id?: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    order: OrderCreateNestedOneWithoutSamplesInput
    orderItem: OrderItemCreateNestedOneWithoutSampleInput
    testResults?: TestResultCreateNestedManyWithoutSampleInput
  }

  export type SampleUncheckedCreateWithoutReportInput = {
    id?: string
    orderId: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    testResults?: TestResultUncheckedCreateNestedManyWithoutSampleInput
  }

  export type SampleCreateOrConnectWithoutReportInput = {
    where: SampleWhereUniqueInput
    create: XOR<SampleCreateWithoutReportInput, SampleUncheckedCreateWithoutReportInput>
  }

  export type SampleCreateManyReportInputEnvelope = {
    data: SampleCreateManyReportInput | SampleCreateManyReportInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithoutReportInput = {
    update: XOR<OrderUpdateWithoutReportInput, OrderUncheckedUpdateWithoutReportInput>
    create: XOR<OrderCreateWithoutReportInput, OrderUncheckedCreateWithoutReportInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReportInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReportInput, OrderUncheckedUpdateWithoutReportInput>
  }

  export type OrderUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    operator?: UserUpdateOneRequiredWithoutOrdersNestedInput
    samples?: SampleUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    samples?: SampleUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type ClientUpsertWithoutReportsInput = {
    update: XOR<ClientUpdateWithoutReportsInput, ClientUncheckedUpdateWithoutReportsInput>
    create: XOR<ClientCreateWithoutReportsInput, ClientUncheckedCreateWithoutReportsInput>
    where?: ClientWhereInput
  }

  export type ClientUpdateToOneWithWhereWithoutReportsInput = {
    where?: ClientWhereInput
    data: XOR<ClientUpdateWithoutReportsInput, ClientUncheckedUpdateWithoutReportsInput>
  }

  export type ClientUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type ClientUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type InvoiceUpsertWithoutReportInput = {
    update: XOR<InvoiceUpdateWithoutReportInput, InvoiceUncheckedUpdateWithoutReportInput>
    create: XOR<InvoiceCreateWithoutReportInput, InvoiceUncheckedCreateWithoutReportInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutReportInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutReportInput, InvoiceUncheckedUpdateWithoutReportInput>
  }

  export type InvoiceUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
    client?: ClientUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutReportsInput = {
    update: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
    create: XOR<UserCreateWithoutReportsInput, UserUncheckedCreateWithoutReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReportsInput, UserUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOperatorNestedInput
  }

  export type UserUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOperatorNestedInput
  }

  export type SampleUpsertWithWhereUniqueWithoutReportInput = {
    where: SampleWhereUniqueInput
    update: XOR<SampleUpdateWithoutReportInput, SampleUncheckedUpdateWithoutReportInput>
    create: XOR<SampleCreateWithoutReportInput, SampleUncheckedCreateWithoutReportInput>
  }

  export type SampleUpdateWithWhereUniqueWithoutReportInput = {
    where: SampleWhereUniqueInput
    data: XOR<SampleUpdateWithoutReportInput, SampleUncheckedUpdateWithoutReportInput>
  }

  export type SampleUpdateManyWithWhereWithoutReportInput = {
    where: SampleScalarWhereInput
    data: XOR<SampleUpdateManyMutationInput, SampleUncheckedUpdateManyWithoutReportInput>
  }

  export type OrderCreateManyOperatorInput = {
    id?: string
    clientId: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
  }

  export type ReportCreateManyGeneratorInput = {
    id?: string
    orderId: string
    clientId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientUpdateOneRequiredWithoutOrdersNestedInput
    samples?: SampleUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    report?: ReportUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    samples?: SampleUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    report?: ReportUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOperatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReportNestedInput
    client?: ClientUpdateOneRequiredWithoutReportsNestedInput
    invoice?: InvoiceUpdateOneWithoutReportNestedInput
    samples?: SampleUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: SampleUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutGeneratorInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyClientInput = {
    id?: string
    sarokNumber?: string | null
    orderDate?: Date | string
    status?: $Enums.OrderStatus
    operatorId: string
    totalAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    invoiceId?: string | null
    reportId?: string | null
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    orderId: string
    invoiceDate?: Date | string
    dueDate?: Date | string | null
    totalAmount: number
    paidAmount?: number
    status: $Enums.InvoiceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type ReportCreateManyClientInput = {
    id?: string
    orderId: string
    invoiceId?: string | null
    reportType?: string
    reportNumber: string
    issueDate?: Date | string
    status?: $Enums.ReportStatus
    recommendations?: string | null
    notes?: string | null
    generatedByUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    operator?: UserUpdateOneRequiredWithoutOrdersNestedInput
    samples?: SampleUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUpdateOneWithoutOrderNestedInput
    report?: ReportUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    samples?: SampleUncheckedUpdateManyWithoutOrderNestedInput
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    invoice?: InvoiceUncheckedUpdateOneWithoutOrderNestedInput
    report?: ReportUncheckedUpdateOneWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    sarokNumber?: NullableStringFieldUpdateOperationsInput | string | null
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumOrderStatusFieldUpdateOperationsInput | $Enums.OrderStatus
    operatorId?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneRequiredWithoutInvoiceNestedInput
    report?: ReportUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    report?: ReportUncheckedUpdateOneWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutReportNestedInput
    invoice?: InvoiceUpdateOneWithoutReportNestedInput
    generator?: UserUpdateOneRequiredWithoutReportsNestedInput
    samples?: SampleUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    samples?: SampleUncheckedUpdateManyWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    invoiceId?: NullableStringFieldUpdateOperationsInput | string | null
    reportType?: StringFieldUpdateOperationsInput | string
    reportNumber?: StringFieldUpdateOperationsInput | string
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReportStatusFieldUpdateOperationsInput | $Enums.ReportStatus
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    generatedByUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestParameterCreateManyAgroTestInput = {
    id?: string
    name: string
    unit?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderItemCreateManyAgroTestInput = {
    id?: string
    orderId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestParameterUpdateWithoutAgroTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: PricingUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterUncheckedUpdateWithoutAgroTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricing?: PricingUncheckedUpdateManyWithoutTestParamaterNestedInput
    comparisonRules?: ComparisonRuleUncheckedUpdateManyWithoutTestParameterNestedInput
    testResults?: TestResultUncheckedUpdateManyWithoutTestParamaterNestedInput
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutTestParameterNestedInput
  }

  export type TestParameterUncheckedUpdateManyWithoutAgroTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemUpdateWithoutAgroTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutOrderItemsNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutOrderItemNestedInput
    sample?: SampleUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutAgroTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutOrderItemNestedInput
    sample?: SampleUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutAgroTestInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingCreateManyTestParamaterInput = {
    id?: string
    clientType: $Enums.ClientType
    price: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComparisonRuleCreateManyTestParameterInput = {
    id?: string
    soilCategory?: $Enums.SoilCategory | null
    min?: number | null
    max?: number | null
    interpretation?: string | null
    type?: $Enums.ComparisonType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestResultCreateManyTestParamaterInput = {
    id?: string
    sampleId: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderTestParameterCreateManyTestParameterInput = {
    id?: string
    orderItemId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PricingUpdateWithoutTestParamaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingUncheckedUpdateWithoutTestParamaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingUncheckedUpdateManyWithoutTestParamaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientType?: EnumClientTypeFieldUpdateOperationsInput | $Enums.ClientType
    price?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparisonRuleUpdateWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparisonRuleUncheckedUpdateWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComparisonRuleUncheckedUpdateManyWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    soilCategory?: NullableEnumSoilCategoryFieldUpdateOperationsInput | $Enums.SoilCategory | null
    min?: NullableFloatFieldUpdateOperationsInput | number | null
    max?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumComparisonTypeFieldUpdateOperationsInput | $Enums.ComparisonType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUpdateWithoutTestParamaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sample?: SampleUpdateOneRequiredWithoutTestResultsNestedInput
  }

  export type TestResultUncheckedUpdateWithoutTestParamaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleId?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateManyWithoutTestParamaterInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleId?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterUpdateWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutOrderTestParametersNestedInput
  }

  export type OrderTestParameterUncheckedUpdateWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterUncheckedUpdateManyWithoutTestParameterInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultCreateManySampleInput = {
    id?: string
    testParameterId: string
    value?: number | null
    interpretation?: string | null
    uplandInterpretation?: string | null
    wetlandInterpretation?: string | null
    analysisType?: $Enums.AnalysisType | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TestResultUpdateWithoutSampleInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParamater?: TestParameterUpdateOneRequiredWithoutTestResultsNestedInput
  }

  export type TestResultUncheckedUpdateWithoutSampleInput = {
    id?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TestResultUncheckedUpdateManyWithoutSampleInput = {
    id?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    value?: NullableFloatFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    uplandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    wetlandInterpretation?: NullableStringFieldUpdateOperationsInput | string | null
    analysisType?: NullableEnumAnalysisTypeFieldUpdateOperationsInput | $Enums.AnalysisType | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleCreateManyOrderInput = {
    id?: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: string
    agroTestId: string
    quantity?: number
    unitPrice: number
    subtotal: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItem?: OrderItemUpdateOneRequiredWithoutSampleNestedInput
    testResults?: TestResultUpdateManyWithoutSampleNestedInput
    report?: ReportUpdateOneWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    testResults?: TestResultUncheckedUpdateManyWithoutSampleNestedInput
  }

  export type SampleUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agroTest?: AgrotestUpdateOneRequiredWithoutOrderItemsNestedInput
    orderTestParameters?: OrderTestParameterUpdateManyWithoutOrderItemNestedInput
    sample?: SampleUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderTestParameters?: OrderTestParameterUncheckedUpdateManyWithoutOrderItemNestedInput
    sample?: SampleUncheckedUpdateManyWithoutOrderItemNestedInput
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    agroTestId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    subtotal?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterCreateManyOrderItemInput = {
    id?: string
    testParameterId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleCreateManyOrderItemInput = {
    id?: string
    orderId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    reportId?: string | null
  }

  export type OrderTestParameterUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testParameter?: TestParameterUpdateOneRequiredWithoutOrderTestParametersNestedInput
  }

  export type OrderTestParameterUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderTestParameterUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    testParameterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SampleUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutSamplesNestedInput
    testResults?: TestResultUpdateManyWithoutSampleNestedInput
    report?: ReportUpdateOneWithoutSamplesNestedInput
  }

  export type SampleUncheckedUpdateWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
    testResults?: TestResultUncheckedUpdateManyWithoutSampleNestedInput
  }

  export type SampleUncheckedUpdateManyWithoutOrderItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reportId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SampleCreateManyReportInput = {
    id?: string
    orderId: string
    orderItemId: string
    sampleIdNumber: string
    collectionDate: Date | string
    sampleType: $Enums.SampleType
    collectionLocation?: string | null
    cropType?: string | null
    bunot?: string | null
    manchitroUnit?: number | null
    vumiSrini?: string | null
    status?: $Enums.SampleStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SampleUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    order?: OrderUpdateOneRequiredWithoutSamplesNestedInput
    orderItem?: OrderItemUpdateOneRequiredWithoutSampleNestedInput
    testResults?: TestResultUpdateManyWithoutSampleNestedInput
  }

  export type SampleUncheckedUpdateWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    testResults?: TestResultUncheckedUpdateManyWithoutSampleNestedInput
  }

  export type SampleUncheckedUpdateManyWithoutReportInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    orderItemId?: StringFieldUpdateOperationsInput | string
    sampleIdNumber?: StringFieldUpdateOperationsInput | string
    collectionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    sampleType?: EnumSampleTypeFieldUpdateOperationsInput | $Enums.SampleType
    collectionLocation?: NullableStringFieldUpdateOperationsInput | string | null
    cropType?: NullableStringFieldUpdateOperationsInput | string | null
    bunot?: NullableStringFieldUpdateOperationsInput | string | null
    manchitroUnit?: NullableIntFieldUpdateOperationsInput | number | null
    vumiSrini?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSampleStatusFieldUpdateOperationsInput | $Enums.SampleStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}